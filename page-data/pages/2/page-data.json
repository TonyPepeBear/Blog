{"componentChunkName":"component---src-templates-article-list-page-template-tsx","path":"/pages/2","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"9b4fd17c-47e0-5706-ae0f-62acdd29fab4","html":"<p>Kotlin 在多工處理上提供非常好用的 Coroutine。當不同 Job 之間需要傳遞資料時，總會遇到許多問題，以前最簡單的方式就是 Callback，但 Callback 模式已經在各個程式語言中產生許多問題，這邊就不多討論。Kotlin Coroutine 如果只是要回傳一個值，可以直接用 Suspend 的 Return 值，但如果是要回傳很多資料呢？簡單的方式是直接回傳 List，可是如果資料非常大，也會產生出問題。所以 Kotlin 提供 Flow 來幫助解決大量資料傳遞的問題。</p>\n<!--more-->\n<h2>Kotline Coroutine</h2>\n<p>如果還不知道什麼是 Coroutine 的，我以前也有寫過<a href=\"/posts/kotlin/kotlin-coroutine/\">Kotlin Coroutine</a>。</p>\n<h2>List OF Numbers</h2>\n<p>讓我們先來看一個簡單的範例，產生一個會回傳 1 到 100 的 Int Function：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> ans <span class=\"token operator\">=</span> mutableListOf<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ans<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> ans\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span> <span class=\"token punctuation\">{</span> value <span class=\"token operator\">-></span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>乍看之下沒什麼問題，但是如果這是一個需要大量 CPU 或 IO 處理的工作而且回傳值非常大，就會對記憶體產生負擔。下面假設我們需要 1 到 100,000，並用 <code class=\"language-text\">delay()</code> 模擬 CPU 工作，然後改成 Suspend Function。下面也把 main 改成 <code class=\"language-text\">runBlocking</code>，方便執行 Suspend Function：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> ans <span class=\"token operator\">=</span> mutableListOf<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">100_000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n        ans<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> ans\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span> <span class=\"token punctuation\">{</span> value <span class=\"token operator\">-></span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的範例就會對記憶體產生一定的負擔，這時就是改成 Flow 的好時機：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">100_000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以看到上面的範例沒有一次產生一個很大的 List，再一次把資料回傳，寫的也可以更簡潔。</p>\n<h2>Flow is Cold</h2>\n<p>這句話的意思是，如果 Flow 沒有被 Collect，那麼 Flow 就永遠不會被執行。</p>\n<p>下面的例子我們在 Emit 前加上一個 <code class=\"language-text\">println</code> ，並用一個變數接住一個 Flow，但不去呼叫 Collect，所以會先輸出 <code class=\"language-text\">Hello World</code> 才會輸出 <code class=\"language-text\">Start Flow</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Start Flow\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> n<span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello World\"</span></span><span class=\"token punctuation\">)</span>\n    n<span class=\"token punctuation\">.</span><span class=\"token function\">collect</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>輸出：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Hello World\nStart Flow\n1\n2\n3\n4\n5</code></pre></div>\n<h2>Emit 時 才會呼叫 Collect</h2>\n<p>把上面的例子再 emit 前加上一個 <code class=\"language-text\">println()</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Start Flow\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"emit </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">i</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> n<span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello World\"</span></span><span class=\"token punctuation\">)</span>\n    n<span class=\"token punctuation\">.</span><span class=\"token function\">collect</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>看到輸出可以發現，會先看到 emit() 上面的 print 被執行，才會執行到呼叫 collect 時傳進去的 function。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Hello World\nStart Flow\nemit 1\n1\nemit 2\n2\nemit 3\n3\nemit 4\n4\nemit 5\n5</code></pre></div>\n<h2>Flow 的資料量是固定的</h2>\n<p>這句話的意思並不是說 flow 只能定義好數量再回傳，而是說如果 flow 裡的所有 emit 沒有被 collect，就會出錯。</p>\n<p>下面的 flow 就一定要被 collect 五次，如果因為呼叫他的 function 被意外中斷，這個 flow 也會拋出錯誤。</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>那麼如果我只要一定數量的資料怎麼辦？下面範例取自官方文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">numbers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"This line will not execute\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Finally in numbers\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">numbers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// take only the first two</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">collect</span> <span class=\"token punctuation\">{</span> value <span class=\"token operator\">-></span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/* output:\n1\n2\nFinally in numbers\n*/</span></code></pre></div>\n<h2>Flow mapping</h2>\n<p>Flow 可以用 map 的方式，轉換成另一個 Flow。</p>\n<p>這個例子產生平方數：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">allNumbers</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">square</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">allNumbers</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span> <span class=\"token punctuation\">{</span> it <span class=\"token operator\">*</span> it <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">square</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">it</span></span><span class=\"token string\"> \"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// output: 1 4 9 16 25 36 49 64 81 100</span></code></pre></div>\n<h2>Flow Filter</h2>\n<p>這個例子輸出 1 到 100 之間的所有質數(勿模仿，效率堪憂)：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">allNumbers</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">primeNumbers</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">allNumbers</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span> <span class=\"token punctuation\">{</span> it<span class=\"token punctuation\">.</span><span class=\"token function\">isPrime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> Int<span class=\"token punctuation\">.</span><span class=\"token function\">isPrime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Boolean <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">2</span><span class=\"token operator\">..</span>this <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">%</span> i <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">primeNumbers</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">it</span></span><span class=\"token string\"> \"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// output: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97</span></code></pre></div>\n<blockquote>\n<p>碎念：這段程式真的充分展現 Kotlin 的威力..</p>\n</blockquote>\n<h2>後記</h2>\n<p>Flow 還有很多複雜的用法，像是合併兩個 flow 之類的，建議有興趣的人可以自己去看官方文件。</p>\n<p>另外，Kotlin 其實還有一個叫做 Sequence 的 Interface，跟 Flow 非常像，在不是需要多線程的時候就已經很夠用，Flow 主要在多線程中使用，Sequence 單線程中使用。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://kotlinlang.org/docs/flow.html\">Asynchronous Flow</a></li>\n</ul>","rawMarkdownBody":"\nKotlin 在多工處理上提供非常好用的 Coroutine。當不同 Job 之間需要傳遞資料時，總會遇到許多問題，以前最簡單的方式就是 Callback，但 Callback 模式已經在各個程式語言中產生許多問題，這邊就不多討論。Kotlin Coroutine 如果只是要回傳一個值，可以直接用 Suspend 的 Return 值，但如果是要回傳很多資料呢？簡單的方式是直接回傳 List，可是如果資料非常大，也會產生出問題。所以 Kotlin 提供 Flow 來幫助解決大量資料傳遞的問題。\n\n<!--more-->\n\n## Kotline Coroutine\n\n如果還不知道什麼是 Coroutine 的，我以前也有寫過[Kotlin Coroutine](/posts/kotlin/kotlin-coroutine/)。\n\n## List OF Numbers\n\n讓我們先來看一個簡單的範例，產生一個會回傳 1 到 100 的 Int Function：\n\n```kotlin\nfun nums(): List<Int> {\n    val ans = mutableListOf<Int>()\n    for (i in 1..100) {\n        ans.add(i)\n    }\n    return ans\n}\n\nfun main() {\n    nums().forEach { value ->\n        println(value)\n    }\n}\n```\n\n乍看之下沒什麼問題，但是如果這是一個需要大量 CPU 或 IO 處理的工作而且回傳值非常大，就會對記憶體產生負擔。下面假設我們需要 1 到 100,000，並用 `delay()` 模擬 CPU 工作，然後改成 Suspend Function。下面也把 main 改成 `runBlocking`，方便執行 Suspend Function：\n\n```kotlin\nsuspend fun nums(): List<Int> {\n    val ans = mutableListOf<Int>()\n    for (i in 1..100_000) {\n        delay(100)\n        ans.add(i)\n    }\n    return ans\n}\n\nfun main() = runBlocking {\n    nums().forEach { value ->\n        println(value)\n    }\n}\n```\n\n上面的範例就會對記憶體產生一定的負擔，這時就是改成 Flow 的好時機：\n\n```kotlin\nsuspend fun nums(): Flow<Int> = flow {\n    for (i in 1..100_000) {\n        delay(100)\n        emit(i)\n    }\n}\n\nfun main() = runBlocking {\n    nums().collect {\n        println(it)\n    }\n}\n```\n\n可以看到上面的範例沒有一次產生一個很大的 List，再一次把資料回傳，寫的也可以更簡潔。\n\n## Flow is Cold\n\n這句話的意思是，如果 Flow 沒有被 Collect，那麼 Flow 就永遠不會被執行。\n\n下面的例子我們在 Emit 前加上一個 `println` ，並用一個變數接住一個 Flow，但不去呼叫 Collect，所以會先輸出 `Hello World` 才會輸出 `Start Flow`。\n\n```kotlin\nsuspend fun nums(): Flow<Int> = flow {\n    println(\"Start Flow\")\n    for (i in 1..5) {\n        delay(100)\n        emit(i)\n    }\n}\n\nfun main() = runBlocking {\n    var n: Flow<Int> = nums()\n    println(\"Hello World\")\n    n.collect {\n        println(it)\n    }\n}\n```\n\n輸出：\n\n```text\nHello World\nStart Flow\n1\n2\n3\n4\n5\n```\n\n## Emit 時 才會呼叫 Collect\n\n把上面的例子再 emit 前加上一個 `println()`：\n\n```kotlin\nsuspend fun nums(): Flow<Int> = flow {\n    println(\"Start Flow\")\n    for (i in 1..5) {\n        delay(100)\n        println(\"emit $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking {\n    var n: Flow<Int> = nums()\n    println(\"Hello World\")\n    n.collect {\n        println(it)\n    }\n}\n```\n\n看到輸出可以發現，會先看到 emit() 上面的 print 被執行，才會執行到呼叫 collect 時傳進去的 function。\n\n```text\nHello World\nStart Flow\nemit 1\n1\nemit 2\n2\nemit 3\n3\nemit 4\n4\nemit 5\n5\n```\n\n## Flow 的資料量是固定的\n\n這句話的意思並不是說 flow 只能定義好數量再回傳，而是說如果 flow 裡的所有 emit 沒有被 collect，就會出錯。\n\n下面的 flow 就一定要被 collect 五次，如果因為呼叫他的 function 被意外中斷，這個 flow 也會拋出錯誤。\n\n```kotlin\nsuspend fun nums(): Flow<Int> = flow {\n    for (i in 1..5) {\n        emit(i)\n    }\n}\n```\n\n那麼如果我只要一定數量的資料怎麼辦？下面範例取自官方文件：\n\n```kotlin\nfun numbers(): Flow<Int> = flow {\n    try {\n        emit(1)\n        emit(2)\n        println(\"This line will not execute\")\n        emit(3)\n    } finally {\n        println(\"Finally in numbers\")\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    numbers()\n        .take(2) // take only the first two\n        .collect { value -> println(value) }\n}\n\n/* output:\n1\n2\nFinally in numbers\n*/\n```\n\n## Flow mapping\n\nFlow 可以用 map 的方式，轉換成另一個 Flow。\n\n這個例子產生平方數：\n\n```kotlin\nsuspend fun allNumbers(n: Int): Flow<Int> = flow {\n    for (i in 1..n) {\n        emit(i)\n    }\n}\n\nsuspend fun square(n: Int): Flow<Int> = allNumbers(n).map { it * it }\n\nfun main() = runBlocking {\n    square(10).collect {\n        print(\"$it \")\n    }\n}\n\n// output: 1 4 9 16 25 36 49 64 81 100\n```\n\n## Flow Filter\n\n這個例子輸出 1 到 100 之間的所有質數(勿模仿，效率堪憂)：\n\n```kotlin\nsuspend fun allNumbers(n: Int): Flow<Int> = flow {\n    for (i in 1..n) {\n        emit(i)\n    }\n}\n\nsuspend fun primeNumbers(n: Int): Flow<Int> = allNumbers(n).filter { it.isPrime() }\n\nfun Int.isPrime(): Boolean {\n    if (this <= 1) return false\n    for (i in 2..this / 2) {\n        if (this % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun main() = runBlocking {\n    primeNumbers(100).collect {\n        print(\"$it \")\n    }\n}\n\n// output: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97\n```\n\n> 碎念：這段程式真的充分展現 Kotlin 的威力..\n\n## 後記\n\nFlow 還有很多複雜的用法，像是合併兩個 flow 之類的，建議有興趣的人可以自己去看官方文件。\n\n另外，Kotlin 其實還有一個叫做 Sequence 的 Interface，跟 Flow 非常像，在不是需要多線程的時候就已經很夠用，Flow 主要在多線程中使用，Sequence 單線程中使用。\n\n## Reference\n\n- [Asynchronous Flow](https://kotlinlang.org/docs/flow.html)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Kotlin/Kotlin Flow.md","excerpt":"Kotlin 在多工處理上提供非常好用的 Coroutine。當不同 Job 之間需要傳遞資料時，總會遇到許多問題，以前最簡單的方式就是 Callback，但 Callback 模式已經在各個程式語言中產生許多問題，這邊就不多討論。Kotlin Coroutine 如果只是要回傳一個值，可以直接用 Suspend 的 Return 值，但如果是要回傳很多資料呢？簡單的方式是直接回傳 List，可…","frontmatter":{"title":"Kotlin Flow","date":"2022-04-17T14:00:13.000Z","draft":false,"tags":["kotlin","coroutines","flow","android"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/973beda6-caa9-4559-1f92-8ab5bd7d2700/public","description":null}}},{"node":{"id":"90e0fd93-6420-5e55-aef4-b691b3fcf6e2","html":"<p>最近常常會看到別入 GitHub 上的 Commit 會有 Verified 的字樣，查了才知道這是為了防止有人盜用你的 email 簽 commit，畢竟 git 的 user.email 是可以自己隨便設的，所以 GitHub 就提供一個可以用公私鑰的方式來確認身份。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6e429f76-94c1-46ff-77da-7d50a886d100/public\" alt=\"img\"></p>\n<!--more-->\n<h2>GnuPG</h2>\n<p>我們要利用 GnuPG 來產生金鑰和簽署 Commit，當然要先安裝他，可以自己查一下自己的 OS 要怎麼裝：</p>\n<p><a href=\"https://www.gnupg.org/download\">Download GnuPG</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">brew install gnupg     # macOS\nchoco install gnupg    # Windows\napt install gnupg      # Ubuntu</code></pre></div>\n<h2>產生 GPG Key</h2>\n<p>用下面的一行指令就會進到互動式的畫面，接下來需要輸入一些資料：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">gpg --full-generate-key</code></pre></div>\n<ol>\n<li>產生 Rsa and Rsa</li>\n<li>GitHub 建議使用 4096，最複雜的就對了</li>\n<li>金鑰要不要過期可以自己評估，我是選不過期</li>\n<li>確認資料輸入正確</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d6411985-0b33-4ab2-e883-f95ce0da3c00/public\" alt=\"img\"></p>\n<ol>\n<li>輸入要簽署的名字</li>\n<li>輸入要簽署的 email，注意必須與 GitHub Email 和 <code class=\"language-text\">git config user.email</code> 的一樣。</li>\n<li>註釋隨便輸入即可</li>\n<li>確認資料輸入正確</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/594a269c-ab4f-4484-fa9a-c74307454600/public\" alt=\"img\"></p>\n<p>接下來會跳出一個要輸入密碼的畫面，一樣依自己需求設定即可</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6b11a19b-c7fa-4697-0861-5fb4c66ff800/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/56a8fc50-5a1e-4a0e-e9ef-30b9fe74fc00/public\" alt=\"img\"></p>\n<p>這樣就產生成功了，可以記一下這個畫面出現的資料</p>\n<p>如果要顯示所有的 Key：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">gpg --list-secret-keys</code></pre></div>\n<h2>複製 GPG Key 到 GitHub</h2>\n<p>用各個指令來顯示公鑰，並且複製到 GitHub 上，包含 Begin 和 End 兩行：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">gpg --armor --export <span class=\"token operator\">&lt;</span>Your Key<span class=\"token operator\">></span></code></pre></div>\n<p>進到設定裡，新增 GPG Key，貼上剛剛複製下的金鑰</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8a75edb9-4a08-4060-608a-d63353a77c00/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9c5ad211-0bcc-4058-a304-6903e69c8700/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0ef8e55b-7f1b-43ab-cd40-43303b98bc00/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/32e1e3a5-2fdc-4e6d-aef3-08122d448d00/public\" alt=\"img\"></p>\n<h2>簽署 Commit</h2>\n<p>要簽署 Commit 我們需要先告訴 git 我們要用哪支鑰匙，也是用 git config 設定，如果要每個倉庫都用這支鑰匙，可以直接設定 global：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> config user.signingkey <span class=\"token operator\">&lt;</span>Your Key<span class=\"token operator\">></span>\n<span class=\"token function\">git</span> config --global user.signingkey <span class=\"token operator\">&lt;</span>Your Key<span class=\"token operator\">></span></code></pre></div>\n<p>設定好後，我們就可以開始簽 Commit，基本上就是在 Commit 時加上 <code class=\"language-text\">-S</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> commit -S -m <span class=\"token string\">\"Commit Message\"</span></code></pre></div>\n<p>如果覺得每次都要加上參數很麻煩，也可以直接加到 config 中，讓每次 Commit 都預設簽署：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> config commit.gpgsign <span class=\"token boolean\">true</span>\n<span class=\"token function\">git</span> config --global commit.gpgsign <span class=\"token boolean\">true</span></code></pre></div>\n<p>接下來，只要 push 到 GitHub 上，就會看到有 Verified 的標籤：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6e429f76-94c1-46ff-77da-7d50a886d100/public\" alt=\"img\"></p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://docs.github.com/en/authentication/managing-commit-signature-verification/generating-a-new-gpg-key\">Generating a new GPG key</a></li>\n<li><a href=\"https://docs.github.com/en/authentication/managing-commit-signature-verification/adding-a-new-gpg-key-to-your-github-account\">Adding a new GPG key to your GitHub account</a></li>\n<li><a href=\"https://www.gnupg.org/\">GnuPG</a></li>\n</ul>","rawMarkdownBody":"\n最近常常會看到別入 GitHub 上的 Commit 會有 Verified 的字樣，查了才知道這是為了防止有人盜用你的 email 簽 commit，畢竟 git 的 user.email 是可以自己隨便設的，所以 GitHub 就提供一個可以用公私鑰的方式來確認身份。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6e429f76-94c1-46ff-77da-7d50a886d100/public)\n\n<!--more-->\n\n## GnuPG\n\n我們要利用 GnuPG 來產生金鑰和簽署 Commit，當然要先安裝他，可以自己查一下自己的 OS 要怎麼裝：\n\n[Download GnuPG](https://www.gnupg.org/download)\n\n```text\nbrew install gnupg     # macOS\nchoco install gnupg    # Windows\napt install gnupg      # Ubuntu\n```\n\n## 產生 GPG Key\n\n用下面的一行指令就會進到互動式的畫面，接下來需要輸入一些資料：\n\n```shell\ngpg --full-generate-key\n```\n\n1. 產生 Rsa and Rsa\n2. GitHub 建議使用 4096，最複雜的就對了\n3. 金鑰要不要過期可以自己評估，我是選不過期\n4. 確認資料輸入正確\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d6411985-0b33-4ab2-e883-f95ce0da3c00/public)\n\n1. 輸入要簽署的名字\n2. 輸入要簽署的 email，注意必須與 GitHub Email 和 `git config user.email` 的一樣。\n3. 註釋隨便輸入即可\n4. 確認資料輸入正確\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/594a269c-ab4f-4484-fa9a-c74307454600/public)\n\n接下來會跳出一個要輸入密碼的畫面，一樣依自己需求設定即可\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6b11a19b-c7fa-4697-0861-5fb4c66ff800/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/56a8fc50-5a1e-4a0e-e9ef-30b9fe74fc00/public)\n\n這樣就產生成功了，可以記一下這個畫面出現的資料\n\n如果要顯示所有的 Key：\n\n```shell\ngpg --list-secret-keys\n```\n\n## 複製 GPG Key 到 GitHub\n\n用各個指令來顯示公鑰，並且複製到 GitHub 上，包含 Begin 和 End 兩行：\n\n```shell\ngpg --armor --export <Your Key>\n```\n\n進到設定裡，新增 GPG Key，貼上剛剛複製下的金鑰\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8a75edb9-4a08-4060-608a-d63353a77c00/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9c5ad211-0bcc-4058-a304-6903e69c8700/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0ef8e55b-7f1b-43ab-cd40-43303b98bc00/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/32e1e3a5-2fdc-4e6d-aef3-08122d448d00/public)\n\n## 簽署 Commit\n\n要簽署 Commit 我們需要先告訴 git 我們要用哪支鑰匙，也是用 git config 設定，如果要每個倉庫都用這支鑰匙，可以直接設定 global：\n\n```shell\ngit config user.signingkey <Your Key>\ngit config --global user.signingkey <Your Key>\n```\n\n設定好後，我們就可以開始簽 Commit，基本上就是在 Commit 時加上 `-S`：\n\n```shell\ngit commit -S -m \"Commit Message\"\n```\n\n如果覺得每次都要加上參數很麻煩，也可以直接加到 config 中，讓每次 Commit 都預設簽署：\n\n```shell\ngit config commit.gpgsign true\ngit config --global commit.gpgsign true\n```\n\n接下來，只要 push 到 GitHub 上，就會看到有 Verified 的標籤：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6e429f76-94c1-46ff-77da-7d50a886d100/public)\n\n## Reference\n\n- [Generating a new GPG key](https://docs.github.com/en/authentication/managing-commit-signature-verification/generating-a-new-gpg-key)\n- [Adding a new GPG key to your GitHub account](https://docs.github.com/en/authentication/managing-commit-signature-verification/adding-a-new-gpg-key-to-your-github-account)\n- [GnuPG](https://www.gnupg.org/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Git/github gpg.md","excerpt":"最近常常會看到別入 GitHub 上的 Commit 會有 Verified 的字樣，查了才知道這是為了防止有人盜用你的 email 簽 commit，畢竟 git 的 user.email 是可以自己隨便設的，所以 GitHub 就提供一個可以用公私鑰的方式來確認身份。 img GnuPG 我們要利用 GnuPG 來產生金鑰和簽署 Commit，當然要先安裝他，可以自己查一下自己的 OS 要怎…","frontmatter":{"title":"GitHub GPG - Verified Commit","date":"2022-03-24T14:32:19.000Z","draft":false,"tags":["git","github","gpg","verified","commit"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/eb2adedc-6625-46d1-73ea-07c01fc92000/public","description":"最近常常會看到別入 GitHub 上的 Commit 會有 Verified 的字樣，查了才知道這是為了防止有人盜用你的 email 簽 commit，畢竟 git 的 user.email 是可以自己隨便設的，所以 GitHub 就提供一個可以用公私鑰的方式來確認身份。"}}},{"node":{"id":"8e495473-8d57-530c-bb3f-4262fce2dde7","html":"<p>說到搜尋的解決方案，最有名的大概就是 <a href=\"https://www.algolia.com/\">Algolia</a>，可以方便的創建索引，也有很多寫好的前端網頁元件可以使用，唯一的缺點就是收費。雖然 Algolia 要收費，但其實對於我這個小網頁都索引量是完全不用錢的，但是就還是覺得自己架一個索引系統比較有感覺，然後我就在 GitHub 上發現了開源的 <a href=\"https://meilisearch.com\">MeiliSearch</a>，功能基本上跟 Algolia 很像，也支援中文，甚至有些前端元件可以直接使用 Algolia 的，缺點就是要自己架設 Server。</p>\n<!--more-->\n<p>本文以搜尋本站為目的撰寫，所以後面的範例大多與 Hugo 相關，如果想要看完整的程式碼，可以直接到本站的 GitHub。</p>\n<h2>簡介 MeiliSearch Server</h2>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f93885e8-f670-44ec-ea24-264a97c9a500/public\" alt=\"img\"></p>\n<p>基本上 MeiliSearch 就是一個 RESTful API，目標是要提供現成的搜尋解決方案，完全開源，提供即時搜尋、拼寫錯誤、同義詞、模糊搜尋、自訂排名、排序和多語言搜尋的支援，連中文也不例外。根據官方文件的介紹，MeiliSearch 以易用性為首要目標，對於開發者，只需要少少幾行 code 就可以使用；對於使用者，提供直觀的即時輸入即時反應的搜尋結果。</p>\n<p>官方也有很多的 SDK，.NET, Dart, Go, Java, JS, Python, Swift，而且上面這些還不是全部，所以在開發各語言的應用程式時，都可以考慮用 MeiliSearch 做為後端搜尋引擎。</p>\n<p>MeiliSearch 也不是完全沒有缺點，缺點就是要自己有伺服器，像是本文今天的案例就是要幫 Static Site 做搜尋的功能，通常 Static Site 大家應該都是用 GitHub Pages 等 Statice Site Hosting 服務，所以網頁本身是沒有自己架 Server 的，為了加個搜尋功能會要多一個 Server 就是很大的缺點。</p>\n<h2>SearchIndex.json</h2>\n<p>在開始使用 MeiliSearch 之前，我們先來把要索引的資料準備好，MeiliSearch 會需要使用 json 當作索引，所以我們要產生一個 json 的範本。創建 <code class=\"language-text\">/layouts/list.searchindex.json</code>，內容如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[ {{- $i := 0 -}}\n    {{- range where .Site.RegularPages \"Section\" \"ne\" \"\" -}}\n       {{- if not .Params.noSearch -}}\n          {{- if gt $i 0 }},{{ end -}}\n          {\"id\":{{ $i }}, \"date\":\"{{ .Date.Unix }}\", \"url\":\"{{ .Permalink }}\", \"title\":{{ .Title | jsonify  }}, \"summary\":{{ with .Description}}{{ . | plainify | jsonify }}{{ else }}{{ .Summary | plainify | jsonify }}{{ end }}, \"content\":{{ .Content | plainify | jsonify }},\"tags\":[ {{- $t := 0 }}{{- range .Param \"tags\" -}}{{ if gt $t 0 }},{{ end }}{{ . | jsonify }}{{ $t = add $t 1 }}{{ end -}} ], \"section\": {{ .Section | jsonify -}} }\n        {{- $i = add $i 1 -}}\n    {{- end -}}\n{{- end -}} ]</code></pre></div>\n<p>然後在 <code class=\"language-text\">config.yaml</code> 中加入下面的設定值：</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">outputFormats</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">SearchIndex</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">mediaType</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"application/json\"</span>\n    <span class=\"token key atrule\">baseName</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"searchindex\"</span>\n    <span class=\"token key atrule\">isPlainText</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n    <span class=\"token key atrule\">notAlternative</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n<span class=\"token key atrule\">outputs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">home</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"HTML\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"RSS\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"SearchIndex\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>完成上面兩樣設定後，可以 <code class=\"language-text\">hugo</code> 一下試試看，有沒有在 <code class=\"language-text\">/public/searchindex.json</code> 中看到索引檔案，應該會類似如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"date\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1622891718\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://tonypepe.com/posts/others/hello-world/\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"summary\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Hello World. This is a test post.\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"content\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"This is my first post in hugo\\ncontent\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"tags\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"hugo\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"test\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"section\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"posts\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<h2>架設 MeiliSearch Server</h2>\n<p>準備好索引檔案後，我們就來架設 MeiliSearch 的 Server，MeiliSearch 是用 Rust 編寫，所以也是跨平台通用。官方提供很多種安裝方式，還有一鍵啟動腳本，當然，為了避免弄髒環境，最推薦的當然還是 Docker，下面就先以 Docker 為範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -it --rm <span class=\"token punctuation\">\\</span>\n    -p <span class=\"token number\">7700</span>:7700 <span class=\"token punctuation\">\\</span>\n    -v <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>/data.ms:/data.ms <span class=\"token punctuation\">\\</span>\n    getmeili/meilisearch:latest</code></pre></div>\n<p>注意一下，上面掛載了一個 <code class=\"language-text\">data.ms</code> 的資料夾，所以在執行上面的指令前，記得先創建好。<code class=\"language-text\">data.ms</code> 這個資料夾是為了存放索引資料，避免因為 Docker 容器重啟就損失資料，所以很重要。</p>\n<p>現在可以到 <a href=\"http://localhost:7700\">http://localhost:7700</a>，會看到有一個簡易的 WEB UI。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/5664dc51-5d55-415a-3633-ac45e17d7a00/public\" alt=\"img\"></p>\n<p>如果不想用 Docker，還是可以參考官方文件的其他安裝方式安裝。</p>\n<h2>提交索引資料</h2>\n<p>前面有提到 MeiliSearch 是 RESTful API，所以要向他搜尋或是提供資料，都是用 HTTP Method。官方文件寫的都是 curl，我們還是使用 GUI 的方式介紹。HTTP 的 GUI 大家應該都會想到 Postman，但今天我們要使用他的開源替代 <a href=\"https://hoppspot.io\">Hoppsotch</a>，他是一個網頁工具，所以不需要安裝。</p>\n<p>可以先對 <code class=\"language-text\">/health</code> 做 <code class=\"language-text\">GET</code> 試試看有沒有連上，如果沒有連上，可能要檢查一下有沒有成功啟動 MeiliSearch Server。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/cf86e106-a1f6-472e-d2c1-a6b186944f00/public\" alt=\"img\"></p>\n<p>確定連上後，我們就來提交索引資料，如果還沒有 Hugo 產生的索引資料，可以先到本站的 GitHub，拿本站的 <a href=\"https://github.com/TonyPepeBear/HugoBlog/blob/1bfae9859a44338d24a9f6676be37f72cc983505/searchindex.json\">searchindex.json</a> 做測試。</p>\n<p>因為 MeiliSearch 也可以同時有多個 Indexes 做搜尋，我們下面的範例以 <code class=\"language-text\">hugo_blog</code> 作為範例名稱，大家可以根據需求自己決定使用的名稱。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/71797a57-6f97-44cd-f4dc-675ec42ffd00/public\" alt=\"img\"></p>\n<p>可以看到上圖對 <code class=\"language-text\">/indexes/&lt;&lt;IndexName>>/documents</code> 做 <code class=\"language-text\">POST</code> 方法，就可以把索引資料提交到 MeiliSearch Server。記得內容類型是 <code class=\"language-text\">application/json</code>，然後把索引資料放到 body。</p>\n<p>現在回到 <a href=\"http://localhost:7700\">localhost:7700</a>，應該就可以看到原本空空如也的 WEB UI 現在可以做搜尋了，可以先在這裡做一些簡單的搜尋，試試看自己的索引資料有沒有被成功的使用。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c58970b0-53b5-4a16-50bb-ff40fa6fde00/public\" alt=\"img\"></p>\n<h2>MeiliSearch in Production</h2>\n<p>MeiliSearch 預設的啟動方式其實是 <code class=\"language-text\">development</code>，這模式只是方便本地做測試使用的，如果要使用在生產環境，應該要以 <code class=\"language-text\">production</code> 模式啟動。在 Production 模式下，會有兩個不一樣的地方，第一項是 Web UI 會被停用，第二項是會必須要設定 <code class=\"language-text\">Master Key</code>，下面還是用 Docker 作為範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -it --rm <span class=\"token punctuation\">\\</span>\n    -p <span class=\"token number\">7700</span>:7700 <span class=\"token punctuation\">\\</span>\n    -v <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>/data.ms:/data.ms <span class=\"token punctuation\">\\</span>\n    -e <span class=\"token assign-left variable\">MEILI_ENV</span><span class=\"token operator\">=</span>production <span class=\"token punctuation\">\\</span>\n    -e <span class=\"token assign-left variable\">MEILI_MASTER_KEY</span><span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>Your Master Key<span class=\"token operator\">></span> <span class=\"token punctuation\">\\</span>\n    getmeili/meilisearch:latest</code></pre></div>\n<p>上面設定的 Master Key，就是管理權限最大的 API Key，所以要記得妥善保存。</p>\n<p>下面用剛剛的 Master Key 去對 <code class=\"language-text\">/keys</code> 做 <code class=\"language-text\">GET</code>，然後在 Headers 中，加上剛剛的 Master Key，就可以拿到預設的搜尋 KEY，和預設的 ADMIN KEY。如果要再另外新增 API KEY，可以參考官方的文件，這裡就不多著墨。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/91af11f7-29fc-446b-7ae1-dcb47f82b900/public\" alt=\"img\"></p>\n<h2>為網頁加上搜尋功能</h2>\n<p>我們會用到 MeiliSearch 提供的 <a href=\"https://github.com/meilisearch/instant-meilisearch\">Instant MeiliSearch</a>，這個 JS 庫就是使用 Algolia 的 Instant Search 改的，所以有些文件可以直接去看 Algolia 的官方文件。Instant MeiliSearch 最簡單的使用方式也是直接用 CDN 的方式，下面是一個最簡單的模板，看懂後用類似的邏輯加到自己的網頁中就好。</p>\n<p>html:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">DOCTYPE</span> <span class=\"token name\">html</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>utf-8<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>searchbox<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>hits<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://cdn.jsdelivr.net/npm/@meilisearch/instant-meilisearch/dist/instant-meilisearch.umd.min.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://cdn.jsdelivr.net/npm/instantsearch.js@4<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>./app.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>下面是剛剛的 html 會用到的 <code class=\"language-text\">app.js</code>，用來作為 Search 的設定值，只要把下面的網址設定成自己的網址，和自己在前幾步驟拿到的搜尋 API KEY 就可以使用了：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> search <span class=\"token operator\">=</span> <span class=\"token function\">instantsearch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">indexName</span><span class=\"token operator\">:</span> <span class=\"token string\">\"steam-video-games\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">searchClient</span><span class=\"token operator\">:</span> <span class=\"token function\">instantMeiliSearch</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"https://integration-demos.meilisearch.com\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"q7QHwGiX841a509c8b05ef29e55f2d94c02c00635f729ccf097a734cbdf7961530f47c47\"</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsearch<span class=\"token punctuation\">.</span><span class=\"token function\">addWidgets</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  instantsearch<span class=\"token punctuation\">.</span>widgets<span class=\"token punctuation\">.</span><span class=\"token function\">searchBox</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">container</span><span class=\"token operator\">:</span> <span class=\"token string\">\"#searchbox\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  instantsearch<span class=\"token punctuation\">.</span>widgets<span class=\"token punctuation\">.</span><span class=\"token function\">hits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">container</span><span class=\"token operator\">:</span> <span class=\"token string\">\"#hits\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">templates</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">item</span><span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n        &lt;div>\n          &lt;div class=\"hit-name\">\n            {{#helpers.highlight}}{ \"attribute\": \"name\" }{{/helpers.highlight}}\n          &lt;/div>\n        &lt;/div>\n      </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsearch<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如果覺得他預設提供的 UI 很醜，可以用 CSS 的方式去改他。</p>\n<h2>GitHub Actions 自動提交索引</h2>\n<p>不廢話，直接上本站的 yml:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> MeiliSearch Index\n\n<span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> master <span class=\"token comment\"># Set a branch to deploy</span>\n\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span><span class=\"token number\">20.04</span>\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">submodules</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span> <span class=\"token comment\"># Fetch Hugo themes (true OR recursive)</span>\n          <span class=\"token key atrule\">fetch-depth</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token comment\"># Fetch all history for .GitInfo and .Lastmod</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Node\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/setup<span class=\"token punctuation\">-</span>node@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">node-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"14\"</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Hugo\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>hugo@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">hugo-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"latest\"</span>\n          <span class=\"token key atrule\">extended</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          npm i\n          hugo --minify</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Post Index\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          curl \\\n            -X POST \"https://search.tonypepe.com/indexes/hugo_blog/documents\" \\\n            -H 'Authorization: Bearer ${{ secrets.MEILISEARCH_KEY }}' \\\n            -H 'Content-Type: application/json' \\\n            --data-binary \"@public/searchindex.json\"</span></code></pre></div>\n<p>其實重點就是在最後一步，把索引檔案 POST 到 MeiliSearch 就可以了。</p>\n<h2>Referenc</h2>\n<ul>\n<li><a href=\"https://meilisearch.com\">MeiliSearch</a></li>\n<li><a href=\"https://discourse.gohugo.io/t/a-simple-javascript-based-full-text-search-function/29119\">A simple javascript based full text search function</a></li>\n<li><a href=\"https://hoppspot.io\">Hoppsotch</a></li>\n<li><a href=\"https://github.com/meilisearch/instant-meilisearch\">Instant MeiliSearch</a></li>\n</ul>","rawMarkdownBody":"\n說到搜尋的解決方案，最有名的大概就是 [Algolia](https://www.algolia.com/)，可以方便的創建索引，也有很多寫好的前端網頁元件可以使用，唯一的缺點就是收費。雖然 Algolia 要收費，但其實對於我這個小網頁都索引量是完全不用錢的，但是就還是覺得自己架一個索引系統比較有感覺，然後我就在 GitHub 上發現了開源的 [MeiliSearch](https://meilisearch.com)，功能基本上跟 Algolia 很像，也支援中文，甚至有些前端元件可以直接使用 Algolia 的，缺點就是要自己架設 Server。\n\n<!--more-->\n\n本文以搜尋本站為目的撰寫，所以後面的範例大多與 Hugo 相關，如果想要看完整的程式碼，可以直接到本站的 GitHub。\n\n## 簡介 MeiliSearch Server\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f93885e8-f670-44ec-ea24-264a97c9a500/public)\n\n基本上 MeiliSearch 就是一個 RESTful API，目標是要提供現成的搜尋解決方案，完全開源，提供即時搜尋、拼寫錯誤、同義詞、模糊搜尋、自訂排名、排序和多語言搜尋的支援，連中文也不例外。根據官方文件的介紹，MeiliSearch 以易用性為首要目標，對於開發者，只需要少少幾行 code 就可以使用；對於使用者，提供直觀的即時輸入即時反應的搜尋結果。\n\n官方也有很多的 SDK，.NET, Dart, Go, Java, JS, Python, Swift，而且上面這些還不是全部，所以在開發各語言的應用程式時，都可以考慮用 MeiliSearch 做為後端搜尋引擎。\n\nMeiliSearch 也不是完全沒有缺點，缺點就是要自己有伺服器，像是本文今天的案例就是要幫 Static Site 做搜尋的功能，通常 Static Site 大家應該都是用 GitHub Pages 等 Statice Site Hosting 服務，所以網頁本身是沒有自己架 Server 的，為了加個搜尋功能會要多一個 Server 就是很大的缺點。\n\n## SearchIndex.json\n\n在開始使用 MeiliSearch 之前，我們先來把要索引的資料準備好，MeiliSearch 會需要使用 json 當作索引，所以我們要產生一個 json 的範本。創建 `/layouts/list.searchindex.json`，內容如下：\n\n```text\n[ {{- $i := 0 -}}\n    {{- range where .Site.RegularPages \"Section\" \"ne\" \"\" -}}\n       {{- if not .Params.noSearch -}}\n          {{- if gt $i 0 }},{{ end -}}\n          {\"id\":{{ $i }}, \"date\":\"{{ .Date.Unix }}\", \"url\":\"{{ .Permalink }}\", \"title\":{{ .Title | jsonify  }}, \"summary\":{{ with .Description}}{{ . | plainify | jsonify }}{{ else }}{{ .Summary | plainify | jsonify }}{{ end }}, \"content\":{{ .Content | plainify | jsonify }},\"tags\":[ {{- $t := 0 }}{{- range .Param \"tags\" -}}{{ if gt $t 0 }},{{ end }}{{ . | jsonify }}{{ $t = add $t 1 }}{{ end -}} ], \"section\": {{ .Section | jsonify -}} }\n        {{- $i = add $i 1 -}}\n    {{- end -}}\n{{- end -}} ]\n```\n\n然後在 `config.yaml` 中加入下面的設定值：\n\n```yaml\noutputFormats:\n  SearchIndex:\n    mediaType: \"application/json\"\n    baseName: \"searchindex\"\n    isPlainText: true\n    notAlternative: true\noutputs:\n  home: [\"HTML\", \"RSS\", \"SearchIndex\"]\n```\n\n完成上面兩樣設定後，可以 `hugo` 一下試試看，有沒有在 `/public/searchindex.json` 中看到索引檔案，應該會類似如下：\n\n```json\n[\n  {\n    \"id\": 0,\n    \"date\": \"1622891718\",\n    \"url\": \"https://tonypepe.com/posts/others/hello-world/\",\n    \"title\": \"Hello World\",\n    \"summary\": \"Hello World. This is a test post.\",\n    \"content\": \"This is my first post in hugo\\ncontent\",\n    \"tags\": [\"hugo\", \"test\"],\n    \"section\": \"posts\"\n  }\n]\n```\n\n## 架設 MeiliSearch Server\n\n準備好索引檔案後，我們就來架設 MeiliSearch 的 Server，MeiliSearch 是用 Rust 編寫，所以也是跨平台通用。官方提供很多種安裝方式，還有一鍵啟動腳本，當然，為了避免弄髒環境，最推薦的當然還是 Docker，下面就先以 Docker 為範例：\n\n```bash\ndocker run -it --rm \\\n    -p 7700:7700 \\\n    -v $(pwd)/data.ms:/data.ms \\\n    getmeili/meilisearch:latest\n```\n\n注意一下，上面掛載了一個 `data.ms` 的資料夾，所以在執行上面的指令前，記得先創建好。`data.ms` 這個資料夾是為了存放索引資料，避免因為 Docker 容器重啟就損失資料，所以很重要。\n\n現在可以到 [http://localhost:7700](http://localhost:7700)，會看到有一個簡易的 WEB UI。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/5664dc51-5d55-415a-3633-ac45e17d7a00/public)\n\n如果不想用 Docker，還是可以參考官方文件的其他安裝方式安裝。\n\n## 提交索引資料\n\n前面有提到 MeiliSearch 是 RESTful API，所以要向他搜尋或是提供資料，都是用 HTTP Method。官方文件寫的都是 curl，我們還是使用 GUI 的方式介紹。HTTP 的 GUI 大家應該都會想到 Postman，但今天我們要使用他的開源替代 [Hoppsotch](https://hoppspot.io)，他是一個網頁工具，所以不需要安裝。\n\n可以先對 `/health` 做 `GET` 試試看有沒有連上，如果沒有連上，可能要檢查一下有沒有成功啟動 MeiliSearch Server。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/cf86e106-a1f6-472e-d2c1-a6b186944f00/public)\n\n確定連上後，我們就來提交索引資料，如果還沒有 Hugo 產生的索引資料，可以先到本站的 GitHub，拿本站的 [searchindex.json](https://github.com/TonyPepeBear/HugoBlog/blob/1bfae9859a44338d24a9f6676be37f72cc983505/searchindex.json) 做測試。\n\n因為 MeiliSearch 也可以同時有多個 Indexes 做搜尋，我們下面的範例以 `hugo_blog` 作為範例名稱，大家可以根據需求自己決定使用的名稱。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/71797a57-6f97-44cd-f4dc-675ec42ffd00/public)\n\n可以看到上圖對 `/indexes/<<IndexName>>/documents` 做 `POST` 方法，就可以把索引資料提交到 MeiliSearch Server。記得內容類型是 `application/json`，然後把索引資料放到 body。\n\n現在回到 [localhost:7700](http://localhost:7700)，應該就可以看到原本空空如也的 WEB UI 現在可以做搜尋了，可以先在這裡做一些簡單的搜尋，試試看自己的索引資料有沒有被成功的使用。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c58970b0-53b5-4a16-50bb-ff40fa6fde00/public)\n\n## MeiliSearch in Production\n\nMeiliSearch 預設的啟動方式其實是 `development`，這模式只是方便本地做測試使用的，如果要使用在生產環境，應該要以 `production` 模式啟動。在 Production 模式下，會有兩個不一樣的地方，第一項是 Web UI 會被停用，第二項是會必須要設定 `Master Key`，下面還是用 Docker 作為範例：\n\n```bash\ndocker run -it --rm \\\n    -p 7700:7700 \\\n    -v $(pwd)/data.ms:/data.ms \\\n    -e MEILI_ENV=production \\\n    -e MEILI_MASTER_KEY=<Your Master Key> \\\n    getmeili/meilisearch:latest\n```\n\n上面設定的 Master Key，就是管理權限最大的 API Key，所以要記得妥善保存。\n\n下面用剛剛的 Master Key 去對 `/keys` 做 `GET`，然後在 Headers 中，加上剛剛的 Master Key，就可以拿到預設的搜尋 KEY，和預設的 ADMIN KEY。如果要再另外新增 API KEY，可以參考官方的文件，這裡就不多著墨。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/91af11f7-29fc-446b-7ae1-dcb47f82b900/public)\n\n## 為網頁加上搜尋功能\n\n我們會用到 MeiliSearch 提供的 [Instant MeiliSearch](https://github.com/meilisearch/instant-meilisearch)，這個 JS 庫就是使用 Algolia 的 Instant Search 改的，所以有些文件可以直接去看 Algolia 的官方文件。Instant MeiliSearch 最簡單的使用方式也是直接用 CDN 的方式，下面是一個最簡單的模板，看懂後用類似的邏輯加到自己的網頁中就好。\n\nhtml:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n  </head>\n\n  <body>\n    <div>\n      <div id=\"searchbox\"></div>\n      <div id=\"hits\"></div>\n    </div>\n\n    <script src=\"https://cdn.jsdelivr.net/npm/@meilisearch/instant-meilisearch/dist/instant-meilisearch.umd.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/instantsearch.js@4\"></script>\n    <script src=\"./app.js\"></script>\n  </body>\n</html>\n```\n\n下面是剛剛的 html 會用到的 `app.js`，用來作為 Search 的設定值，只要把下面的網址設定成自己的網址，和自己在前幾步驟拿到的搜尋 API KEY 就可以使用了：\n\n```js\nconst search = instantsearch({\n  indexName: \"steam-video-games\",\n  searchClient: instantMeiliSearch(\n    \"https://integration-demos.meilisearch.com\",\n    \"q7QHwGiX841a509c8b05ef29e55f2d94c02c00635f729ccf097a734cbdf7961530f47c47\"\n  ),\n});\n\nsearch.addWidgets([\n  instantsearch.widgets.searchBox({\n    container: \"#searchbox\",\n  }),\n  instantsearch.widgets.hits({\n    container: \"#hits\",\n    templates: {\n      item: `\n        <div>\n          <div class=\"hit-name\">\n            {{#helpers.highlight}}{ \"attribute\": \"name\" }{{/helpers.highlight}}\n          </div>\n        </div>\n      `,\n    },\n  }),\n]);\n\nsearch.start();\n```\n\n如果覺得他預設提供的 UI 很醜，可以用 CSS 的方式去改他。\n\n## GitHub Actions 自動提交索引\n\n不廢話，直接上本站的 yml:\n\n```yml\nname: MeiliSearch Index\n\non:\n  push:\n    branches:\n      - master # Set a branch to deploy\n\njobs:\n  deploy:\n    runs-on: ubuntu-20.04\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          submodules: true # Fetch Hugo themes (true OR recursive)\n          fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod\n\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: \"14\"\n\n      - name: Setup Hugo\n        uses: peaceiris/actions-hugo@v2\n        with:\n          hugo-version: \"latest\"\n          extended: true\n\n      - name: Build\n        run: |\n          npm i\n          hugo --minify\n\n      - name: Post Index\n        run: |\n          curl \\\n            -X POST \"https://search.tonypepe.com/indexes/hugo_blog/documents\" \\\n            -H 'Authorization: Bearer ${{ secrets.MEILISEARCH_KEY }}' \\\n            -H 'Content-Type: application/json' \\\n            --data-binary \"@public/searchindex.json\"\n```\n\n其實重點就是在最後一步，把索引檔案 POST 到 MeiliSearch 就可以了。\n\n## Referenc\n\n- [MeiliSearch](https://meilisearch.com)\n- [A simple javascript based full text search function](https://discourse.gohugo.io/t/a-simple-javascript-based-full-text-search-function/29119)\n- [Hoppsotch](https://hoppspot.io)\n- [Instant MeiliSearch](https://github.com/meilisearch/instant-meilisearch)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/MeiliSearch-hugo.md","excerpt":"說到搜尋的解決方案，最有名的大概就是 Algolia，可以方便的創建索引，也有很多寫好的前端網頁元件可以使用，唯一的缺點就是收費。雖然 Algolia 要收費，但其實對於我這個小網頁都索引量是完全不用錢的，但是就還是覺得自己架一個索引系統比較有感覺，然後我就在 GitHub 上發現了開源的 MeiliSearch，功能基本上跟 Algolia 很像，也支援中文，甚至有些前端元件可以直接使用 Al…","frontmatter":{"title":"MeiliSearch with Hugo","date":"2022-01-17T17:40:09.000Z","draft":false,"tags":["meilisearch","search","web","hugo","github","actions"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f9f8be53-5393-4190-b6da-baf27d8a7500/public","description":null}}},{"node":{"id":"7344f3d5-18b8-56c7-8a29-887c8c755a3a","html":"<p>GitHub 上有許許多多開源的 icon，但是每個用法不盡相同，甚至大部分的使用方式，都是直接下載 SVG 使用。雖然使用 SVG 也不是不好，但是就會需要自己多一步驟的使用。Iconify 把許多 icon 整合在一起，並且提供非常簡單的辦法，就可以讓網頁有很精美的 icon。</p>\n<!--more-->\n<h2>使用 Iconify</h2>\n<p>使用 Iconify 只需要先在 HTML 中引入 Iconify 的 Script：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://code.iconify.design/2/2.1.0/iconify.min.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>接下來只需要在要使用 icon 的地方，新增一個 span，其中要有包含 <code class=\"language-text\">class=\"iconify\"</code> 和 <code class=\"language-text\">data-icon</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>iconify<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">data-icon</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>fa:home<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>正確使用後，應該就可以在網頁中正確的顯示下面的 icon：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f0141e02-3e26-415d-1ee2-438dc4d43600/public\" alt=\"img\"></p>\n<h2>搜尋 Icon</h2>\n<p>就像前面說的，Iconify 提供非常多的 icon，所以作者也有寫一個可以搜尋圖標的地方，而且搜尋到圖標後，還提供許多可以協助客製化圖標的方法：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/44c38b28-baa8-4faa-6d06-8e2615f19500/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c330c161-f8b4-41d2-db15-b02079185b00/public\" alt=\"\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f0141e02-3e26-415d-1ee2-438dc4d43600/public\" alt=\"img\"></p>\n<p>如果真的不想使用 Iconify 的方式顯示圖標，也可以單純的當作圖標蒐尋器，搜尋到之後直接下載 SVG 使用即可。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://iconify.design/\">Iconify</a></li>\n</ul>","rawMarkdownBody":"\nGitHub 上有許許多多開源的 icon，但是每個用法不盡相同，甚至大部分的使用方式，都是直接下載 SVG 使用。雖然使用 SVG 也不是不好，但是就會需要自己多一步驟的使用。Iconify 把許多 icon 整合在一起，並且提供非常簡單的辦法，就可以讓網頁有很精美的 icon。\n\n<!--more-->\n\n## 使用 Iconify\n\n使用 Iconify 只需要先在 HTML 中引入 Iconify 的 Script：\n\n```html\n<script src=\"https://code.iconify.design/2/2.1.0/iconify.min.js\"></script>\n```\n\n接下來只需要在要使用 icon 的地方，新增一個 span，其中要有包含 `class=\"iconify\"` 和 `data-icon`：\n\n```html\n<span class=\"iconify\" data-icon=\"fa:home\"></span>\n```\n\n正確使用後，應該就可以在網頁中正確的顯示下面的 icon：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f0141e02-3e26-415d-1ee2-438dc4d43600/public)\n\n## 搜尋 Icon\n\n就像前面說的，Iconify 提供非常多的 icon，所以作者也有寫一個可以搜尋圖標的地方，而且搜尋到圖標後，還提供許多可以協助客製化圖標的方法：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/44c38b28-baa8-4faa-6d06-8e2615f19500/public)\n\n![](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c330c161-f8b4-41d2-db15-b02079185b00/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f0141e02-3e26-415d-1ee2-438dc4d43600/public)\n\n如果真的不想使用 Iconify 的方式顯示圖標，也可以單純的當作圖標蒐尋器，搜尋到之後直接下載 SVG 使用即可。\n\n## Reference\n\n- [Iconify](https://iconify.design/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/iconify.md","excerpt":"GitHub 上有許許多多開源的 icon，但是每個用法不盡相同，甚至大部分的使用方式，都是直接下載 SVG 使用。雖然使用 SVG 也不是不好，但是就會需要自己多一步驟的使用。Iconify 把許多 icon 整合在一起，並且提供非常簡單的辦法，就可以讓網頁有很精美的 icon。 使用 Iconify 使用 Iconify 只需要先在 HTML 中引入 Iconify 的 Script： 接下…","frontmatter":{"title":"Iconify -- icon 大禮包","date":"2022-01-14T13:48:25.000Z","draft":false,"tags":["icon","web","ios","android","design"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/ca9b8ae2-b684-421a-a662-2dd4356ce600/public","description":null}}},{"node":{"id":"9c3da1a2-833a-52a8-9d4e-e9194f199199","html":"<p>Telegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。</p>\n<!--more-->\n<h2>新增自己的 Bot</h2>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/fbf36cb0-84f4-4f7a-2553-04ecccf44800/public\" alt=\"image\"></p>\n<p>Telegram 非常有趣，要新增自己的 Bot，只要跟 Telegram 上的 <a href=\"https://telegram.me/BotFather\">BotFather</a> <code class=\"language-text\">說一下</code>，他就會給你一個 Bot。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9200bc38-828c-4ad4-a022-d34c3a692d00/public\" alt=\"image\"></p>\n<p>按 BotFather 給你的步驟做，最後可以看到他會提供一個 API Token 給你，只要有這個 Token 就可以跟 Bot 溝通，要保存好，等等會用到，也不要給別人看到，以免自己的 Bot 變成別人的玩具。</p>\n<h2>go-telegram-bot-api</h2>\n<p>Go 已經有社區開發的函式庫可以用 <a href=\"https://github.com/go-telegram-bot-api/telegram-bot-api\">telegram-bot-api</a>。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">go get -u github.com/go-telegram-bot-api/telegram-bot-api/v5\n</code></pre></div>\n<p>之後只要 import 就可以使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    tgbotapi <span class=\"token string\">\"github.com/go-telegram-bot-api/telegram-bot-api/v5\"</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<h2>連線到 Telegram Bot</h2>\n<p>利用剛剛 import 的函式庫，只需要剛剛創建好的 Bot 的 API Token 就可以連線到 Telegram。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">bot<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewBotAPI</span><span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span><span class=\"token function\">Getenv</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TELEGRAM_API_TOKEN\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面用環境變數的方式來取得 TOKEN，避免需要直接寫在程式碼裡，如果覺得在測試時設定環境變數很麻煩，可以用 JetBrains 的 <a href=\"https://www.jetbrains.com/go/\">GoLand</a>，設定 Runtime 的環境變數：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9af5d8a5-3504-479d-ab04-f8b0adf93500/public\" alt=\"image\"></p>\n<h2>處理 Update</h2>\n<p>要接收使用者傳過來的訊息，Telegram API 稱為 Update，我們使用的函示庫基本上都自動處理好了，只需要接收一個 Channel 就好。使用 <code class=\"language-text\">bot.GetUpdatesChan(config)</code> 會需要給一個 Config，這可以用 <code class=\"language-text\">tgbotapi.NewUpdate(0)</code> 來生，然後這邊設定 Timeout 為 60，如果對這個設定值有興趣，可以去看 Telegram 的文件。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">updateConfig <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewUpdate</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\nupdateConfig<span class=\"token punctuation\">.</span>Timeout <span class=\"token operator\">=</span> <span class=\"token number\">60</span>\nupdates <span class=\"token operator\">:=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">GetUpdatesChan</span><span class=\"token punctuation\">(</span>updateConfig<span class=\"token punctuation\">)</span></code></pre></div>\n<h2>回復</h2>\n<p>我們先簡單寫一隻鸚鵡，把用戶傳過來的 Text，直接傳回去。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/19bbc73e-3090-4a0d-0eec-d65671c01900/public\" alt=\"image\"></p>\n<p>用 for 把 Channel 中的 Update 一個一個拿出來，然後用 <code class=\"language-text\">tgbotapi</code> 產生一個 Message 物件，裡面放在聊天室的 ID 和要回傳的 Text，最後用 bot 把 Message 傳回去。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> update <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> updates <span class=\"token punctuation\">{</span>\n    text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n    chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n    replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n    <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>簡單鸚鵡的完整程式碼</h2>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    tgbotapi <span class=\"token string\">\"github.com/go-telegram-bot-api/telegram-bot-api/v5\"</span>\n    <span class=\"token string\">\"os\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    bot<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewBotAPI</span><span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span><span class=\"token function\">Getenv</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TELEGRAM_API_TOKEN\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    bot<span class=\"token punctuation\">.</span>Debug <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    updateConfig <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewUpdate</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    updateConfig<span class=\"token punctuation\">.</span>Timeout <span class=\"token operator\">=</span> <span class=\"token number\">60</span>\n    updates <span class=\"token operator\">:=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">GetUpdatesChan</span><span class=\"token punctuation\">(</span>updateConfig<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> update <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> updates <span class=\"token punctuation\">{</span>\n        text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n        chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n        replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n        <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>改寫成非阻塞的 Goroutine</h2>\n<p>因為每次處理和回復都會需要一點時間，甚至是要去 DB 找資料，如果用上面的寫法，在處理多人或高速傳訊息的時候會被卡住，一次只能處理的一個訊息。還好 Go 的併發寫法非常簡單，只要放一個 go 在前面，就可以非阻塞的執行 function 中的內容。</p>\n<p>我們先把 <code class=\"language-text\">handleUpdate</code> 提取成一個 function，然後再用 go 去執行他：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    bot<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewBotAPI</span><span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span><span class=\"token function\">Getenv</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TELEGRAM_API_TOKEN\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    bot<span class=\"token punctuation\">.</span>Debug <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    updateConfig <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewUpdate</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    updateConfig<span class=\"token punctuation\">.</span>Timeout <span class=\"token operator\">=</span> <span class=\"token number\">60</span>\n    updates <span class=\"token operator\">:=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">GetUpdatesChan</span><span class=\"token punctuation\">(</span>updateConfig<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> update <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> updates <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">go</span> <span class=\"token function\">handleUpdate</span><span class=\"token punctuation\">(</span>bot<span class=\"token punctuation\">,</span> update<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">handleUpdate</span><span class=\"token punctuation\">(</span>bot <span class=\"token operator\">*</span>tgbotapi<span class=\"token punctuation\">.</span>BotAPI<span class=\"token punctuation\">,</span> update tgbotapi<span class=\"token punctuation\">.</span>Update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n    chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n    replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n    <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>回復特定訊息</h2>\n<p>要回復 <code class=\"language-text\">回復訊息</code> ，像是下面的效果也很簡單：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/22010000-e325-45e6-52f9-64eec6b28500/public\" alt=\"image\"></p>\n<p>只需要設定 <code class=\"language-text\">replyMsg.ReplyToMessageID</code> 就可以回復特定的訊息，下面就是直接回覆接收到的訊息：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">handleUpdate</span><span class=\"token punctuation\">(</span>bot <span class=\"token operator\">*</span>tgbotapi<span class=\"token punctuation\">.</span>BotAPI<span class=\"token punctuation\">,</span> update tgbotapi<span class=\"token punctuation\">.</span>Update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n    chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n    replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n    replyMsg<span class=\"token punctuation\">.</span>ReplyToMessageID <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>MessageID\n    <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>處理 Command</h2>\n<p>Telegram 中，用 <code class=\"language-text\">/</code> 開頭的文字就是 Command，這個函示庫也有寫好處理 Command 的方法，只需要用 <code class=\"language-text\">isCommand()</code>，確認一下是不是 Command 就可以：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">handleUpdate</span><span class=\"token punctuation\">(</span>bot <span class=\"token operator\">*</span>tgbotapi<span class=\"token punctuation\">.</span>BotAPI<span class=\"token punctuation\">,</span> update tgbotapi<span class=\"token punctuation\">.</span>Update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n    chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n    replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span><span class=\"token function\">IsCommand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">switch</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span><span class=\"token function\">Command</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> <span class=\"token string\">\"start\"</span><span class=\"token punctuation\">:</span>\n            replyMsg<span class=\"token punctuation\">.</span>Text <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello \"</span> <span class=\"token operator\">+</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>From<span class=\"token punctuation\">.</span>FirstName\n        <span class=\"token keyword\">case</span> <span class=\"token string\">\"help\"</span><span class=\"token punctuation\">:</span>\n            replyMsg<span class=\"token punctuation\">.</span>Text <span class=\"token operator\">=</span> <span class=\"token string\">\"What can I help you?\"</span>\n        <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n            replyMsg<span class=\"token punctuation\">.</span>Text <span class=\"token operator\">=</span> <span class=\"token string\">\"No such command!!!\"</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的程式碼其實也可以看到如何拿到傳送者的一些基本資料。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0fd54240-5c18-4b75-c7be-981cdb144e00/public\" alt=\"image\"></p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://core.telegram.org/\">Telegram APIs</a></li>\n<li><a href=\"https://github.com/go-telegram-bot-api/telegram-bot-api\">Golang bindings for the Telegram Bot API - GitHub</a></li>\n</ul>","rawMarkdownBody":"\nTelegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。\n\n<!--more-->\n\n## 新增自己的 Bot\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/fbf36cb0-84f4-4f7a-2553-04ecccf44800/public)\n\nTelegram 非常有趣，要新增自己的 Bot，只要跟 Telegram 上的 [BotFather](https://telegram.me/BotFather) `說一下`，他就會給你一個 Bot。\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9200bc38-828c-4ad4-a022-d34c3a692d00/public)\n\n按 BotFather 給你的步驟做，最後可以看到他會提供一個 API Token 給你，只要有這個 Token 就可以跟 Bot 溝通，要保存好，等等會用到，也不要給別人看到，以免自己的 Bot 變成別人的玩具。\n\n## go-telegram-bot-api\n\nGo 已經有社區開發的函式庫可以用 [telegram-bot-api](https://github.com/go-telegram-bot-api/telegram-bot-api)。\n\n```shell\ngo get -u github.com/go-telegram-bot-api/telegram-bot-api/v5\n\n```\n\n之後只要 import 就可以使用：\n\n```go\nimport (\n    tgbotapi \"github.com/go-telegram-bot-api/telegram-bot-api/v5\"\n)\n```\n\n## 連線到 Telegram Bot\n\n利用剛剛 import 的函式庫，只需要剛剛創建好的 Bot 的 API Token 就可以連線到 Telegram。\n\n```go\nbot, err := tgbotapi.NewBotAPI(os.Getenv(\"TELEGRAM_API_TOKEN\"))\nif err != nil {\n    panic(err)\n}\n```\n\n上面用環境變數的方式來取得 TOKEN，避免需要直接寫在程式碼裡，如果覺得在測試時設定環境變數很麻煩，可以用 JetBrains 的 [GoLand](https://www.jetbrains.com/go/)，設定 Runtime 的環境變數：\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9af5d8a5-3504-479d-ab04-f8b0adf93500/public)\n\n## 處理 Update\n\n要接收使用者傳過來的訊息，Telegram API 稱為 Update，我們使用的函示庫基本上都自動處理好了，只需要接收一個 Channel 就好。使用 `bot.GetUpdatesChan(config)` 會需要給一個 Config，這可以用 `tgbotapi.NewUpdate(0)` 來生，然後這邊設定 Timeout 為 60，如果對這個設定值有興趣，可以去看 Telegram 的文件。\n\n```go\nupdateConfig := tgbotapi.NewUpdate(0)\nupdateConfig.Timeout = 60\nupdates := bot.GetUpdatesChan(updateConfig)\n```\n\n## 回復\n\n我們先簡單寫一隻鸚鵡，把用戶傳過來的 Text，直接傳回去。\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/19bbc73e-3090-4a0d-0eec-d65671c01900/public)\n\n用 for 把 Channel 中的 Update 一個一個拿出來，然後用 `tgbotapi` 產生一個 Message 物件，裡面放在聊天室的 ID 和要回傳的 Text，最後用 bot 把 Message 傳回去。\n\n```go\nfor update := range updates {\n    text := update.Message.Text\n    chatID := update.Message.Chat.ID\n    replyMsg := tgbotapi.NewMessage(chatID, text)\n    _, _ = bot.Send(replyMsg)\n}\n```\n\n## 簡單鸚鵡的完整程式碼\n\n```go\npackage main\n\nimport (\n    tgbotapi \"github.com/go-telegram-bot-api/telegram-bot-api/v5\"\n    \"os\"\n)\n\nfunc main() {\n    bot, err := tgbotapi.NewBotAPI(os.Getenv(\"TELEGRAM_API_TOKEN\"))\n    if err != nil {\n        panic(err)\n    }\n    bot.Debug = true\n    updateConfig := tgbotapi.NewUpdate(0)\n    updateConfig.Timeout = 60\n    updates := bot.GetUpdatesChan(updateConfig)\n    for update := range updates {\n        text := update.Message.Text\n        chatID := update.Message.Chat.ID\n        replyMsg := tgbotapi.NewMessage(chatID, text)\n        _, _ = bot.Send(replyMsg)\n    }\n}\n```\n\n## 改寫成非阻塞的 Goroutine\n\n因為每次處理和回復都會需要一點時間，甚至是要去 DB 找資料，如果用上面的寫法，在處理多人或高速傳訊息的時候會被卡住，一次只能處理的一個訊息。還好 Go 的併發寫法非常簡單，只要放一個 go 在前面，就可以非阻塞的執行 function 中的內容。\n\n我們先把 `handleUpdate` 提取成一個 function，然後再用 go 去執行他：\n\n```go\nfunc main() {\n    bot, err := tgbotapi.NewBotAPI(os.Getenv(\"TELEGRAM_API_TOKEN\"))\n    if err != nil {\n        panic(err)\n    }\n    bot.Debug = true\n    updateConfig := tgbotapi.NewUpdate(0)\n    updateConfig.Timeout = 60\n    updates := bot.GetUpdatesChan(updateConfig)\n    for update := range updates {\n        go handleUpdate(bot, update)\n    }\n}\n\nfunc handleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n    text := update.Message.Text\n    chatID := update.Message.Chat.ID\n    replyMsg := tgbotapi.NewMessage(chatID, text)\n    _, _ = bot.Send(replyMsg)\n}\n```\n\n## 回復特定訊息\n\n要回復 `回復訊息` ，像是下面的效果也很簡單：\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/22010000-e325-45e6-52f9-64eec6b28500/public)\n\n只需要設定 `replyMsg.ReplyToMessageID` 就可以回復特定的訊息，下面就是直接回覆接收到的訊息：\n\n```go\nfunc handleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n    text := update.Message.Text\n    chatID := update.Message.Chat.ID\n    replyMsg := tgbotapi.NewMessage(chatID, text)\n    replyMsg.ReplyToMessageID = update.Message.MessageID\n    _, _ = bot.Send(replyMsg)\n}\n```\n\n## 處理 Command\n\nTelegram 中，用 `/` 開頭的文字就是 Command，這個函示庫也有寫好處理 Command 的方法，只需要用 `isCommand()`，確認一下是不是 Command 就可以：\n\n```go\nfunc handleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n    text := update.Message.Text\n    chatID := update.Message.Chat.ID\n    replyMsg := tgbotapi.NewMessage(chatID, text)\n    if update.Message.IsCommand() {\n        switch update.Message.Command() {\n        case \"start\":\n            replyMsg.Text = \"Hello \" + update.Message.From.FirstName\n        case \"help\":\n            replyMsg.Text = \"What can I help you?\"\n        default:\n            replyMsg.Text = \"No such command!!!\"\n        }\n    }\n    _, _ = bot.Send(replyMsg)\n}\n```\n\n上面的程式碼其實也可以看到如何拿到傳送者的一些基本資料。\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0fd54240-5c18-4b75-c7be-981cdb144e00/public)\n\n## Reference\n\n- [Telegram APIs](https://core.telegram.org/)\n- [Golang bindings for the Telegram Bot API - GitHub](https://github.com/go-telegram-bot-api/telegram-bot-api)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Telegram/go-tg-bot.md","excerpt":"Telegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。 新增自己的 Bot image Telegram 非常有趣，要新增自己的 Bot，只要跟 Telegram 上的 BotFather ，他就會給你一個 Bot。 image 按 BotFather 給你的步驟做，最後可以看到他會提供一個 API Token …","frontmatter":{"title":"用 Go 寫 Telegram Bot","date":"2021-12-11T14:30:15.000Z","draft":false,"tags":["go","golang","telegram","bot","telegram-bot"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f8c04956-a2ef-4cba-b9fe-2a5ceff40b00/public","description":"Telegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。"}}},{"node":{"id":"d8fb3977-7c7f-57ad-83c2-8dc1d7ba1927","html":"<p>Flutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是 <code class=\"language-text\">() {}</code> 寫法，另一個是 <code class=\"language-text\">() =></code> 寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。</p>\n<!--more-->\n<h2>不同在哪</h2>\n<p>下面我用在寫 Flutter 中常見的創建一個有 10 個 Text 的 List 舉例。</p>\n<p>創建一個有 10 項元素的 List：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Text</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">.</span><span class=\"token function\">generate</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>上面就是輸出一個帶有 0-9 的 List，那現在假設我會需要再創建 Text 前，根據 index 來做一些改變，下面就做最簡單的平方。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Text</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">.</span><span class=\"token function\">generate</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do some work</span>\n    <span class=\"token keyword\">var</span> text <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">*</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>觀察上面兩個例子，不難發現兩個的差別，第一個寫法 <code class=\"language-text\">() =></code> 後面直接接上一個表達式(Expression)，當作回傳值。而 <code class=\"language-text\">() {}</code> 則是在大括號中寫一個完整的 Function，所以要寫一個 return。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/51868395/flutter-dart-difference-between-and\">Flutter/Dart - Difference between () {} and () => {}</a></li>\n</ul>","rawMarkdownBody":"\nFlutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是 `() {}` 寫法，另一個是 `() =>` 寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。\n\n<!--more-->\n\n## 不同在哪\n\n下面我用在寫 Flutter 中常見的創建一個有 10 個 Text 的 List 舉例。\n\n創建一個有 10 項元素的 List：\n\n```dart\nList<Text> list = List.generate(10, (index) => Text(index.toString()));\n```\n\n上面就是輸出一個帶有 0-9 的 List，那現在假設我會需要再創建 Text 前，根據 index 來做一些改變，下面就做最簡單的平方。\n\n```dart\nList<Text> list = List.generate(10, (index) {\n    // do some work\n    var text = (index * index).toString();\n    return Text(text);\n});\n```\n\n觀察上面兩個例子，不難發現兩個的差別，第一個寫法 `() =>` 後面直接接上一個表達式(Expression)，當作回傳值。而 `() {}` 則是在大括號中寫一個完整的 Function，所以要寫一個 return。\n\n## Reference\n\n- [Flutter/Dart - Difference between () {} and () => {}](https://stackoverflow.com/questions/51868395/flutter-dart-difference-between-and)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Flutter/Dart Function Lambda diff.md","excerpt":"Flutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是  寫法，另一個是  寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。 不同在哪 下面我用在寫 Flutter 中常見的創建一個有 10 個 Text 的 List 舉例。 創建一個有 10 項元素的 List： 上面就是輸出一個帶有 0-9…","frontmatter":{"title":"Flutter/Dart (){} 和 () => 的差別","date":"2021-11-04T05:52:44.000Z","draft":false,"tags":["dart","flutter","function"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f8a3eaa5-e9c2-455f-d301-43fc77fee200/large","description":"Flutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是 () {} 寫法，另一個是 () => 寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。"}}},{"node":{"id":"5a287e0a-4039-585c-b56d-03d41cb6b549","html":"<p>上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。</p>\n<!--more-->\n<blockquote>\n<p>No one likes to wait. Internet impatience is something we all suffer from.</p>\n</blockquote>\n<p>文章一開頭就用一句點出大家在上網時會遇到的狀況，沒有人喜歡等待，可是所有人都在上網時身受其害，相信大家都遇過下面的情況：</p>\n<ol>\n<li>等待 App 完成內容更新</li>\n<li>等待網頁出現</li>\n<li>等待電影開始播放</li>\n</ol>\n<p>但有寫過程式或服務的都知道，人一多，就一定慢，非常的難避免，<del>所以這時候就要用 Cloudflare</del>，這時又宣傳了一下 Cloudflare。</p>\n<p>許多使用者家裡都會覺得網路很慢，然後買了很快很快的網速，像是 100Mbpa, 1Gbps 甚至 2Gbps，但其實就算家裡的網路再怎麼快，你連線的 Server 就是很慢，你的上網體驗還是大打折扣。</p>\n<p>如果要讓自己的服務不卡，只需要完成下面三樣要求：</p>\n<ol>\n<li>Server 有充足的帶寬</li>\n<li>讓 Server 盡量接近 User</li>\n<li>讓你的 Web 或 App 盡量得快</li>\n</ol>\n<p>看起來很簡單，但如果要完成這三個要求，都會耗費極大的成本。</p>\n<h2>DNS</h2>\n<p>現今的網路世界主要是由 ipv4 組成，也就是說，如果沒有 ipv4 地址，所有的網路連線都不會發生，如果我只知道 <a href=\"www.fcu.edu.tw\">www.fcu.edu.tw</a>，是完全沒有辦法上網的，因為我並不知道這個網址對應的 ip 是多少 (像是 140.134.xxx.xxx)，就完全沒有辦法和伺服器產生連線。DNS 出現前，大家都是直接用 ip 溝通，快速方便，最大的缺點就是非常難記。所以 DNS 就出現了，DNS 就像你打電話會需要電話簿一樣，我只我需要一個簡單好記的名字，再去電話簿搜尋真正的電話號碼就好。</p>\n<p>在知道電話號碼前，所有網路連線都不會發生，所以用最快速的方式查找電話簿絕對是上網速度最重要的一環，如果光是要知道 ip 位置就花掉 50ms(甚至更多)，上網效率就會大大降低。如今網路上有許多的 DNS 提供商，為大家記下這龐大的 DNS 電話簿，最著名的就是 Google 的 <a href=\"8.8.8.8\">8.8.8.8</a>，和 Cloudflare 的 <a href=\"1.1.1.1\">1.1.1.1</a>，Cloudflare 宣稱他是全世界最快的 DNS 提供商，(雖然在台灣好像未必)，但 Cloudflare 承諾他不會<strong>紀錄</strong>使用者查過的 DNS 紀錄，或上過什麼網頁 (好像是在暗示競爭對手會這麼做)。</p>\n<p>另外，就算 DNS 伺服器完全不假思索 (沒有反應時間) 就回傳 DNS 的查詢結果，這也付出了至少一個<a href=\"#%E5%85%89%E9%80%9F%E6%90%8D%E8%80%97\"><strong>光速的代價</strong></a>，聽起來好像沒什麼影響，但可以看看下面簡單的計算。</p>\n<h3>光速損耗</h3>\n<p>假設我家和 DNS 伺服器之間的直線距離是 100 公里，而且中華電信筆直的連接了一條筆直光纖到 DNS 伺服器，而光在光纖中的速度是 200,000,000 公尺/秒，往返需要 200,000 公尺。經過這樣簡單的計算，光是光速就已經耗費整整 1 毫秒(ms)，可以試著想想看更糟的情況，光速已經開始在嚴重拖累網速。</p>\n<h2>Hello Hello OK</h2>\n<p>知道了 ip 後，瀏覽器終於可以連上目標伺服器取得網頁，不久後就可以看到網頁出現在眼前。</p>\n<p>上面的步驟，幾乎都是由 TCP 協定完成，協定的第一步就是你的電腦和伺服器互相同意連線，這個過程稱作三向交握 (Three-Way Handshake)，步驟如下：</p>\n<ol>\n<li>Client 對 Server 說：Hello</li>\n<li>Server 對 Client 說：我聽到你說 Hello</li>\n<li>Client 對 Server 說：我聽到 -- 你說你聽到我說 Hello，我們現在可以溝通了。</li>\n</ol>\n<p>從上面的步驟就可以發現，已經至少耗費了<a href=\"#%E5%85%89%E9%80%9F%E6%90%8D%E8%80%97\">一個光速的時間</a>，所以也是一樣，伺服器愈靠近用戶，網速就愈快。這也是為什麼 Cloudflare 在世界各地廣設伺服器。</p>\n<h3>TLS/SSL</h3>\n<p>有了 TCP 我們就可以安全的連線了嗎？當然不是，TCP 一點也不安全，現在的網路連線幾乎都是透過 TLS (或稱作 SSL) 加密連線，所以 TCP 連線後，下一步是建立安全的加密連線。</p>\n<p>TLS 是一個非常複雜的加密協定，會牽涉到下面的設備：網路瀏覽器、建立鑰匙的伺服器，而且還要有一個可以證明他的身分的伺服器，因為不會想要和銀行建立安全連線，但你根本不確定他是不是你的銀行。</p>\n<p>上面的步驟也會需要好幾次<a href=\"#%E5%85%89%E9%80%9F%E6%90%8D%E8%80%97\">光速損耗</a>，所以讓伺服器愈靠近用戶端愈好。另外，也要盡量使用最新的 TLS 標準 (現在是 TLS 1.3)。</p>\n<h2>後記</h2>\n<p>我覺得這篇文章最有趣的的部分就是一直在討論光速對網路連線的影響，以往我都覺得光速很快，但光就算很快，光也是要跑很長一段距離，這樣耗損來回個幾次就已經對網路連線產生極大的影響了，而且更何況一個連線就一定會需要來回溝通好幾次。這篇文章後面還有蠻多內容，但我覺得沒有那麼重要就懶得寫了，有興趣的話可以自己繼續往下看。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://blog.cloudflare.com/fastest-internet/\">Welcome to Speed Week and a Waitless Internet</a></li>\n</ul>","rawMarkdownBody":"\n上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。\n\n<!--more-->\n\n> No one likes to wait. Internet impatience is something we all suffer from.\n\n文章一開頭就用一句點出大家在上網時會遇到的狀況，沒有人喜歡等待，可是所有人都在上網時身受其害，相信大家都遇過下面的情況：\n\n1. 等待 App 完成內容更新\n2. 等待網頁出現\n3. 等待電影開始播放\n\n但有寫過程式或服務的都知道，人一多，就一定慢，非常的難避免，~~所以這時候就要用 Cloudflare~~，這時又宣傳了一下 Cloudflare。\n\n許多使用者家裡都會覺得網路很慢，然後買了很快很快的網速，像是 100Mbpa, 1Gbps 甚至 2Gbps，但其實就算家裡的網路再怎麼快，你連線的 Server 就是很慢，你的上網體驗還是大打折扣。\n\n如果要讓自己的服務不卡，只需要完成下面三樣要求：\n\n1. Server 有充足的帶寬\n2. 讓 Server 盡量接近 User\n3. 讓你的 Web 或 App 盡量得快\n\n看起來很簡單，但如果要完成這三個要求，都會耗費極大的成本。\n\n## DNS\n\n現今的網路世界主要是由 ipv4 組成，也就是說，如果沒有 ipv4 地址，所有的網路連線都不會發生，如果我只知道 [www.fcu.edu.tw](www.fcu.edu.tw)，是完全沒有辦法上網的，因為我並不知道這個網址對應的 ip 是多少 (像是 140.134.xxx.xxx)，就完全沒有辦法和伺服器產生連線。DNS 出現前，大家都是直接用 ip 溝通，快速方便，最大的缺點就是非常難記。所以 DNS 就出現了，DNS 就像你打電話會需要電話簿一樣，我只我需要一個簡單好記的名字，再去電話簿搜尋真正的電話號碼就好。\n\n在知道電話號碼前，所有網路連線都不會發生，所以用最快速的方式查找電話簿絕對是上網速度最重要的一環，如果光是要知道 ip 位置就花掉 50ms(甚至更多)，上網效率就會大大降低。如今網路上有許多的 DNS 提供商，為大家記下這龐大的 DNS 電話簿，最著名的就是 Google 的 [8.8.8.8](8.8.8.8)，和 Cloudflare 的 [1.1.1.1](1.1.1.1)，Cloudflare 宣稱他是全世界最快的 DNS 提供商，(雖然在台灣好像未必)，但 Cloudflare 承諾他不會**紀錄**使用者查過的 DNS 紀錄，或上過什麼網頁 (好像是在暗示競爭對手會這麼做)。\n\n另外，就算 DNS 伺服器完全不假思索 (沒有反應時間) 就回傳 DNS 的查詢結果，這也付出了至少一個[**光速的代價**](#光速損耗)，聽起來好像沒什麼影響，但可以看看下面簡單的計算。\n\n### 光速損耗\n\n假設我家和 DNS 伺服器之間的直線距離是 100 公里，而且中華電信筆直的連接了一條筆直光纖到 DNS 伺服器，而光在光纖中的速度是 200,000,000 公尺/秒，往返需要 200,000 公尺。經過這樣簡單的計算，光是光速就已經耗費整整 1 毫秒(ms)，可以試著想想看更糟的情況，光速已經開始在嚴重拖累網速。\n\n## Hello Hello OK\n\n知道了 ip 後，瀏覽器終於可以連上目標伺服器取得網頁，不久後就可以看到網頁出現在眼前。\n\n上面的步驟，幾乎都是由 TCP 協定完成，協定的第一步就是你的電腦和伺服器互相同意連線，這個過程稱作三向交握 (Three-Way Handshake)，步驟如下：\n\n1. Client 對 Server 說：Hello\n2. Server 對 Client 說：我聽到你說 Hello\n3. Client 對 Server 說：我聽到 -- 你說你聽到我說 Hello，我們現在可以溝通了。\n\n從上面的步驟就可以發現，已經至少耗費了[一個光速的時間](#光速損耗)，所以也是一樣，伺服器愈靠近用戶，網速就愈快。這也是為什麼 Cloudflare 在世界各地廣設伺服器。\n\n### TLS/SSL\n\n有了 TCP 我們就可以安全的連線了嗎？當然不是，TCP 一點也不安全，現在的網路連線幾乎都是透過 TLS (或稱作 SSL) 加密連線，所以 TCP 連線後，下一步是建立安全的加密連線。\n\nTLS 是一個非常複雜的加密協定，會牽涉到下面的設備：網路瀏覽器、建立鑰匙的伺服器，而且還要有一個可以證明他的身分的伺服器，因為不會想要和銀行建立安全連線，但你根本不確定他是不是你的銀行。\n\n上面的步驟也會需要好幾次[光速損耗](#光速損耗)，所以讓伺服器愈靠近用戶端愈好。另外，也要盡量使用最新的 TLS 標準 (現在是 TLS 1.3)。\n\n## 後記\n\n我覺得這篇文章最有趣的的部分就是一直在討論光速對網路連線的影響，以往我都覺得光速很快，但光就算很快，光也是要跑很長一段距離，這樣耗損來回個幾次就已經對網路連線產生極大的影響了，而且更何況一個連線就一定會需要來回溝通好幾次。這篇文章後面還有蠻多內容，但我覺得沒有那麼重要就懶得寫了，有興趣的話可以自己繼續往下看。\n\n## Reference\n\n- [Welcome to Speed Week and a Waitless Internet](https://blog.cloudflare.com/fastest-internet/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/Cloudflare Speed Week.md","excerpt":"上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。 No one likes to wait. Internet impatienc…","frontmatter":{"title":"Cloudflare Speed Week","date":"2021-10-05T16:10:58.000Z","draft":false,"tags":["cloudflare","web","internet","tcp"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/be2106f3-0557-4e94-803a-9dda63550300/public","description":"上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。"}}},{"node":{"id":"829e849f-13bc-5b82-8699-88b701b8f0e3","html":"<p>Kotlin 在非同步處理上有新的方法，協程 <code class=\"language-text\">Coroutine</code>。<code class=\"language-text\">Coroutine</code> 不會像 <code class=\"language-text\">Thread</code> 會耗費大量的資源，能在原本的<code class=\"language-text\">線程</code>上創建極為輕量的<code class=\"language-text\">協程</code>，且較不會發生記憶體洩漏的情況。</p>\n<!--more-->\n<h2>導入 Coroutine</h2>\n<p>在 <code class=\"language-text\">build.gradle</code> 中添加依賴項</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">dependencies <span class=\"token punctuation\">{</span>\n    implementation <span class=\"token string\">'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2'</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>若要在 <code class=\"language-text\">Android</code> 中使用需要再添加 <code class=\"language-text\">Android</code> 依賴</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">implementation <span class=\"token string\">'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2'</span></code></pre></div>\n<h2>第一個 Coroutine</h2>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">//在後台啟動一個新的縣協程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//非阻塞式的等待 1 秒鐘</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 阻塞主線程兩秒確保主線程存活</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的程式碼輸出結果：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">Hellow<span class=\"token punctuation\">,</span>\nWorld</code></pre></div>\n<p>基本上 <code class=\"language-text\">Coroutine</code> 就是輕量的協程</p>\n<p>也可以分別將 <code class=\"language-text\">GlobalScope.launch{...}</code> 和 <code class=\"language-text\">delay(...)</code> 替換成<code class=\"language-text\">thread { ... }</code> 和 <code class=\"language-text\">Thread.Sleap(...)</code>，也可以得到相同的結果，可以嘗試一下。</p>\n<p>如果只將 <code class=\"language-text\">GlobalScope.launch{...}</code> 替換成 <code class=\"language-text\">thread{...}</code> 你會得到以下錯誤：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another <span class=\"token function\">suspend</span> <span class=\"token keyword\">function</span></code></pre></div>\n<p>因為 <code class=\"language-text\">delay()</code> 是一個特殊的 <code class=\"language-text\">suspend function</code> (有人譯作 <code class=\"language-text\">掛起函數</code>)，他不會阻塞線程，但是會 <code class=\"language-text\">suspend</code> 協程，而且只能在協程中使用。</p>\n<h2>橋接阻塞和非阻塞的世界</h2>\n<p>上面的範例中同時使用了非阻塞式的 <code class=\"language-text\">delay()</code> 和阻塞式的 <code class=\"language-text\">Thread.sleap()</code>，這樣很容易讓我們混淆哪個會阻塞線程。下面我們使用 <code class=\"language-text\">runblocking{...}</code> 來阻塞線程</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 在後台啟動一個新的協程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    runBlocking <span class=\"token punctuation\">{</span>     <span class=\"token comment\">// 這個表達式會阻塞主線程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 延遲兩秒來確保主線程存活</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>結果基本上是相似的，只是都是使用了非組塞式的 <code class=\"language-text\">delay()</code>。調用了 <code class=\"language-text\">runblocking{...}</code> 的主線程會被阻塞直到 <code class=\"language-text\">runblocking{...}</code> 內的協程執行完畢。</p>\n<p>下面用一個更合乎慣用法的方法在寫一次，用 <code class=\"language-text\">runblocking{...}</code> 來包裝 <code class=\"language-text\">main</code> 方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 開始執行主協程</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 在後台啓動一個協程並繼續執行</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 延遲 2 秒來確保主線程存活</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這裡的 <code class=\"language-text\">runBlocking {...}</code> 用來啟動主線程。我們顯式指定了其返回類型 <code class=\"language-text\">Unit</code>，因為在 Kotlin 中 <code class=\"language-text\">main</code> 方法必須回傳 <code class=\"language-text\">Unit</code>。</p>\n<h2>等待一個作業完成</h2>\n<p>延遲一段時間來確保協程的運行並不是一個好辦法利用 <code class=\"language-text\">job.join()</code> 來確保工作執行結束。</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job<span class=\"token operator\">:</span> Job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">launch</code> 會回傳一個 <code class=\"language-text\">Job</code> 物件，而 <code class=\"language-text\">job.join()</code> 其實就是會等待 <code class=\"language-text\">job</code> 的工作完成再繼續持行。</p>\n<p>我們也可以利用 <code class=\"language-text\">job.cancel()</code> 取消協程：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job<span class=\"token operator\">:</span> Job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>但是如果 <code class=\"language-text\">job</code> 已經完成工作，<code class=\"language-text\">cancel</code> 是不會發生任何事。</p>\n<h2>參考資料</h2>\n<ul>\n<li><a href=\"https://kotlinlang.org/docs/reference/coroutines/basics.html\">Coroutine Basics</a></li>\n</ul>","rawMarkdownBody":"\nKotlin 在非同步處理上有新的方法，協程 `Coroutine`。`Coroutine` 不會像 `Thread` 會耗費大量的資源，能在原本的`線程`上創建極為輕量的`協程`，且較不會發生記憶體洩漏的情況。\n\n<!--more-->\n\n## 導入 Coroutine\n\n在 `build.gradle` 中添加依賴項\n\n```groovy\ndependencies {\n    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2'\n}\n```\n\n若要在 `Android` 中使用需要再添加 `Android` 依賴\n\n```groovy\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2'\n```\n\n## 第一個 Coroutine\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { //在後台啟動一個新的縣協程\n        delay(1000L) //非阻塞式的等待 1 秒鐘\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    Thread.sleep(2000L) // 阻塞主線程兩秒確保主線程存活\n}\n```\n\n上面的程式碼輸出結果：\n\n```kotlin\nHellow,\nWorld\n```\n\n基本上 `Coroutine` 就是輕量的協程\n\n也可以分別將 `GlobalScope.launch{...}` 和 `delay(...)` 替換成`thread { ... }` 和 `Thread.Sleap(...)`，也可以得到相同的結果，可以嘗試一下。\n\n如果只將 `GlobalScope.launch{...}` 替換成 `thread{...}` 你會得到以下錯誤：\n\n```shell\nError: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function\n```\n\n因為 `delay()` 是一個特殊的 `suspend function` (有人譯作 `掛起函數`)，他不會阻塞線程，但是會 `suspend` 協程，而且只能在協程中使用。\n\n## 橋接阻塞和非阻塞的世界\n\n上面的範例中同時使用了非阻塞式的 `delay()` 和阻塞式的 `Thread.sleap()`，這樣很容易讓我們混淆哪個會阻塞線程。下面我們使用 `runblocking{...}` 來阻塞線程\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { // 在後台啟動一個新的協程\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    runBlocking {     // 這個表達式會阻塞主線程\n        delay(2000L)  // 延遲兩秒來確保主線程存活\n    }\n}\n```\n\n結果基本上是相似的，只是都是使用了非組塞式的 `delay()`。調用了 `runblocking{...}` 的主線程會被阻塞直到 `runblocking{...}` 內的協程執行完畢。\n\n下面用一個更合乎慣用法的方法在寫一次，用 `runblocking{...}` 來包裝 `main` 方法：\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> { // 開始執行主協程\n    GlobalScope.launch { // 在後台啓動一個協程並繼續執行\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    delay(2000L)  // 延遲 2 秒來確保主線程存活\n}\n```\n\n這裡的 `runBlocking {...}` 用來啟動主線程。我們顯式指定了其返回類型 `Unit`，因為在 Kotlin 中 `main` 方法必須回傳 `Unit`。\n\n## 等待一個作業完成\n\n延遲一段時間來確保協程的運行並不是一個好辦法利用 `job.join()` 來確保工作執行結束。\n\n```kotlin\nval job: Job = GlobalScope.launch {\n    delay(1000L)\n    println(\"World!\")\n}\nprintln(\"Hello,\")\njob.join()\n```\n\n`launch` 會回傳一個 `Job` 物件，而 `job.join()` 其實就是會等待 `job` 的工作完成再繼續持行。\n\n我們也可以利用 `job.cancel()` 取消協程：\n\n```kotlin\nval job: Job = GlobalScope.launch {\n    delay(1000L)\n    println(\"World!\")\n}\nprintln(\"Hello,\")\njob.cancel()\n```\n\n但是如果 `job` 已經完成工作，`cancel` 是不會發生任何事。\n\n## 參考資料\n\n- [Coroutine Basics](https://kotlinlang.org/docs/reference/coroutines/basics.html)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Kotlin/kotlin coroutine.md","excerpt":"Kotlin 在非同步處理上有新的方法，協程 。 不會像  會耗費大量的資源，能在原本的上創建極為輕量的，且較不會發生記憶體洩漏的情況。 導入 Coroutine 在  中添加依賴項 若要在  中使用需要再添加  依賴 第一個 Coroutine 上面的程式碼輸出結果： 基本上  就是輕量的協程 也可以分別將  和  替換成 和 ，也可以得到相同的結果，可以嘗試一下。 如果只將  替換成  你會…","frontmatter":{"title":"Kotlin Coroutine","date":"2021-09-19T07:26:56.000Z","draft":false,"tags":["kotlin","coroutine"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6f11a63e-3923-4ce5-3b6e-d06243815300/public","description":"Kotlin 在非同步處理上有新的方法，協程 Coroutine，Coroutine 不會像 Thread 會耗費大量的資源，能在原本的線程上創建極為輕量的協程，且較不會發生記憶體洩漏的情況。"}}}]}},"pageContext":{"limit":8,"skip":8,"numPages":4,"currentPage":2}},"staticQueryHashes":[]}