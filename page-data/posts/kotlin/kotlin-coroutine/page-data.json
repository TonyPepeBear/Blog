{"componentChunkName":"component---src-templates-article-template-tsx","path":"/posts/kotlin/kotlin-coroutine","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"829e849f-13bc-5b82-8699-88b701b8f0e3","html":"<p>Kotlin 在非同步處理上有新的方法，協程 <code class=\"language-text\">Coroutine</code>。<code class=\"language-text\">Coroutine</code> 不會像 <code class=\"language-text\">Thread</code> 會耗費大量的資源，能在原本的<code class=\"language-text\">線程</code>上創建極為輕量的<code class=\"language-text\">協程</code>，且較不會發生記憶體洩漏的情況。</p>\n<!--more-->\n<h2>導入 Coroutine</h2>\n<p>在 <code class=\"language-text\">build.gradle</code> 中添加依賴項</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">dependencies <span class=\"token punctuation\">{</span>\n    implementation <span class=\"token string\">'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2'</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>若要在 <code class=\"language-text\">Android</code> 中使用需要再添加 <code class=\"language-text\">Android</code> 依賴</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">implementation <span class=\"token string\">'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2'</span></code></pre></div>\n<h2>第一個 Coroutine</h2>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">//在後台啟動一個新的縣協程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//非阻塞式的等待 1 秒鐘</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 阻塞主線程兩秒確保主線程存活</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的程式碼輸出結果：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">Hellow<span class=\"token punctuation\">,</span>\nWorld</code></pre></div>\n<p>基本上 <code class=\"language-text\">Coroutine</code> 就是輕量的協程</p>\n<p>也可以分別將 <code class=\"language-text\">GlobalScope.launch{...}</code> 和 <code class=\"language-text\">delay(...)</code> 替換成<code class=\"language-text\">thread { ... }</code> 和 <code class=\"language-text\">Thread.Sleap(...)</code>，也可以得到相同的結果，可以嘗試一下。</p>\n<p>如果只將 <code class=\"language-text\">GlobalScope.launch{...}</code> 替換成 <code class=\"language-text\">thread{...}</code> 你會得到以下錯誤：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another <span class=\"token function\">suspend</span> <span class=\"token keyword\">function</span></code></pre></div>\n<p>因為 <code class=\"language-text\">delay()</code> 是一個特殊的 <code class=\"language-text\">suspend function</code> (有人譯作 <code class=\"language-text\">掛起函數</code>)，他不會阻塞線程，但是會 <code class=\"language-text\">suspend</code> 協程，而且只能在協程中使用。</p>\n<h2>橋接阻塞和非阻塞的世界</h2>\n<p>上面的範例中同時使用了非阻塞式的 <code class=\"language-text\">delay()</code> 和阻塞式的 <code class=\"language-text\">Thread.sleap()</code>，這樣很容易讓我們混淆哪個會阻塞線程。下面我們使用 <code class=\"language-text\">runblocking{...}</code> 來阻塞線程</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 在後台啟動一個新的協程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    runBlocking <span class=\"token punctuation\">{</span>     <span class=\"token comment\">// 這個表達式會阻塞主線程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 延遲兩秒來確保主線程存活</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>結果基本上是相似的，只是都是使用了非組塞式的 <code class=\"language-text\">delay()</code>。調用了 <code class=\"language-text\">runblocking{...}</code> 的主線程會被阻塞直到 <code class=\"language-text\">runblocking{...}</code> 內的協程執行完畢。</p>\n<p>下面用一個更合乎慣用法的方法在寫一次，用 <code class=\"language-text\">runblocking{...}</code> 來包裝 <code class=\"language-text\">main</code> 方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 開始執行主協程</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 在後台啓動一個協程並繼續執行</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 延遲 2 秒來確保主線程存活</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這裡的 <code class=\"language-text\">runBlocking {...}</code> 用來啟動主線程。我們顯式指定了其返回類型 <code class=\"language-text\">Unit</code>，因為在 Kotlin 中 <code class=\"language-text\">main</code> 方法必須回傳 <code class=\"language-text\">Unit</code>。</p>\n<h2>等待一個作業完成</h2>\n<p>延遲一段時間來確保協程的運行並不是一個好辦法利用 <code class=\"language-text\">job.join()</code> 來確保工作執行結束。</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job<span class=\"token operator\">:</span> Job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">launch</code> 會回傳一個 <code class=\"language-text\">Job</code> 物件，而 <code class=\"language-text\">job.join()</code> 其實就是會等待 <code class=\"language-text\">job</code> 的工作完成再繼續持行。</p>\n<p>我們也可以利用 <code class=\"language-text\">job.cancel()</code> 取消協程：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job<span class=\"token operator\">:</span> Job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>但是如果 <code class=\"language-text\">job</code> 已經完成工作，<code class=\"language-text\">cancel</code> 是不會發生任何事。</p>\n<h2>參考資料</h2>\n<ul>\n<li><a href=\"https://kotlinlang.org/docs/reference/coroutines/basics.html\">Coroutine Basics</a></li>\n</ul>","rawMarkdownBody":"\nKotlin 在非同步處理上有新的方法，協程 `Coroutine`。`Coroutine` 不會像 `Thread` 會耗費大量的資源，能在原本的`線程`上創建極為輕量的`協程`，且較不會發生記憶體洩漏的情況。\n\n<!--more-->\n\n## 導入 Coroutine\n\n在 `build.gradle` 中添加依賴項\n\n```groovy\ndependencies {\n    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2'\n}\n```\n\n若要在 `Android` 中使用需要再添加 `Android` 依賴\n\n```groovy\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2'\n```\n\n## 第一個 Coroutine\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { //在後台啟動一個新的縣協程\n        delay(1000L) //非阻塞式的等待 1 秒鐘\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    Thread.sleep(2000L) // 阻塞主線程兩秒確保主線程存活\n}\n```\n\n上面的程式碼輸出結果：\n\n```kotlin\nHellow,\nWorld\n```\n\n基本上 `Coroutine` 就是輕量的協程\n\n也可以分別將 `GlobalScope.launch{...}` 和 `delay(...)` 替換成`thread { ... }` 和 `Thread.Sleap(...)`，也可以得到相同的結果，可以嘗試一下。\n\n如果只將 `GlobalScope.launch{...}` 替換成 `thread{...}` 你會得到以下錯誤：\n\n```shell\nError: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function\n```\n\n因為 `delay()` 是一個特殊的 `suspend function` (有人譯作 `掛起函數`)，他不會阻塞線程，但是會 `suspend` 協程，而且只能在協程中使用。\n\n## 橋接阻塞和非阻塞的世界\n\n上面的範例中同時使用了非阻塞式的 `delay()` 和阻塞式的 `Thread.sleap()`，這樣很容易讓我們混淆哪個會阻塞線程。下面我們使用 `runblocking{...}` 來阻塞線程\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { // 在後台啟動一個新的協程\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    runBlocking {     // 這個表達式會阻塞主線程\n        delay(2000L)  // 延遲兩秒來確保主線程存活\n    }\n}\n```\n\n結果基本上是相似的，只是都是使用了非組塞式的 `delay()`。調用了 `runblocking{...}` 的主線程會被阻塞直到 `runblocking{...}` 內的協程執行完畢。\n\n下面用一個更合乎慣用法的方法在寫一次，用 `runblocking{...}` 來包裝 `main` 方法：\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> { // 開始執行主協程\n    GlobalScope.launch { // 在後台啓動一個協程並繼續執行\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    delay(2000L)  // 延遲 2 秒來確保主線程存活\n}\n```\n\n這裡的 `runBlocking {...}` 用來啟動主線程。我們顯式指定了其返回類型 `Unit`，因為在 Kotlin 中 `main` 方法必須回傳 `Unit`。\n\n## 等待一個作業完成\n\n延遲一段時間來確保協程的運行並不是一個好辦法利用 `job.join()` 來確保工作執行結束。\n\n```kotlin\nval job: Job = GlobalScope.launch {\n    delay(1000L)\n    println(\"World!\")\n}\nprintln(\"Hello,\")\njob.join()\n```\n\n`launch` 會回傳一個 `Job` 物件，而 `job.join()` 其實就是會等待 `job` 的工作完成再繼續持行。\n\n我們也可以利用 `job.cancel()` 取消協程：\n\n```kotlin\nval job: Job = GlobalScope.launch {\n    delay(1000L)\n    println(\"World!\")\n}\nprintln(\"Hello,\")\njob.cancel()\n```\n\n但是如果 `job` 已經完成工作，`cancel` 是不會發生任何事。\n\n## 參考資料\n\n- [Coroutine Basics](https://kotlinlang.org/docs/reference/coroutines/basics.html)\n","excerpt":"Kotlin 在非同步處理上有新的方法，協程 。 不會像  會耗費大量的資源，能在原本的上創建極為輕量的，且較不會發生記憶體洩漏的情況。 導入 Coroutine 在  中添加依賴項 若要在  中使用需要再添加  依賴 第一個 Coroutine 上面的程式碼輸出結果： 基本上  就是輕量的協程 也可以分別將  和  替換成 和 ，也可以得到相同的結果，可以嘗試一下。 如果只將  替換成  你會…","frontmatter":{"title":"Kotlin Coroutine","date":"2021-09-19T07:26:56.000Z","draft":false,"tags":["kotlin","coroutine"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6f11a63e-3923-4ce5-3b6e-d06243815300/public","description":"Kotlin 在非同步處理上有新的方法，協程 Coroutine，Coroutine 不會像 Thread 會耗費大量的資源，能在原本的線程上創建極為輕量的協程，且較不會發生記憶體洩漏的情況。"}}}]}},"pageContext":{"id":"829e849f-13bc-5b82-8699-88b701b8f0e3"}},"staticQueryHashes":[]}