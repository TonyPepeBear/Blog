{"componentChunkName":"component---src-templates-article-list-page-template-tsx","path":"/pages/3","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"0328ae6c-1fa1-50d8-aec1-a55575fe59b5","html":"<p>Cloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。</p>\n<p>我覺得目前的缺點就是網路上相關的資料比較少，遇到問題很難找到資料參考，因為他其實主要是 Cloudflare 的一項零信任服務，目標客群都是一些厲害的網管，所以官方寫的文件也都很深奧，如果是新手可能會頭昏眼花。</p>\n<!--more-->\n<p>這一項服務可以先不用帳號就能試用，不過就不能自訂 Domain，我會先介紹免登入的，再介紹要登入的。第一步還是要在本地先安裝環境。</p>\n<h2>安裝 cloudflared</h2>\n<h3>全系統適用</h3>\n<p>注意 Cloudflare 後面多了一個 <code class=\"language-text\">d</code>，這是他連上 Tunnel 的必要程式，是用 Go 編寫，安裝方式就是到<a href=\"https://github.com/cloudflare/cloudflared/releases\">官方 Github</a>下載符合自己環境的執行檔。</p>\n<h3>macOS</h3>\n<p>mac 可以用 Homebrew 安裝：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">brew install cloudflare/cloudflare/cloudflared</code></pre></div>\n<h3>Windows</h3>\n<p>Windows 永遠是最麻煩的，下載完執行檔後，隨便丟到一個資料夾，然後加到 PATH 裡。</p>\n<h3>Update</h3>\n<p>要更新這個執行檔，只要 Run 下面的指令，另外，Windows 不支援自動更新，要更新就只能手動下載覆蓋：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared update</code></pre></div>\n<h2>免登入測試 Tunnel</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel --url http://localhost:8080</code></pre></div>\n<p>執行上面的指令，就可以將本地電腦的 8080 port 用 http 公開到網路上，應該會看到輸出中會給一串個 <code class=\"language-text\">*-*-*.trycloudflare.com</code> 的網址，現在只要訪問那個網址，就可以發現本地的網頁已經可以從全網連到，不需註冊，也不用設定複雜的 Domain，還不限流量。</p>\n<h2>登入 Cloudflare</h2>\n<p>第一步就是先登入 Cloudflare 的帳號，也要有一個已經託管給 Cloudflare 的 Domain：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel login</code></pre></div>\n<p>執行這個命令後，應該會跳出瀏覽器授權，如果沒有跳出，就手動複製提供的授權網址登入 Cloudflare 帳號。</p>\n<h2>創建並使用 Tunnel</h2>\n<p>登入完成後就可以開始創建通道，創建只會在本地產生一些文件，並不會有任何連線的動作，可以放心執行：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel create &lt;Name&gt;</code></pre></div>\n<p>創建完成後，Cloudflare 會給一組 UUID，可以看一下有沒有創建成功：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel list</code></pre></div>\n<p>如果要刪除就是 Delete：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel delete &lt;Name or UUID&gt;</code></pre></div>\n<h2>DNS 設定</h2>\n<p>在創建 Tunnel 後，Cloudflare 會將剛剛創建隧道時產生的 UUID 綁定到 <code class=\"language-text\">&lt;UUID>.cfargotunnel.com</code> 這個 Domain，不過 Cloudflare 會擋掉用這個 Domain 直接連線的流量，所以我們要把我們的 Domain 新增一個 CNAME 紀錄，把流量往這邊導。</p>\n<p>有兩個方法可以設定 CNAME，一個是自己去 Cloudflare 的官網設定：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210813165733.png\" alt=\"img\"></p>\n<p>另一個是直接用指令設定，快又方便，把後面的 domain 改成自己想要綁定的：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel route dns &lt;Name or UUID&gt; test.example.com</code></pre></div>\n<p>打完後如果不放心，還是可以自己到 Cloudflare 的 Dns 設定看一下有沒有設定完成，應該會看到跟上圖一樣產生一個 CNAME Record。</p>\n<h2>Tunnel Config</h2>\n<p>下面是最簡單的 Config 範例，這是一個 <code class=\"language-text\">yml</code> 檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">tunnel</span><span class=\"token punctuation\">:</span> &lt;Name<span class=\"token punctuation\">></span>\n\n<span class=\"token key atrule\">ingress</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">hostname</span><span class=\"token punctuation\">:</span> test.example.com\n    <span class=\"token key atrule\">service</span><span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">:</span>//localhost<span class=\"token punctuation\">:</span><span class=\"token number\">8080</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">service</span><span class=\"token punctuation\">:</span> http_status<span class=\"token punctuation\">:</span><span class=\"token number\">404</span></code></pre></div>\n<p>上面會把 8080 的 HTTP 流量導到 <code class=\"language-text\">domain.example.com</code>，使用剛剛創建的 Tunnel。</p>\n<p>最後一行一定要有一個可以接受所有流量的 Service，不然服務會不能啟動，這裡全部往 404 導。</p>\n<h2>Run Tunnel</h2>\n<p>最後一步，加上 config 的參數，把剛剛的 yml 檔喂給 Cloudflare，就可以啟動通道了：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel --config test.yml run</code></pre></div>\n<h2>後記</h2>\n<p>這篇只介紹了如何創建一個 Http 的 Tunnel，如果要開其他的 TCP Port，還需要其他的設定，而且在 Client 端也會需要安裝 Cloudflared，所以我留到下一篇在介紹。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://developers.cloudflare.com/cloudflare-one/\">Cloudflare for Teams documentation</a></li>\n</ul>","rawMarkdownBody":"\nCloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。\n\n我覺得目前的缺點就是網路上相關的資料比較少，遇到問題很難找到資料參考，因為他其實主要是 Cloudflare 的一項零信任服務，目標客群都是一些厲害的網管，所以官方寫的文件也都很深奧，如果是新手可能會頭昏眼花。\n\n<!--more-->\n\n這一項服務可以先不用帳號就能試用，不過就不能自訂 Domain，我會先介紹免登入的，再介紹要登入的。第一步還是要在本地先安裝環境。\n\n## 安裝 cloudflared\n\n### 全系統適用\n\n注意 Cloudflare 後面多了一個 `d`，這是他連上 Tunnel 的必要程式，是用 Go 編寫，安裝方式就是到[官方 Github](https://github.com/cloudflare/cloudflared/releases)下載符合自己環境的執行檔。\n\n### macOS\n\nmac 可以用 Homebrew 安裝：\n\n```sh\nbrew install cloudflare/cloudflare/cloudflared\n```\n\n### Windows\n\nWindows 永遠是最麻煩的，下載完執行檔後，隨便丟到一個資料夾，然後加到 PATH 裡。\n\n### Update\n\n要更新這個執行檔，只要 Run 下面的指令，另外，Windows 不支援自動更新，要更新就只能手動下載覆蓋：\n\n```sh\ncloudflared update\n```\n\n## 免登入測試 Tunnel\n\n```sh\ncloudflared tunnel --url http://localhost:8080\n```\n\n執行上面的指令，就可以將本地電腦的 8080 port 用 http 公開到網路上，應該會看到輸出中會給一串個 `*-*-*.trycloudflare.com` 的網址，現在只要訪問那個網址，就可以發現本地的網頁已經可以從全網連到，不需註冊，也不用設定複雜的 Domain，還不限流量。\n\n## 登入 Cloudflare\n\n第一步就是先登入 Cloudflare 的帳號，也要有一個已經託管給 Cloudflare 的 Domain：\n\n```sh\ncloudflared tunnel login\n```\n\n執行這個命令後，應該會跳出瀏覽器授權，如果沒有跳出，就手動複製提供的授權網址登入 Cloudflare 帳號。\n\n## 創建並使用 Tunnel\n\n登入完成後就可以開始創建通道，創建只會在本地產生一些文件，並不會有任何連線的動作，可以放心執行：\n\n```sh\ncloudflared tunnel create <Name>\n```\n\n創建完成後，Cloudflare 會給一組 UUID，可以看一下有沒有創建成功：\n\n```sh\ncloudflared tunnel list\n```\n\n如果要刪除就是 Delete：\n\n```sh\ncloudflared tunnel delete <Name or UUID>\n```\n\n## DNS 設定\n\n在創建 Tunnel 後，Cloudflare 會將剛剛創建隧道時產生的 UUID 綁定到 `<UUID>.cfargotunnel.com` 這個 Domain，不過 Cloudflare 會擋掉用這個 Domain 直接連線的流量，所以我們要把我們的 Domain 新增一個 CNAME 紀錄，把流量往這邊導。\n\n有兩個方法可以設定 CNAME，一個是自己去 Cloudflare 的官網設定：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210813165733.png)\n\n另一個是直接用指令設定，快又方便，把後面的 domain 改成自己想要綁定的：\n\n```sh\ncloudflared tunnel route dns <Name or UUID> test.example.com\n```\n\n打完後如果不放心，還是可以自己到 Cloudflare 的 Dns 設定看一下有沒有設定完成，應該會看到跟上圖一樣產生一個 CNAME Record。\n\n## Tunnel Config\n\n下面是最簡單的 Config 範例，這是一個 `yml` 檔案：\n\n```yml\ntunnel: <Name>\n\ningress:\n  - hostname: test.example.com\n    service: http://localhost:8080\n  - service: http_status:404\n```\n\n上面會把 8080 的 HTTP 流量導到 `domain.example.com`，使用剛剛創建的 Tunnel。\n\n最後一行一定要有一個可以接受所有流量的 Service，不然服務會不能啟動，這裡全部往 404 導。\n\n## Run Tunnel\n\n最後一步，加上 config 的參數，把剛剛的 yml 檔喂給 Cloudflare，就可以啟動通道了：\n\n```sh\ncloudflared tunnel --config test.yml run\n```\n\n## 後記\n\n這篇只介紹了如何創建一個 Http 的 Tunnel，如果要開其他的 TCP Port，還需要其他的設定，而且在 Client 端也會需要安裝 Cloudflared，所以我留到下一篇在介紹。\n\n## Reference\n\n- [Cloudflare for Teams documentation](https://developers.cloudflare.com/cloudflare-one/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/Cloudflare Tunnel.md","excerpt":"Cloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。 我覺得目前的缺點就是網路上相關的資料比較少，遇到問題很難找到資料參考，因為他其實主要是 Cloudflare 的一項零信任服務，目標…","frontmatter":{"title":"Cloudflare Tunnel","date":"2021-08-13T07:17:39.000Z","draft":false,"tags":["cloudflare","tunnel","teams","cloudflare-tunnel"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/00e85cf1-4c03-45ea-004c-f61e6216d400/public","description":"Cloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。"}}},{"node":{"id":"acc7e2df-e6e5-5c7a-aa49-4f23527be703","html":"<p>簡單記錄我所認知的 A320 的一些程序。</p>\n<!--more-->\n<blockquote>\n<p>注意這些都不是標準程序，只是我自己亂理解的，也省去蠻多步驟，基本上就是能起讓飛機動起來，標準程序肯定是更複雜的。</p>\n</blockquote>\n<h2>啟動飛機前檢查</h2>\n<p><del>模擬器中跳過還是可以飛</del></p>\n<ol>\n<li>Engine Master 1 and 2 Switch -> OFF\n<ul>\n<li>主引擎 1, 2 都關閉</li>\n</ul>\n</li>\n<li>Engine Mode Selector -> NORM\n<ul>\n<li>引擎模式在 Normal 位置</li>\n</ul>\n</li>\n<li>Weather Radar -> OFF\n<ul>\n<li>關閉氣象雷達</li>\n</ul>\n</li>\n<li>Landing Gear -> Down\n<ul>\n<li>機輪放下</li>\n</ul>\n</li>\n<li>Wipers -> Both OFF\n<ul>\n<li>兩個雨刷都關閉</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/7e29f7e1-bf0b-44d4-7589-29286ed81b00/large\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/ca5109ba-4baf-40e3-850e-ee4002882c00/large\" alt=\"img\"></p>\n<h2>啟動飛機</h2>\n<ol>\n<li>Batt 1 and 2 -> ON</li>\n<li>EXT Power -> ON\n<ul>\n<li>啟動外部電源</li>\n<li>這時應該可以看到所有儀表亮起</li>\n</ul>\n</li>\n<li>APU Fire Test\n<ul>\n<li>APU 滅火測試</li>\n</ul>\n</li>\n<li>APU Master and wait 3 sec -> ON\n<ul>\n<li>打開 APU 主開關，並等待 3 秒</li>\n</ul>\n</li>\n<li>APU START -> ON\n<ul>\n<li>發動 APU</li>\n</ul>\n</li>\n<li>Wait for APU START -> Green \"AVAIL\"\n<ul>\n<li>等 APU 發動完成</li>\n</ul>\n</li>\n<li>APU BLEED -> ON\n<ul>\n<li>開啟 APU 供給氣壓</li>\n</ul>\n</li>\n<li>EXT Power -> OFF\n<ul>\n<li>移除外部電源</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/bcc428a6-c065-4bc3-0d19-ad204b860700/large\" alt=\"img\"></p>\n<h2>Overhead Panel 上方儀表</h2>\n<p>基本上，由左至右，由下而上的檢查</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4aa17d2f-419c-40e6-09f8-e31ca2833a00/large\" alt=\"img\"></p>\n<h3>左邊那排</h3>\n<ol>\n<li>CREW SUPPLY -> ON\n<ul>\n<li>打開組員氧氣供給</li>\n</ul>\n</li>\n<li>ADIRS 1, 2, 3 -> NAV\n<ul>\n<li>開啟三個慣性導航，需等待 6-7 分鐘校準</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b25f2e34-5ff9-4534-4fc2-927961a5ce00/large\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/16fb299e-1847-4767-8093-aa0d058cd400/large\" alt=\"img\"></p>\n<h3>中間那排</h3>\n<ol>\n<li>NAV &#x26; LOGO Light -> ON</li>\n<li>OVHD INTEG LT -> AS REQ.</li>\n<li>DOME LT -> AS REQ.</li>\n<li>ANN LT TEST</li>\n<li>EMER EXIT LT -> ARM</li>\n<li>SEAT BELTS -> ON</li>\n<li>NO SMOKING -> ON</li>\n<li>ALL PUMP -> ON</li>\n<li>ENG 1 FIRE TEST</li>\n<li>ENG 2 FIRE TEST</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/e5f05a70-bc36-4bc3-fff2-61f413e6b900/large\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/613ca5d3-3519-4c5d-cb82-4f9371e1d500/large\" alt=\"img\"></p>\n<h3>右邊那排</h3>\n<p>基本上不用動</p>\n<h2>MCDU 飛行電腦</h2>\n<p>在等待導航校準時，來設定飛行電腦。設定飛行電腦有一個口訣：</p>\n<blockquote>\n<p>D > I > F > S > R > I > P > P</p>\n</blockquote>\n<ul>\n<li>DATA</li>\n<li>INIT A</li>\n<li>F-PLN</li>\n<li>SEC PLAN</li>\n<li>RAD NAV</li>\n<li>INIT B</li>\n<li>PREF</li>\n<li>PROG</li>\n</ul>\n<blockquote>\n<p>飛行電腦設定蠻複雜的，本文就先跳過詳細步驟，專注在冷操到起飛。</p>\n</blockquote>\n<h2>後推 and 啟動引擎前檢查</h2>\n<p>記得等 IRS 校準完後再後推。</p>\n<ol>\n<li>申請後推</li>\n<li>BECON Light -> ON\n<ul>\n<li>啟動 BECAON 燈</li>\n</ul>\n</li>\n<li>Trust Levers -> IDLE\n<ul>\n<li>確定推力桿在 IDLE</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f3d16c92-7e28-4b76-c106-458211015c00/public\" alt=\"img\"></p>\n<p>在 MSFS 的 FlyByWire 中可以用旁邊的 FlyPad 申請後推。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/71f815a8-11e0-4d0b-38a5-2de486a4e000/public\" alt=\"img\"></p>\n<h2>啟動引擎</h2>\n<ol>\n<li>ENG MODE selector -> IGN/START\n<ul>\n<li>把 ENG MODE selector 轉到右邊的啟動引擎模式</li>\n</ul>\n</li>\n<li>ENGINE 2 START -> ON\n<ul>\n<li>啟動右邊的 2 號引擎</li>\n<li>我也不知道為甚麼都是先啟動 2 號引擎</li>\n<li>等待發動完成後再發動 1 號引擎</li>\n<li>發動時應監控引擎數據，19% N1, 68% N2, 520°C EGT, 290 kg/h FF，等待 2 號引擎 AVAIL 字樣出現</li>\n</ul>\n</li>\n<li>ENGINE 1 START -> ON\n<ul>\n<li>啟動左邊的 1 號引擎，重複第 2 步直到 1 號引擎 AVAIL 字樣出現</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/1e82de0e-18d0-402e-b279-780fe5f6b800/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d164d67d-9afb-4bd6-2eb9-835d7fe24300/public\" alt=\"img\"></p>\n<h2>啟動引擎後</h2>\n<ol>\n<li>ENG MODE selectgor -> NORM\n<ul>\n<li>引擎模式轉回中間 NORM</li>\n</ul>\n</li>\n<li>APU Bleed -> OFF\n<ul>\n<li>關閉 APU 供氣</li>\n</ul>\n</li>\n<li>APU MASTER -> OFF\n<ul>\n<li>關閉 APU</li>\n</ul>\n</li>\n<li>FLAPS lever -> SET TAKEOFF POSITION\n<ul>\n<li>放出襟翼到起飛需要的位置</li>\n</ul>\n</li>\n</ol>\n<h2>滑行 Taxi</h2>\n<ol>\n<li>NOSE Light -> Taxi\n<ul>\n<li>開啟滑行燈</li>\n</ul>\n</li>\n<li>RWY TURN OFF -> ON\n<ul>\n<li>開啟脫離跑道燈 (轉彎燈)</li>\n</ul>\n</li>\n<li>PARK BRK -> OFF\n<ul>\n<li>關閉手煞車</li>\n</ul>\n</li>\n<li>AUTO BRK MAX -> ON\n<ul>\n<li>開啟最大自動煞車</li>\n</ul>\n</li>\n</ol>\n<h2>起飛</h2>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://www.youtube.com/channel/UCDKKDx4mNVI7vONL1vqTx7g\">教官我想飛</a></li>\n<li><a href=\"https://www.youtube.com/channel/UCOHc8xzWD25Nn-snDBJUMGQ\">機師阿楷</a></li>\n<li><a href=\"https://github.com/flybywiresim/manuals/blob/master/pdf/A32NX%20Documentation/FBW%20A32NX%20Checklist.pdf\">FBW A32NX Checklist.pdf</a></li>\n<li><a href=\"https://github.com/flybywiresim/manuals/blob/master/pdf/A32NX%20Documentation/FBW%20A32NX%20SOP.pdf\">FBW A32NX SOP.pdf</a></li>\n</ul>","rawMarkdownBody":"\n簡單記錄我所認知的 A320 的一些程序。\n\n<!--more-->\n\n> 注意這些都不是標準程序，只是我自己亂理解的，也省去蠻多步驟，基本上就是能起讓飛機動起來，標準程序肯定是更複雜的。\n\n## 啟動飛機前檢查\n\n~~模擬器中跳過還是可以飛~~\n\n1. Engine Master 1 and 2 Switch -> OFF\n   - 主引擎 1, 2 都關閉\n2. Engine Mode Selector -> NORM\n   - 引擎模式在 Normal 位置\n3. Weather Radar -> OFF\n   - 關閉氣象雷達\n4. Landing Gear -> Down\n   - 機輪放下\n5. Wipers -> Both OFF\n   - 兩個雨刷都關閉\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/7e29f7e1-bf0b-44d4-7589-29286ed81b00/large)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/ca5109ba-4baf-40e3-850e-ee4002882c00/large)\n\n## 啟動飛機\n\n1. Batt 1 and 2 -> ON\n2. EXT Power -> ON\n   - 啟動外部電源\n   - 這時應該可以看到所有儀表亮起\n3. APU Fire Test\n   - APU 滅火測試\n4. APU Master and wait 3 sec -> ON\n   - 打開 APU 主開關，並等待 3 秒\n5. APU START -> ON\n   - 發動 APU\n6. Wait for APU START -> Green \"AVAIL\"\n   - 等 APU 發動完成\n7. APU BLEED -> ON\n   - 開啟 APU 供給氣壓\n8. EXT Power -> OFF\n   - 移除外部電源\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/bcc428a6-c065-4bc3-0d19-ad204b860700/large)\n\n## Overhead Panel 上方儀表\n\n基本上，由左至右，由下而上的檢查\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4aa17d2f-419c-40e6-09f8-e31ca2833a00/large)\n\n### 左邊那排\n\n1. CREW SUPPLY -> ON\n   - 打開組員氧氣供給\n2. ADIRS 1, 2, 3 -> NAV\n   - 開啟三個慣性導航，需等待 6-7 分鐘校準\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b25f2e34-5ff9-4534-4fc2-927961a5ce00/large)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/16fb299e-1847-4767-8093-aa0d058cd400/large)\n\n### 中間那排\n\n1. NAV & LOGO Light -> ON\n2. OVHD INTEG LT -> AS REQ.\n3. DOME LT -> AS REQ.\n4. ANN LT TEST\n5. EMER EXIT LT -> ARM\n6. SEAT BELTS -> ON\n7. NO SMOKING -> ON\n8. ALL PUMP -> ON\n9. ENG 1 FIRE TEST\n10. ENG 2 FIRE TEST\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/e5f05a70-bc36-4bc3-fff2-61f413e6b900/large)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/613ca5d3-3519-4c5d-cb82-4f9371e1d500/large)\n\n### 右邊那排\n\n基本上不用動\n\n## MCDU 飛行電腦\n\n在等待導航校準時，來設定飛行電腦。設定飛行電腦有一個口訣：\n\n> D > I > F > S > R > I > P > P\n\n- DATA\n- INIT A\n- F-PLN\n- SEC PLAN\n- RAD NAV\n- INIT B\n- PREF\n- PROG\n\n> 飛行電腦設定蠻複雜的，本文就先跳過詳細步驟，專注在冷操到起飛。\n\n## 後推 and 啟動引擎前檢查\n\n記得等 IRS 校準完後再後推。\n\n1. 申請後推\n2. BECON Light -> ON\n   - 啟動 BECAON 燈\n3. Trust Levers -> IDLE\n   - 確定推力桿在 IDLE\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f3d16c92-7e28-4b76-c106-458211015c00/public)\n\n在 MSFS 的 FlyByWire 中可以用旁邊的 FlyPad 申請後推。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/71f815a8-11e0-4d0b-38a5-2de486a4e000/public)\n\n## 啟動引擎\n\n1. ENG MODE selector -> IGN/START\n   - 把 ENG MODE selector 轉到右邊的啟動引擎模式\n2. ENGINE 2 START -> ON\n   - 啟動右邊的 2 號引擎\n   - 我也不知道為甚麼都是先啟動 2 號引擎\n   - 等待發動完成後再發動 1 號引擎\n   - 發動時應監控引擎數據，19% N1, 68% N2, 520°C EGT, 290 kg/h FF，等待 2 號引擎 AVAIL 字樣出現\n3. ENGINE 1 START -> ON\n   - 啟動左邊的 1 號引擎，重複第 2 步直到 1 號引擎 AVAIL 字樣出現\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/1e82de0e-18d0-402e-b279-780fe5f6b800/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d164d67d-9afb-4bd6-2eb9-835d7fe24300/public)\n\n## 啟動引擎後\n\n1. ENG MODE selectgor -> NORM\n   - 引擎模式轉回中間 NORM\n2. APU Bleed -> OFF\n   - 關閉 APU 供氣\n3. APU MASTER -> OFF\n   - 關閉 APU\n4. FLAPS lever -> SET TAKEOFF POSITION\n   - 放出襟翼到起飛需要的位置\n\n## 滑行 Taxi\n\n1. NOSE Light -> Taxi\n   - 開啟滑行燈\n2. RWY TURN OFF -> ON\n   - 開啟脫離跑道燈 (轉彎燈)\n3. PARK BRK -> OFF\n   - 關閉手煞車\n4. AUTO BRK MAX -> ON\n   - 開啟最大自動煞車\n\n## 起飛\n\n## Reference\n\n- [教官我想飛](https://www.youtube.com/channel/UCDKKDx4mNVI7vONL1vqTx7g)\n- [機師阿楷](https://www.youtube.com/channel/UCOHc8xzWD25Nn-snDBJUMGQ)\n- [FBW A32NX Checklist.pdf](https://github.com/flybywiresim/manuals/blob/master/pdf/A32NX%20Documentation/FBW%20A32NX%20Checklist.pdf)\n- [FBW A32NX SOP.pdf](https://github.com/flybywiresim/manuals/blob/master/pdf/A32NX%20Documentation/FBW%20A32NX%20SOP.pdf)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Flight/A320 Note.md","excerpt":"簡單記錄我所認知的 A320 的一些程序。 注意這些都不是標準程序，只是我自己亂理解的，也省去蠻多步驟，基本上就是能起讓飛機動起來，標準程序肯定是更複雜的。 啟動飛機前檢查 模擬器中跳過還是可以飛 Engine Master 1 and 2 Switch -> OFF 主引擎 1, 2 都關閉 Engine Mode Selector -> NORM 引擎模式在 Normal 位置 Weathe…","frontmatter":{"title":"A320neo 冷艙到飛行","date":"2021-07-21T14:08:20.000Z","draft":false,"tags":["a320neo","airbus","msfs"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/06a43a08-dc77-48eb-9f4a-f47a29566900/public","description":"簡單記錄我所認知的 A320 的一些程序。"}}},{"node":{"id":"e1f2136a-0c65-5dce-bf47-743229e64ad2","html":"<p>打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210716235146.png\" alt=\"img\"></p>\n<!--more-->\n<p>我們今天主要會用到下面的幾樣技術：</p>\n<ol>\n<li><a href=\"https://zsh.sourceforge.io/\">zsh</a></li>\n<li><a href=\"https://github.com/romkatv/powerlevel10k\">powerlevel10K</a></li>\n<li><a href=\"https://zimfw.sh/#install\">zim</a></li>\n<li><a href=\"https://www.nerdfonts.com/\">Nerd Fonts</a></li>\n</ol>\n<p>看到這幾項技術其實可以自己先去研究一下，看看這些技術是不是自己需要的，以免亂裝一堆東西，搞的自己 Terminal 亂七八糟無法復原。另外，Windows 應該是無法安裝的，至少我自己是沒辦法，不過 WSL 倒是可以玩成這樣，畢竟就是 Linux 麻。</p>\n<p>很多人會推薦在 mac 上安裝 iTerm，我自己是沒裝，我覺得 mac 內建的 Terminal 足夠好用，沒必要安裝其他 Terminal。</p>\n<h2>Font</h2>\n<p>好看的第一步就是有好看的字體，<a href=\"https://www.nerdfonts.com/\">Nerd Fonts</a> 這個專案把一些開發者常用的字體，加上一些在 Terminal 中會用到的一些 icon 和 symbol，常見的 <code class=\"language-text\">Hack</code>、<code class=\"language-text\">Jetbrains Mono</code> 都有在這個專案裡。到 Nerd Fonts 的官網可以下載到這些字體，注意不要到字體們原本的管網下載，要到 Nerd Fonts 下載包含特殊符號的字體。</p>\n<p><img src=\"https://www.nerdfonts.com/assets/img/sankey-glyphs-combined-diagram.png\" alt=\"img\"></p>\n<p>下載安裝好字體後，記得到自己的 Terminal 中變更字體，選擇有包含 Nerd 的字體，以免等等字體都無法顯示，這部分教學我懶得寫，所以附一張圖：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717112205.png\" alt=\"img\"></p>\n<h2>zsh</h2>\n<p>zsh 可以說是 bash 的進階版，提供客製化自己在 Terminal 中想要的主題和功能。要安裝 zsh 通常各個系統都不一樣，自己上網根據系統安裝即可。安裝完成後也要將預設 shell 改成 zsh。</p>\n<p>ubuntu:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token function\">zsh</span>\nchsh -s /bin/zsh <span class=\"token variable\">$USRR</span></code></pre></div>\n<h2>powerlevel10k</h2>\n<p>powerlevel10k 是一個 zsh 主題，提供可高客製化的主題和客製化嚮導，可以簡單地就把 Terminal 變成自己喜歡的模樣，也是本文最重要的部分。powerlevel10k 提供許多安裝方法，可以透過 oh-my-zsh，也可以用腳本安裝，我是認為用腳本安裝就好，可以不用用到 oh-my-zsh，因我們之後會提到 zim 就提供許多可以替代 oh-my-zsh 的功能。</p>\n<p>用腳本安裝 powerlevel10k：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> clone --depth<span class=\"token operator\">=</span><span class=\"token number\">1</span> https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'source ~/powerlevel10k/powerlevel10k.zsh-theme'</span> <span class=\"token operator\">>></span>~/.zshrc</code></pre></div>\n<p>安裝方式可能會因版本變動而不一樣，建議還是到官方 Github 上看一下安裝方式。</p>\n<p>安裝完成後第一次進到 Terminal 會遇到一個安裝嚮導，可以根據自己喜好設定主題樣式。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717214526.gif\" alt=\"img\"></p>\n<p>完成到這裡，Terminal 應該已經變得美美的，如果遇到亂碼，可能是字型沒有調整好。</p>\n<p>powerlevel10k 會提供一個 <code class=\"language-text\">p10k</code> 的命令，可以用於重新啟動嚮導：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717174430.png\" alt=\"img\"></p>\n<h2>Zim</h2>\n<p>全名 Zsh IMproved FrameWork，主要是提供一些方便的 zsh plugin，像是自動補全、語法高亮等，如果是希望好看，不用好用，Zim 就可以不用安裝。</p>\n<p>安裝 Zim 也很簡單，只要 Run 下面的腳本就可以：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> -fsSL https://raw.githubusercontent.com/zimfw/install/master/install.zsh <span class=\"token operator\">|</span> <span class=\"token function\">zsh</span></code></pre></div>\n<p>到這就算是全部完成，如果有發現更多好用的 Terminal 工具，記得分享給我。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://zsh.sourceforge.io/\">zsh</a></li>\n<li><a href=\"https://github.com/romkatv/powerlevel10k\">powerlevel10K</a></li>\n<li><a href=\"https://zimfw.sh/#install\">zim</a></li>\n<li><a href=\"https://www.nerdfonts.com/\">Nerd Fonts</a></li>\n</ul>","rawMarkdownBody":"\n打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210716235146.png)\n\n<!--more-->\n\n我們今天主要會用到下面的幾樣技術：\n\n1. [zsh](https://zsh.sourceforge.io/)\n2. [powerlevel10K](https://github.com/romkatv/powerlevel10k)\n3. [zim](https://zimfw.sh/#install)\n4. [Nerd Fonts](https://www.nerdfonts.com/)\n\n看到這幾項技術其實可以自己先去研究一下，看看這些技術是不是自己需要的，以免亂裝一堆東西，搞的自己 Terminal 亂七八糟無法復原。另外，Windows 應該是無法安裝的，至少我自己是沒辦法，不過 WSL 倒是可以玩成這樣，畢竟就是 Linux 麻。\n\n很多人會推薦在 mac 上安裝 iTerm，我自己是沒裝，我覺得 mac 內建的 Terminal 足夠好用，沒必要安裝其他 Terminal。\n\n## Font\n\n好看的第一步就是有好看的字體，[Nerd Fonts](https://www.nerdfonts.com/) 這個專案把一些開發者常用的字體，加上一些在 Terminal 中會用到的一些 icon 和 symbol，常見的 `Hack`、`Jetbrains Mono` 都有在這個專案裡。到 Nerd Fonts 的官網可以下載到這些字體，注意不要到字體們原本的管網下載，要到 Nerd Fonts 下載包含特殊符號的字體。\n\n![img](https://www.nerdfonts.com/assets/img/sankey-glyphs-combined-diagram.png)\n\n下載安裝好字體後，記得到自己的 Terminal 中變更字體，選擇有包含 Nerd 的字體，以免等等字體都無法顯示，這部分教學我懶得寫，所以附一張圖：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717112205.png)\n\n## zsh\n\nzsh 可以說是 bash 的進階版，提供客製化自己在 Terminal 中想要的主題和功能。要安裝 zsh 通常各個系統都不一樣，自己上網根據系統安裝即可。安裝完成後也要將預設 shell 改成 zsh。\n\nubuntu:\n\n```bash\nsudo apt install zsh\nchsh -s /bin/zsh $USRR\n```\n\n## powerlevel10k\n\npowerlevel10k 是一個 zsh 主題，提供可高客製化的主題和客製化嚮導，可以簡單地就把 Terminal 變成自己喜歡的模樣，也是本文最重要的部分。powerlevel10k 提供許多安裝方法，可以透過 oh-my-zsh，也可以用腳本安裝，我是認為用腳本安裝就好，可以不用用到 oh-my-zsh，因我們之後會提到 zim 就提供許多可以替代 oh-my-zsh 的功能。\n\n用腳本安裝 powerlevel10k：\n\n```bash\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k\necho 'source ~/powerlevel10k/powerlevel10k.zsh-theme' >>~/.zshrc\n```\n\n安裝方式可能會因版本變動而不一樣，建議還是到官方 Github 上看一下安裝方式。\n\n安裝完成後第一次進到 Terminal 會遇到一個安裝嚮導，可以根據自己喜好設定主題樣式。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717214526.gif)\n\n完成到這裡，Terminal 應該已經變得美美的，如果遇到亂碼，可能是字型沒有調整好。\n\npowerlevel10k 會提供一個 `p10k` 的命令，可以用於重新啟動嚮導：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717174430.png)\n\n## Zim\n\n全名 Zsh IMproved FrameWork，主要是提供一些方便的 zsh plugin，像是自動補全、語法高亮等，如果是希望好看，不用好用，Zim 就可以不用安裝。\n\n安裝 Zim 也很簡單，只要 Run 下面的腳本就可以：\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/zimfw/install/master/install.zsh | zsh\n```\n\n到這就算是全部完成，如果有發現更多好用的 Terminal 工具，記得分享給我。\n\n## Reference\n\n- [zsh](https://zsh.sourceforge.io/)\n- [powerlevel10K](https://github.com/romkatv/powerlevel10k)\n- [zim](https://zimfw.sh/#install)\n- [Nerd Fonts](https://www.nerdfonts.com/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Linux/Beautiful Terminal.md","excerpt":"打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。 img 我們今天主要會用到下面的幾樣技術： zsh powerlevel10K zim Nerd Fonts 看到這幾項技術其實可以自己先去研究一下，看看這些技術是不是自己需要的，以免亂裝一堆東西，搞的自己 Terminal 亂七八糟無法復原。另外，W…","frontmatter":{"title":"Beautiful Terminal","date":"2021-07-16T15:43:07.000Z","draft":false,"tags":["terminl","zsh","zim","powerlevel","powerlevel10k","nerd-font","ubuntu","mac"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/939d8b79-aeab-465b-8bc7-fcf3cc4def00/public","description":"打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。"}}},{"node":{"id":"01f03396-06dd-573b-95a5-793a7fd2bc95","html":"<p>Markdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。</p>\n<!--more-->\n<p>我們來看看 <a href=\"https://github.com/apple/swift\">Swift</a> 的官網，可以發現 <code class=\"language-text\">[README.md](http://readme.md)</code> 這個檔案就是由 Markdown 編寫，Github 也會自動將這個檔案渲染在網頁下方。到這裡可以發現，在 Github 上的所有開源專案的文件，幾乎都是由 Markdown 編寫。</p>\n<h2>哲學</h2>\n<p>引述自 <a href=\"https://markdown.tw\">https://markdown.tw</a></p>\n<blockquote>\n<p>Markdown 的目標是實現「易讀易寫」。<br>\n不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 語法受到一些既有 text-to-HTML 格式的影響，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，然而最大靈感來源其實是純文字的電子郵件格式。<br>\n因此 Markdown 的語法全由標點符號所組成，並經過嚴謹慎選，是為了讓它們看起來就像所要表達的意思。像是在文字兩旁加上星號，看起來就像<em>強調</em>。Markdown 的清單看起來，嗯，就是清單。假如你有使用過電子郵件，區塊引言看起來就真的像是引用一段文字。</p>\n</blockquote>\n<h2>Tools</h2>\n<p>Q: 那要用什麼來寫呢？</p>\n<p>因為 Markdown 基本上也是純文字檔案，所以只要是文字編輯器都可以編輯，你要用 txt 來寫也是個不錯的方法 ❤️。</p>\n<h3>VSCode</h3>\n<p>目前最推薦的就是工程師的好夥伴 <code class=\"language-text\">VSCode</code> ，VSCode 在寫 Markdown 時，有提供即時渲染，可以快速的看到結果，而且 VSCode 應該在各位工程師的電腦裡都應該有安裝才對。</p>\n<h3>HackMD</h3>\n<p>HackMD 是一個在網頁中的 Markdown 編輯器，可以方便地在網頁中編輯和看到編寫的結果，HackMD 最厲害的功能是可以將 Markdown 轉換成簡報，用 Markdown 取代 PowerPoint？這夠帥吧！</p>\n<h3>MarkText</h3>\n<p>這是一個在 <a href=\"https://github.com/marktext/marktext\">Github</a> 上的開源專案，可以所寫所得，方便使用，但我還是比較推薦新手使用上面兩項工具，因為這東西真的太方便了，有點沒有在寫 Markdown 的感覺。</p>\n<h3>Microsoft Word</h3>\n<p>推薦指數：⭐⭐⭐⭐⭐</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=X34ZmkeZDos\">[YouTube] Why Microsoft Word is the best IDE for programming</a></li>\n</ul>\n<h2>Markdown 語法</h2>\n<!-- markdownlint-disable MD025 -->\n<h1>大標題</h1>\n<!-- markdownlint-enable MD025 -->\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token title important\"><span class=\"token punctuation\">#</span> 大標題</span></code></pre></div>\n<hr>\n<h2>次標題</h2>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h2</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token title important\"><span class=\"token punctuation\">##</span> 次標題</span></code></pre></div>\n<hr>\n<h3>次次標題</h3>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h3</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token title important\"><span class=\"token punctuation\">###</span> 次次標題</span></code></pre></div>\n<hr>\n<h2>內文</h2>\n<p>內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文</p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>\n\n內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文</code></pre></div>\n<hr>\n<h2>斜體 粗體</h2>\n<p>內文內文內文<em>斜體</em>內文內文內文內文內文內文<br>\n內文內文內文<strong>粗體</strong>內文內文內文內文內文內文</p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">內文內文內文<span class=\"token italic\"><span class=\"token punctuation\">*</span><span class=\"token content\">斜體</span><span class=\"token punctuation\">*</span></span>內文內文內文內文內文內文  \n內文內文內文<span class=\"token bold\"><span class=\"token punctuation\">**</span><span class=\"token content\">粗體</span><span class=\"token punctuation\">**</span></span>內文內文內文內文內文內文</code></pre></div>\n<hr>\n<h2>有序清單</h2>\n<ol>\n<li>有序清單 1</li>\n<li>有序清單 2</li>\n<li>有序清單 3</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ol</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token list punctuation\">1.</span> 有序清單 1\n<span class=\"token list punctuation\">2.</span> 有序清單 2\n<span class=\"token list punctuation\">3.</span> 有序清單 3</code></pre></div>\n<hr>\n<h2>無序清單</h2>\n<ul>\n<li>無序清單 1</li>\n<li>無序清單 2</li>\n<li>無序清單 3</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token list punctuation\">-</span> 無序清單 1\n<span class=\"token list punctuation\">-</span> 無序清單 2\n<span class=\"token list punctuation\">-</span> 無序清單 3\n\n<span class=\"token list punctuation\">*</span> 無序清單 1\n<span class=\"token list punctuation\">*</span> 無序清單 2\n<span class=\"token list punctuation\">*</span> 無序清單 3\n\n<span class=\"token list punctuation\">-</span> 無序清單 1\n<span class=\"token list punctuation\">-</span> 無序清單 2\n<span class=\"token list punctuation\">-</span> 無序清單 3</code></pre></div>\n<hr>\n<h2>程式碼區塊</h2>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hi 程式碼區塊\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717220425.png\" alt=\"img\"></p>\n<hr>\n<h2>標記程式碼</h2>\n<p>inline <code class=\"language-text\">code</code></p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">inline <span class=\"token code-snippet code keyword\">`code`</span></code></pre></div>\n<hr>\n<h2>超連結</h2>\n<p><a href=\"https://google.com\">Google 首頁</a></p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token url\">[<span class=\"token content\">Google 首頁</span>](<span class=\"token url\">https://google.com</span>)</span></code></pre></div>\n<hr>\n<h2>圖片連結</h2>\n<p><img src=\"https://www.google.com.tw/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" alt=\"img\"></p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">![](https://www.google.com.tw/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png)</code></pre></div>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://markdown.tw/\">Markdown 文件</a></li>\n</ul>","rawMarkdownBody":"\nMarkdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。\n\n<!--more-->\n\n我們來看看 [Swift](https://github.com/apple/swift) 的官網，可以發現 `[README.md](http://readme.md)` 這個檔案就是由 Markdown 編寫，Github 也會自動將這個檔案渲染在網頁下方。到這裡可以發現，在 Github 上的所有開源專案的文件，幾乎都是由 Markdown 編寫。\n\n## 哲學\n\n引述自 [https://markdown.tw](https://markdown.tw)\n\n> Markdown 的目標是實現「易讀易寫」。  \n> 不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 語法受到一些既有 text-to-HTML 格式的影響，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，然而最大靈感來源其實是純文字的電子郵件格式。  \n> 因此 Markdown 的語法全由標點符號所組成，並經過嚴謹慎選，是為了讓它們看起來就像所要表達的意思。像是在文字兩旁加上星號，看起來就像*強調*。Markdown 的清單看起來，嗯，就是清單。假如你有使用過電子郵件，區塊引言看起來就真的像是引用一段文字。\n\n## Tools\n\nQ: 那要用什麼來寫呢？\n\n因為 Markdown 基本上也是純文字檔案，所以只要是文字編輯器都可以編輯，你要用 txt 來寫也是個不錯的方法 ❤️。\n\n### VSCode\n\n目前最推薦的就是工程師的好夥伴 `VSCode` ，VSCode 在寫 Markdown 時，有提供即時渲染，可以快速的看到結果，而且 VSCode 應該在各位工程師的電腦裡都應該有安裝才對。\n\n### HackMD\n\nHackMD 是一個在網頁中的 Markdown 編輯器，可以方便地在網頁中編輯和看到編寫的結果，HackMD 最厲害的功能是可以將 Markdown 轉換成簡報，用 Markdown 取代 PowerPoint？這夠帥吧！\n\n### MarkText\n\n這是一個在 [Github](https://github.com/marktext/marktext) 上的開源專案，可以所寫所得，方便使用，但我還是比較推薦新手使用上面兩項工具，因為這東西真的太方便了，有點沒有在寫 Markdown 的感覺。\n\n### Microsoft Word\n\n推薦指數：⭐⭐⭐⭐⭐\n\n- [[YouTube] Why Microsoft Word is the best IDE for programming](https://www.youtube.com/watch?v=X34ZmkeZDos)\n\n## Markdown 語法\n\n<!-- markdownlint-disable MD025 -->\n\n# 大標題\n\n<!-- markdownlint-enable MD025 -->\n\n```md\n<h1>\n\n# 大標題\n```\n\n---\n\n## 次標題\n\n```md\n<h2>\n\n## 次標題\n```\n\n---\n\n### 次次標題\n\n```md\n<h3>\n\n### 次次標題\n```\n\n---\n\n## 內文\n\n內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文\n\n```md\n<p>\n\n內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文\n```\n\n---\n\n## 斜體 粗體\n\n內文內文內文*斜體*內文內文內文內文內文內文  \n內文內文內文**粗體**內文內文內文內文內文內文\n\n```md\n內文內文內文*斜體*內文內文內文內文內文內文  \n內文內文內文**粗體**內文內文內文內文內文內文\n```\n\n---\n\n## 有序清單\n\n1. 有序清單 1\n2. 有序清單 2\n3. 有序清單 3\n\n```md\n<ol>\n\n1. 有序清單 1\n2. 有序清單 2\n3. 有序清單 3\n```\n\n---\n\n## 無序清單\n\n- 無序清單 1\n- 無序清單 2\n- 無序清單 3\n\n```md\n<ul>\n\n- 無序清單 1\n- 無序清單 2\n- 無序清單 3\n\n* 無序清單 1\n* 無序清單 2\n* 無序清單 3\n\n- 無序清單 1\n- 無序清單 2\n- 無序清單 3\n```\n\n---\n\n## 程式碼區塊\n\n```c\nprintf(\"Hi 程式碼區塊\");\n```\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717220425.png)\n\n---\n\n## 標記程式碼\n\ninline `code`\n\n```md\ninline `code`\n```\n\n---\n\n## 超連結\n\n[Google 首頁](https://google.com)\n\n```md\n[Google 首頁](https://google.com)\n```\n\n---\n\n## 圖片連結\n\n![img](https://www.google.com.tw/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png)\n\n```md\n![](https://www.google.com.tw/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png)\n```\n\n## Reference\n\n- [Markdown 文件](https://markdown.tw/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/markdown.md","excerpt":"Markdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。 我們來看看 Swift 的官網，可以發現  這個檔案就是由 Markdown 編寫，Github 也會自動將這個檔案渲染在網頁下方。到這裡可以發現，在 Github 上的…","frontmatter":{"title":"Markdown","date":"2021-07-05T09:05:38.000Z","draft":false,"tags":["markdown"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0ecfde1e-521f-4e7c-ab46-30357d4e5e00/public","description":"Markdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。"}}},{"node":{"id":"12cf7dd4-2218-52e9-b731-11bbf415cd30","html":"<p>frp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。</p>\n<!--more-->\n<p>frp 會需要一台 Server，Server 需要公網 ip，如果沒有公網 ip，可以使用 aws 或 gcp 買一個簡單的 VPS。</p>\n<h2>安裝</h2>\n<p>網路上有許多一鍵安裝的到腳本，但我們不使用那些，有興趣的自己上網搜尋。</p>\n<p>到官方 <a href=\"https://github.com/fatedier/frp/releases\">Release</a> 下載最新版，根據系統選擇，解壓後會看到 <code class=\"language-text\">frps</code> 、<code class=\"language-text\">frpc</code> 各有三個檔案，跟 <code class=\"language-text\">frps</code> 有關的就是 Server 端用的，<code class=\"language-text\">frpc</code> 的就是 Client 端用的。如果是 Server 端，就可以將 <code class=\"language-text\">frpc</code> 的檔案都刪除。</p>\n<h2>Server 端設定</h2>\n<p>在 Server 上打開設定文件 <code class=\"language-text\">frps.ini</code> 可以看到預設就有如下的內容：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">bind_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span></code></pre></div>\n<p><code class=\"language-text\">common</code> 內綁定了 7000 port，這個 port 是讓 client 端連接用的，基本現在不用改設定就可以直接用。執行 <code class=\"language-text\">frps</code> 要用 <code class=\"language-text\">-c</code> 參數給定設定檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">./frps -c ./frps.ini</code></pre></div>\n<p>如果沒看到問題，基本上 Server 端就設定好了，其他功能晚點再介紹，我們先設定好 Client。</p>\n<h2>Client 端設定</h2>\n<p>Client 就是要發布服務伺服器，所以雖然叫做 Client 但本身應該也是一台提供服務的 Server。Client 就可以刪除有關 <code class=\"language-text\">frps</code> 相關的檔案。</p>\n<p>一樣先打開設定檔 <code class=\"language-text\">frpc.ini</code>，也會有如下預設內容：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">server_addr</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">server_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span>\n\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">ssh</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">type</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">tcp</span>\n<span class=\"token key attr-name\">local_ip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">local_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">22</span>\n<span class=\"token key attr-name\">remote_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">6000</span></code></pre></div>\n<p>Client 端的設定檔就不能直接用，需要修改 Server ip 才行，更改 <code class=\"language-text\">server_addr</code> 為剛剛 Server 端的 ip 地址或是 Domain 都可以。</p>\n<p>下方方的 ssh 區塊設一個將 Client 端的 ssh 22 port 公開到 Server 端的 6000 port 的範本，如果有其他的 port 要開放，用相同的思維更改即可。像是如過要加 Minecraft 25565 port 也到 Server 端的 25565 port，就可以新增一個區塊：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">server_addr</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">example.com</span>\n<span class=\"token key attr-name\">server_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span>\n\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">ssh</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">type</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">tcp</span>\n<span class=\"token key attr-name\">local_ip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">local_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">22</span>\n<span class=\"token key attr-name\">remote_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">6000</span>\n\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">minecraft</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">type</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">tcp</span>\n<span class=\"token key attr-name\">local_ip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">local_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">25565</span>\n<span class=\"token key attr-name\">remote_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">25565</span></code></pre></div>\n<p>到目前為止應該就可以用 Server 端的 ip 連接到 Client 端了，如果連不上，可能要檢查一下 Server 端防火牆的設定，這邊就不贅述。</p>\n<h2>Token 認證</h2>\n<p>不知道大家有沒有發現，基本上只要知道你 Server ip 或 domain 的人都可以新增自己的 port，要避免這樣的狀況，我們可以使用 token。使用方法也很簡單，只要在 Server 和 Client 端的 <code class=\"language-text\">[common]</code> 都加上相同的 token 參數，就可以進行簡單的認證。</p>\n<p>Server 端範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">bind_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span>\n<span class=\"token key attr-name\">token</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7Jc2ZCvVzHu</span></code></pre></div>\n<p>Client 端範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">server_addr</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">example.com</span>\n<span class=\"token key attr-name\">server_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span>\n<span class=\"token key attr-name\">token</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7Jc2ZCvVzHu</span>\n\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">ssh</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">type</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">tcp</span>\n<span class=\"token key attr-name\">local_ip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">local_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">22</span>\n<span class=\"token key attr-name\">remote_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">6000</span></code></pre></div>\n<h2>Refrence</h2>\n<p><a href=\"https://github.com/fatedier/frp\">GitHub</a></p>\n<p><a href=\"https://gofrp.org/docs/\">中文文檔</a></p>","rawMarkdownBody":"\nfrp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。\n\n<!--more-->\n\nfrp 會需要一台 Server，Server 需要公網 ip，如果沒有公網 ip，可以使用 aws 或 gcp 買一個簡單的 VPS。\n\n## 安裝\n\n網路上有許多一鍵安裝的到腳本，但我們不使用那些，有興趣的自己上網搜尋。\n\n到官方 [Release](https://github.com/fatedier/frp/releases) 下載最新版，根據系統選擇，解壓後會看到 `frps` 、`frpc` 各有三個檔案，跟 `frps` 有關的就是 Server 端用的，`frpc` 的就是 Client 端用的。如果是 Server 端，就可以將 `frpc` 的檔案都刪除。\n\n## Server 端設定\n\n在 Server 上打開設定文件 `frps.ini` 可以看到預設就有如下的內容：\n\n```ini\n[common]\nbind_port = 7000\n```\n\n`common` 內綁定了 7000 port，這個 port 是讓 client 端連接用的，基本現在不用改設定就可以直接用。執行 `frps` 要用 `-c` 參數給定設定檔案：\n\n```shell\n./frps -c ./frps.ini\n```\n\n如果沒看到問題，基本上 Server 端就設定好了，其他功能晚點再介紹，我們先設定好 Client。\n\n## Client 端設定\n\nClient 就是要發布服務伺服器，所以雖然叫做 Client 但本身應該也是一台提供服務的 Server。Client 就可以刪除有關 `frps` 相關的檔案。\n\n一樣先打開設定檔 `frpc.ini`，也會有如下預設內容：\n\n```ini\n[common]\nserver_addr = 127.0.0.1\nserver_port = 7000\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n```\n\nClient 端的設定檔就不能直接用，需要修改 Server ip 才行，更改 `server_addr` 為剛剛 Server 端的 ip 地址或是 Domain 都可以。\n\n下方方的 ssh 區塊設一個將 Client 端的 ssh 22 port 公開到 Server 端的 6000 port 的範本，如果有其他的 port 要開放，用相同的思維更改即可。像是如過要加 Minecraft 25565 port 也到 Server 端的 25565 port，就可以新增一個區塊：\n\n```ini\n[common]\nserver_addr = example.com\nserver_port = 7000\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n\n[minecraft]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 25565\nremote_port = 25565\n```\n\n到目前為止應該就可以用 Server 端的 ip 連接到 Client 端了，如果連不上，可能要檢查一下 Server 端防火牆的設定，這邊就不贅述。\n\n## Token 認證\n\n不知道大家有沒有發現，基本上只要知道你 Server ip 或 domain 的人都可以新增自己的 port，要避免這樣的狀況，我們可以使用 token。使用方法也很簡單，只要在 Server 和 Client 端的 `[common]` 都加上相同的 token 參數，就可以進行簡單的認證。\n\nServer 端範例：\n\n```ini\n[common]\nbind_port = 7000\ntoken = 7Jc2ZCvVzHu\n```\n\nClient 端範例：\n\n```ini\n[common]\nserver_addr = example.com\nserver_port = 7000\ntoken = 7Jc2ZCvVzHu\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n```\n\n## Refrence\n\n[GitHub](https://github.com/fatedier/frp)\n\n[中文文檔](https://gofrp.org/docs/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Linux/frp.md","excerpt":"frp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。 frp 會需要一台 Server，Server 需要公網 ip，如果沒有公網 ip，可以使用 aws 或 gcp 買一個簡單的 VPS。 安…","frontmatter":{"title":"Frp","date":"2021-06-20T13:48:33.000Z","draft":false,"tags":["frp","linux"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/34046c81-cb6e-40a5-7b3a-8623c613f400/public","description":"frp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。"}}},{"node":{"id":"0c0b9771-fcc3-543e-a234-33d6b9792da1","html":"<p>我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。</p>\n<!--more-->\n<p>本篇使用 Kotlin 和 OKHttp，來嘗試撰寫一個應用程式，來協助發布 Markdwon 至 Medium，專案原始碼在 <a href=\"https://github.com/TonyPepeBear/MediumMarkdownUploader\">Github</a> 上。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/2021/02/10-21-47-48-%E6%88%AA%E5%9C%96%202021-02-10%20%E4%B8%8B%E5%8D%889.47.40.png\" alt=\"截圖 2021-02-10 下午9.47.40.png\"></p>\n<h2>申請 token</h2>\n<p>Medium API 的 <a href=\"https://github.com/Medium/medium-api-docs\">官方文件</a> 在這，可以用 <code class=\"language-text\">HTTP POST</code> 的方式來發布文章。要使用 API 第一件事就是要有 <code class=\"language-text\">token</code>，要申請 <code class=\"language-text\">token</code> 不用錢，官方目前好像也沒有使用限制，到 <a href=\"https://medium.com/me/settings\">用戶設定</a> 的頁面，找到 <code class=\"language-text\">Integration tokens</code> 的地方，申請一個 token，說明隨便輸入就好。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/2021/02/10-01-42-07-%E6%88%AA%E5%9C%96%202021-02-10%20%E4%B8%8A%E5%8D%881.42.04.png\" alt=\"img\"></p>\n<h2>UserID</h2>\n<p>根據官方文檔，想要發布文章，需要 UserID，我找了好久才發現 UserID 不是 Name 也不是 UserName，也是要先用 API 的方式取得。</p>\n<p>用 Http GET 的方式可以取得 token 主人資料，使用方式如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\">GET https://api.medium.com/v1/me</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">GET</span> <span class=\"token request-target url\">/v1/me</span> <span class=\"token http-version property\">HTTP/1.1</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">api.medium.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Authorization</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Bearer 181d415f34379af07b2c11d144dfbe35d</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept-Charset</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">utf-8</span></span></code></pre></div>\n<p><code class=\"language-text\">token</code> 是放在 Post 的 header，的 <code class=\"language-text\">Authorization:Bearer</code> 後方，下方是用 Kotlin 和 OKHttp 實作的方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> request <span class=\"token operator\">=</span> Request<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"https://api.medium.com/v1/me\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Authorization\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Bearer </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">token</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> response <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>範例的 Response 如下，可以拿到用 UserID、UserName 等資料：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"data\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"5303d74c64f66366f00cb9b2a94f3251bf5\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"username\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"majelbstoat\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Jamie Talbot\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://medium.com/@majelbstoat\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"imageUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://images.medium.com/0*fkfQiTzT7TlUGGyI.png\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>根據上方的 Json，可以產生 <code class=\"language-text\">Kotlin Data Class</code> 來放取回的資料：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">MediumApiMe</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> `<span class=\"token keyword\">data</span>`<span class=\"token operator\">:</span> MediumMeData\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">MediumMeData</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> id<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> imageUrl<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> url<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> username<span class=\"token operator\">:</span> String\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>取回的 Response 用 <code class=\"language-text\">gson</code> 轉換 json 到 Data Class，最後寫成一個完整的方法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">getUserData</span><span class=\"token punctuation\">(</span>token<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MediumApiMe <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> request <span class=\"token operator\">=</span> Request<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"https://api.medium.com/v1/me\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Authorization\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Bearer </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">token</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> response <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>code <span class=\"token operator\">!=</span> <span class=\"token number\">200</span> <span class=\"token operator\">||</span> response<span class=\"token punctuation\">.</span>body <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token function\">RuntimeException</span><span class=\"token punctuation\">(</span>\n            <span class=\"token string-literal singleline\"><span class=\"token string\">\"Can not get User info. Maybe token is wrong.\"</span></span> <span class=\"token operator\">+</span>\n            <span class=\"token punctuation\">{</span>response<span class=\"token punctuation\">.</span>body<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">byteStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">readLines</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">val</span> text <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>body<span class=\"token operator\">!!</span><span class=\"token punctuation\">.</span><span class=\"token function\">byteStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">readText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> gson<span class=\"token punctuation\">.</span><span class=\"token function\">fromJson</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">,</span> MediumApiMe<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上方的程式碼有判斷 Response Code 是否為 200，若不是 200 代表取得資料沒有成功，就拋出 Exception。</p>\n<h2>Post 文章</h2>\n<p>取得 UserID 後就可以用 Http Post 的方式向 Medium 發布文章。下方的 authorId 就是剛剛用 Http Get 的方式取得的 UserID。</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\">POST https://api.medium.com/v1/users/{{authorId}}/posts</code></pre></div>\n<p>下面是 Post 的範例，<code class=\"language-text\">token</code> 一樣是放在 <code class=\"language-text\">header</code> 裡。官方的範例是用 html 來發布文章，我們只要將 <code class=\"language-text\">contentFormat</code> 改成 markdown 就可以達成目的。</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">POST</span> <span class=\"token request-target url\">/v1/users/5303d74c64f66366f00cb9b2a94f3251bf5/posts</span> <span class=\"token http-version property\">HTTP/1.1</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">api.medium.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Authorization</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Bearer 181d415f34379af07b2c11d144dfbe35d</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept-Charset</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">utf-8</span></span>\n<span class=\"token application-json\">\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Liverpool FC\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"contentFormat\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"html\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"content\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"&lt;h1>Liverpool FC&lt;/h1>&lt;p>You’ll never walk alone.&lt;/p>\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"canonicalUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://jamietalbot.com/posts/liverpool-fc\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"tags\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"football\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"sport\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Liverpool\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"publishStatus\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"public\"</span>\n<span class=\"token punctuation\">}</span></span></code></pre></div>\n<p>根據上面 Post 的 Json 範例，我們可以產生出如下的 Kotlin Data Class，我順便寫了一個快速轉成 Json 的方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">MediumApiPost</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> title<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> content<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> contentFormat<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> tags<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> publishStatus<span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"draft\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token comment\">//預設是草稿</span>\n    <span class=\"token keyword\">val</span> canonicalUrl<span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"\"</span></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">toJson</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> String <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> gson<span class=\"token punctuation\">.</span><span class=\"token function\">toJson</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>產生出 Data Class 就可以嘗試 Post 看看，是否會發布文章，直接利用剛剛寫好的 <code class=\"language-text\">getUserData</code> 拿到 UserID，之後在 Post：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> userID <span class=\"token operator\">=</span> <span class=\"token function\">getUserData</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">val</span> medimuApiPost <span class=\"token operator\">=</span>\n    <span class=\"token function\">MdieumApiPost</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Title\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"# Title\\nHi\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"markdown\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> request <span class=\"token operator\">=</span> Request<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"https://api.medium.com/v1/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">userID</span></span><span class=\"token string\">/posts\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span>mediumApiPost<span class=\"token punctuation\">.</span><span class=\"token function\">toJson</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toRequestBody</span><span class=\"token punctuation\">(</span>contentType <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"application/json\"</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">toMediaType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Authorization\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Bearer </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">token</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> response <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>如果發布成功，可以拿到 Response Code 201，其他的都代表發布失敗。</p>\n<p>寫成完整的發布方法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">newPost</span><span class=\"token punctuation\">(</span>token<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span> mediumApiPost<span class=\"token operator\">:</span> MediumApiPost<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> String <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> userID <span class=\"token operator\">=</span> <span class=\"token function\">getUserData</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>id\n\n    <span class=\"token keyword\">val</span> request <span class=\"token operator\">=</span> Request<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"https://api.medium.com/v1/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">userID</span></span><span class=\"token string\">/posts\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span>mediumApiPost<span class=\"token punctuation\">.</span><span class=\"token function\">toJson</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toRequestBody</span><span class=\"token punctuation\">(</span>contentType <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"application/json\"</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">toMediaType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Authorization\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Bearer </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">token</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> response <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>code <span class=\"token operator\">!=</span> <span class=\"token number\">201</span> <span class=\"token operator\">||</span> response<span class=\"token punctuation\">.</span>body <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token function\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Something Wrong. </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token expression\">response<span class=\"token punctuation\">.</span>body<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">byteStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">readText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">val</span> text <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>body<span class=\"token operator\">!!</span><span class=\"token punctuation\">.</span><span class=\"token function\">byteStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">readText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">var</span> json <span class=\"token operator\">=</span> gson<span class=\"token punctuation\">.</span><span class=\"token function\">fromJson</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">,</span> MediumNewPostResponse<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> json<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>url\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的方法會直接回傳發布成功的 URL，失敗則會直接拋出 Exception。</p>\n<h2>GUI</h2>\n<p>寫好方法後，最後再用 <code class=\"language-text\">TornadoFX</code> 寫 GUI，這邊就不講述 GUI 的部分，有興趣可以自己到 GitHub 上看專案的原始碼。</p>\n<h2>程式碼區塊</h2>\n<p>因為 Medium 目前並不支援程式碼高亮，傳上去的程式碼區塊都會變成黑底的，目前我有想到的解法是在 Post 上去之前，就先將程式碼區塊都換成 GitHub Gist，但這就需要更複雜的方式解決問題了，有興趣的人可以自己試試看。</p>\n<h2>Reference</h2>\n<p><a href=\"https://github.com/Medium/medium-api-docs\">Medium’s API Documentation</a></p>","rawMarkdownBody":"\n我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。\n\n<!--more-->\n\n本篇使用 Kotlin 和 OKHttp，來嘗試撰寫一個應用程式，來協助發布 Markdwon 至 Medium，專案原始碼在 [Github](https://github.com/TonyPepeBear/MediumMarkdownUploader) 上。\n\n![截圖 2021-02-10 下午9.47.40.png](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/2021/02/10-21-47-48-%E6%88%AA%E5%9C%96%202021-02-10%20%E4%B8%8B%E5%8D%889.47.40.png)\n\n## 申請 token\n\nMedium API 的 [官方文件](https://github.com/Medium/medium-api-docs) 在這，可以用 `HTTP POST` 的方式來發布文章。要使用 API 第一件事就是要有 `token`，要申請 `token` 不用錢，官方目前好像也沒有使用限制，到 [用戶設定](https://medium.com/me/settings) 的頁面，找到 `Integration tokens` 的地方，申請一個 token，說明隨便輸入就好。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/2021/02/10-01-42-07-%E6%88%AA%E5%9C%96%202021-02-10%20%E4%B8%8A%E5%8D%881.42.04.png)\n\n## UserID\n\n根據官方文檔，想要發布文章，需要 UserID，我找了好久才發現 UserID 不是 Name 也不是 UserName，也是要先用 API 的方式取得。\n\n用 Http GET 的方式可以取得 token 主人資料，使用方式如下：\n\n```http\nGET https://api.medium.com/v1/me\n```\n\n```http\nGET /v1/me HTTP/1.1\nHost: api.medium.com\nAuthorization: Bearer 181d415f34379af07b2c11d144dfbe35d\nContent-Type: application/json\nAccept: application/json\nAccept-Charset: utf-8\n```\n\n`token` 是放在 Post 的 header，的 `Authorization:Bearer` 後方，下方是用 Kotlin 和 OKHttp 實作的方法：\n\n```kotlin\nval request = Request.Builder()\n    .url(\"https://api.medium.com/v1/me\")\n    .get()\n    .addHeader(\"Authorization\", \"Bearer $token\")\n    .build()\nval response = client.newCall(request).execute()\n```\n\n範例的 Response 如下，可以拿到用 UserID、UserName 等資料：\n\n```json\n{\n  \"data\": {\n    \"id\": \"5303d74c64f66366f00cb9b2a94f3251bf5\",\n    \"username\": \"majelbstoat\",\n    \"name\": \"Jamie Talbot\",\n    \"url\": \"https://medium.com/@majelbstoat\",\n    \"imageUrl\": \"https://images.medium.com/0*fkfQiTzT7TlUGGyI.png\"\n  }\n}\n```\n\n根據上方的 Json，可以產生 `Kotlin Data Class` 來放取回的資料：\n\n```kotlin\ndata class MediumApiMe(\n    val `data`: MediumMeData\n)\n\ndata class MediumMeData(\n    val id: String,\n    val imageUrl: String,\n    val name: String,\n    val url: String,\n    val username: String\n)\n```\n\n取回的 Response 用 `gson` 轉換 json 到 Data Class，最後寫成一個完整的方法如下：\n\n```kotlin\nfun getUserData(token: String): MediumApiMe {\n    val request = Request.Builder()\n        .url(\"https://api.medium.com/v1/me\")\n        .get()\n        .addHeader(\"Authorization\", \"Bearer $token\")\n        .build()\n    val response = client.newCall(request).execute()\n    if (response.code != 200 || response.body == null)\n        throw RuntimeException(\n            \"Can not get User info. Maybe token is wrong.\" +\n            {response.body?.byteStream()?.reader()?.readLines()}\n        )\n\n    val text = response.body!!.byteStream()\n        .reader()\n        .readText()\n    return gson.fromJson(text, MediumApiMe::class.java)\n}\n```\n\n上方的程式碼有判斷 Response Code 是否為 200，若不是 200 代表取得資料沒有成功，就拋出 Exception。\n\n## Post 文章\n\n取得 UserID 後就可以用 Http Post 的方式向 Medium 發布文章。下方的 authorId 就是剛剛用 Http Get 的方式取得的 UserID。\n\n```http\nPOST https://api.medium.com/v1/users/{{authorId}}/posts\n```\n\n下面是 Post 的範例，`token` 一樣是放在 `header` 裡。官方的範例是用 html 來發布文章，我們只要將 `contentFormat` 改成 markdown 就可以達成目的。\n\n```http\nPOST /v1/users/5303d74c64f66366f00cb9b2a94f3251bf5/posts HTTP/1.1\nHost: api.medium.com\nAuthorization: Bearer 181d415f34379af07b2c11d144dfbe35d\nContent-Type: application/json\nAccept: application/json\nAccept-Charset: utf-8\n\n{\n  \"title\": \"Liverpool FC\",\n  \"contentFormat\": \"html\",\n  \"content\": \"<h1>Liverpool FC</h1><p>You’ll never walk alone.</p>\",\n  \"canonicalUrl\": \"http://jamietalbot.com/posts/liverpool-fc\",\n  \"tags\": [\"football\", \"sport\", \"Liverpool\"],\n  \"publishStatus\": \"public\"\n}\n```\n\n根據上面 Post 的 Json 範例，我們可以產生出如下的 Kotlin Data Class，我順便寫了一個快速轉成 Json 的方法：\n\n```kotlin\ndata class MediumApiPost(\n    val title: String,\n    val content: String,\n    val contentFormat: String,\n    val tags: List<String> = listOf(),\n    val publishStatus: String = \"draft\", //預設是草稿\n    val canonicalUrl: String = \"\",\n) {\n    fun toJson(): String {\n        return gson.toJson(this)\n    }\n}\n```\n\n產生出 Data Class 就可以嘗試 Post 看看，是否會發布文章，直接利用剛剛寫好的 `getUserData` 拿到 UserID，之後在 Post：\n\n```kotlin\nval userID = getUserData(token).data.id\nval medimuApiPost =\n    MdieumApiPost(\"Title\", \"# Title\\nHi\", \"markdown\")\nval request = Request.Builder()\n    .url(\"https://api.medium.com/v1/users/$userID/posts\")\n    .post(mediumApiPost.toJson().toRequestBody(contentType = \"application/json\".toMediaType()))\n    .addHeader(\"Authorization\", \"Bearer $token\")\n    .build()\nval response = client.newCall(request).execute()\n```\n\n如果發布成功，可以拿到 Response Code 201，其他的都代表發布失敗。\n\n寫成完整的發布方法如下：\n\n```kotlin\nfun newPost(token: String, mediumApiPost: MediumApiPost): String {\n    val userID = getUserData(token).data.id\n\n    val request = Request.Builder()\n        .url(\"https://api.medium.com/v1/users/$userID/posts\")\n        .post(mediumApiPost.toJson().toRequestBody(contentType = \"application/json\".toMediaType()))\n        .addHeader(\"Authorization\", \"Bearer $token\")\n        .build()\n    val response = client.newCall(request).execute()\n\n    if (response.code != 201 || response.body == null)\n        throw RuntimeException(\"Something Wrong. ${response.body?.byteStream()?.reader()?.readText()}\")\n\n    val text = response.body!!.byteStream().reader().readText()\n    println(text)\n\n    var json = gson.fromJson(text, MediumNewPostResponse::class.java)\n\n    return json.data.url\n}\n```\n\n上面的方法會直接回傳發布成功的 URL，失敗則會直接拋出 Exception。\n\n## GUI\n\n寫好方法後，最後再用 `TornadoFX` 寫 GUI，這邊就不講述 GUI 的部分，有興趣可以自己到 GitHub 上看專案的原始碼。\n\n## 程式碼區塊\n\n因為 Medium 目前並不支援程式碼高亮，傳上去的程式碼區塊都會變成黑底的，目前我有想到的解法是在 Post 上去之前，就先將程式碼區塊都換成 GitHub Gist，但這就需要更複雜的方式解決問題了，有興趣的人可以自己試試看。\n\n## Reference\n\n[Medium’s API Documentation](https://github.com/Medium/medium-api-docs)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Kotlin/medium-api.md","excerpt":"我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。 本篇…","frontmatter":{"title":"發布 Markdown 至 Medium","date":"2021-06-15T18:35:56.000Z","draft":false,"tags":["medium","markdown","kotlin","tornadofx"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/98587dc3-5d4e-446a-7d98-b0b1ad36d500/public","description":"我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。"}}},{"node":{"id":"dc1d7172-8fd3-59ca-b4a9-f5085ecbd89e","html":"<p>其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩，要先經過不少設定。而且在官方的文件中，其實是教你怎麼建置專案，執行 Debug，如果只是寫一點簡單的小程式根本用不到那麼複雜的設定，所以本文是我目前發現比較容易在 VSCode 中執行 C 和 C++ 的方法。</p>\n<!--more-->\n<h2>gcc g++</h2>\n<p>在了解如何設定 vscode 前，我們先來了解一下基本的 gcc、g++ 指令，這是一個用來編譯 C 程式碼最快的方法，gcc 就是 C 的編譯器，g++ 則是 C++ 的。這裡不會解說如何安裝，在 Windows 下可以使用 MinGW，macOS 則是只要在 Terminal 下 gcc 指令，就會自動問你要不要安裝。</p>\n<p>下面的範例會編譯 <code class=\"language-text\">main.cpp</code> 的 C++ 檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">g++ main.cpp</code></pre></div>\n<p>執行上面的指令後，會產生名為 <code class=\"language-text\">a.out</code> 的檔案，因為我們沒有指定輸出檔名，所以預設就是 <code class=\"language-text\">a.out</code>，在 Windows 上則為 <code class=\"language-text\">a.exe</code> 的執行檔。如果要執行產生的執行檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">./a.out\n./a.exe <span class=\"token comment\"># On Windows</span></code></pre></div>\n<p>要指定輸出檔名也很簡單，加個 <code class=\"language-text\">-o</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">g++ -o main.out main.cpp</code></pre></div>\n<p>這樣就可以將 <code class=\"language-text\">main.cpp</code> 編譯成 <code class=\"language-text\">main.out</code> 的執行檔。</p>\n<p>上面這些不會也沒關係，但我還是建議了解一下，因為等一下要安裝的模組，只是幫你完成這些步驟，如果完全不了解指令的功能，發生問題可能自己會沒辦法解決。</p>\n<h2>設定 VSCode</h2>\n<p>第一步就是先在 VSCode 中安裝 <strong>C/C++</strong>，和 <strong>Code Runner</strong>，兩個延伸模組。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608014749.png\" alt=\"img\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608021309.png\" alt=\"img\"></p>\n<p>安裝完成後，應該就會看到右上角出現了一個執行的按鈕，可以按按看程式會不會執行。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608021808.png\" alt=\"img\"></p>\n<p>如果找不到按鈕，或是想要停下程式，也可以用按下 <code class=\"language-text\">f1</code> 的方式叫出 VSCode 的指令輸入窗，輸入 <code class=\"language-text\">Run Code</code> 或是 <code class=\"language-text\">Stop Code Run</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608022037.png\" alt=\"img\"></p>\n<h2>Run In Terminal</h2>\n<p>現在可能會發先一個問題，這種執行模式是沒有辦法接收鍵盤輸入的，如果想要接收鍵盤輸入，我們要把執行模式改成在 Terminal 中。所以我們要開啟 VSCode 的 <code class=\"language-text\">settings.json</code> 設定檔，來更改設定，一樣是用 <code class=\"language-text\">f1</code> 叫出命令輸入區，並尋找 <code class=\"language-text\">open settings json</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608024052.png\" alt=\"img\"></p>\n<p>打開後在裡面新增一行：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token property\">\"code-runner.runInTerminal\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span></code></pre></div>\n<p>如果前方有其他設定值，記得在前面的設定值的最後面加個逗號 <code class=\"language-text\">,</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608024259.png\" alt=\"img\"></p>\n<p>現在就可以方便的在 VSCode 中寫 C，和方便的執行他們。</p>","rawMarkdownBody":"\n其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩，要先經過不少設定。而且在官方的文件中，其實是教你怎麼建置專案，執行 Debug，如果只是寫一點簡單的小程式根本用不到那麼複雜的設定，所以本文是我目前發現比較容易在 VSCode 中執行 C 和 C++ 的方法。\n\n<!--more-->\n\n## gcc g++\n\n在了解如何設定 vscode 前，我們先來了解一下基本的 gcc、g++ 指令，這是一個用來編譯 C 程式碼最快的方法，gcc 就是 C 的編譯器，g++ 則是 C++ 的。這裡不會解說如何安裝，在 Windows 下可以使用 MinGW，macOS 則是只要在 Terminal 下 gcc 指令，就會自動問你要不要安裝。\n\n下面的範例會編譯 `main.cpp` 的 C++ 檔案：\n\n```bash\ng++ main.cpp\n```\n\n執行上面的指令後，會產生名為 `a.out` 的檔案，因為我們沒有指定輸出檔名，所以預設就是 `a.out`，在 Windows 上則為 `a.exe` 的執行檔。如果要執行產生的執行檔案：\n\n```bash\n./a.out\n./a.exe # On Windows\n```\n\n要指定輸出檔名也很簡單，加個 `-o`：\n\n```bash\ng++ -o main.out main.cpp\n```\n\n這樣就可以將 `main.cpp` 編譯成 `main.out` 的執行檔。\n\n上面這些不會也沒關係，但我還是建議了解一下，因為等一下要安裝的模組，只是幫你完成這些步驟，如果完全不了解指令的功能，發生問題可能自己會沒辦法解決。\n\n## 設定 VSCode\n\n第一步就是先在 VSCode 中安裝 **C/C++**，和 **Code Runner**，兩個延伸模組。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608014749.png)\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608021309.png)\n\n安裝完成後，應該就會看到右上角出現了一個執行的按鈕，可以按按看程式會不會執行。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608021808.png)\n\n如果找不到按鈕，或是想要停下程式，也可以用按下 `f1` 的方式叫出 VSCode 的指令輸入窗，輸入 `Run Code` 或是 `Stop Code Run`。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608022037.png)\n\n## Run In Terminal\n\n現在可能會發先一個問題，這種執行模式是沒有辦法接收鍵盤輸入的，如果想要接收鍵盤輸入，我們要把執行模式改成在 Terminal 中。所以我們要開啟 VSCode 的 `settings.json` 設定檔，來更改設定，一樣是用 `f1` 叫出命令輸入區，並尋找 `open settings json`：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608024052.png)\n\n打開後在裡面新增一行：\n\n```json\n\"code-runner.runInTerminal\": true\n```\n\n如果前方有其他設定值，記得在前面的設定值的最後面加個逗號 `,`：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608024259.png)\n\n現在就可以方便的在 VSCode 中寫 C，和方便的執行他們。\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/VSCode/vscode-clang.md","excerpt":"其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩，要先經過不少設定。而且在官方的文件中，其實是教你怎麼建置專案，執行 Debug，如果只是寫一點簡單的小程式根本用不到那麼複雜的設定，所以本文是我目前發現比較容易在 VSCode 中執行 C 和 C++ 的方法。 …","frontmatter":{"title":"用 VSCode 寫 C/C++","date":"2021-06-07T16:55:19.000Z","draft":false,"tags":["vscode","code","c","c++"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/48d8b9f1-209f-44ab-0f7b-92b5f082a500/public","description":"其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩。"}}},{"node":{"id":"870e064c-4e10-52cf-8ee4-7e88a63fa689","html":"<p>Github Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到 <code class=\"language-text\">gh-pages</code> 的 git 分支。</p>\n<!--more-->\n<p>Github Actions 也是容器化技術的一環，也是類似 Docker 容器的一種，如果對 Docker 還不熟悉，應該會對本文有點吃力，但也可以對完全不了解 Docker 的人，多一點對容器化技術的認識。</p>\n<h2>編寫 Workflows 檔案</h2>\n<p>Workflows 工作流檔案，就是在 CI/CD 中最重要的檔案，這個檔案寫下這個專案的工作流程，像是如何 Test、交付成品，都是寫在這的檔案裡，Github 會自動讀取所有工作留檔案和自動執行，所以只要寫好一次，基本上就一勞永逸，每次只需要 Push，Gihtub 就會按照腳本完成指定的工作。</p>\n<p>Github Actions 的 Worksflows 檔案都是放在專案跟目錄的 <code class=\"language-text\">/.github/workflows</code> 這個資料夾中，Github 會讀取這個資料夾中的 <code class=\"language-text\">*.yml</code> 檔案，並且自動執行他們。我們現在在這個目錄下新增一個叫做 <code class=\"language-text\">hugo-public.yml</code> 的檔案，檔名可以自訂沒關係，Github 不會關心檔名長怎樣，如果有多個檔案也每個都會分別執行。</p>\n<p>我們在現在 <code class=\"language-text\">/.github/workflows/hugo-public.yml</code> 的檔案中新增如下的腳本：</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> github pages\n\n<span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> master <span class=\"token comment\"># Set a branch to deploy</span>\n  <span class=\"token key atrule\">pull_request</span><span class=\"token punctuation\">:</span>\n\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span><span class=\"token number\">20.04</span>\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">submodules</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span> <span class=\"token comment\"># Fetch Hugo themes (true OR recursive)</span>\n          <span class=\"token key atrule\">fetch-depth</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token comment\"># Fetch all history for .GitInfo and .Lastmod</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Hugo\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>hugo@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">hugo-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"latest\"</span>\n          <span class=\"token key atrule\">extended</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> hugo <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>minify\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Deploy\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>gh<span class=\"token punctuation\">-</span>pages@v3\n        <span class=\"token key atrule\">if</span><span class=\"token punctuation\">:</span> github.ref == 'refs/heads/master'\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">github_token</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.ACCESS_TOKEN <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n          <span class=\"token key atrule\">publish_dir</span><span class=\"token punctuation\">:</span> ./public</code></pre></div>\n<p>下面我們分段來解釋上面腳本每行的意思。</p>\n<h2>Name</h2>\n<p>基本上就是這個腳本的名稱，可以隨意自訂不會影響結果。</p>\n<h2>On</h2>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> master <span class=\"token comment\"># Set a branch to deploy</span>\n  pull_request<span class=\"token punctuation\">:</span></code></pre></div>\n<p><code class=\"language-text\">on</code> 區段定義了這個腳本什麼時候會被執行，我們現在這個範例中，定義了這個腳本會在 <code class=\"language-text\">master</code> 這個分支被 push 的時候自動執行。Github 現在預設的分支名稱是 <code class=\"language-text\">main</code>，如果是 <code class=\"language-text\">main</code> 的人千萬要記得改，以免這個腳本永遠不會執行。</p>\n<h2>Jobs</h2>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 以下省略</span></code></pre></div>\n<p>jobs 是整個檔案中最核心的部分，可以分成許多不同的 Job，目前我們只有一個叫做 <code class=\"language-text\">deploy</code> 的 Job，這個名稱也是可以自訂的，這裡只是取叫 <code class=\"language-text\">deploy</code> 看不順眼可以自己換。如果還需要有其他工作，可以自己視情況增加。</p>\n<h3>Job</h3>\n<p>終於來到最核心的部分，deploy 任務中的第一行，就定義了這個任務要 Run 在哪個容器內，或是稱作哪個系統內。這邊是用 <code class=\"language-text\">ubuntu</code> 的 20.04，建議不要亂改，因為其他的 Linux 不一定可以完任務。</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span><span class=\"token number\">20.04</span>\n  <span class=\"token comment\">## 以下省略</span></code></pre></div>\n<h3>Steps</h3>\n<p>接下來就是分步驟執行命令，<code class=\"language-text\">uses</code> 是利用 Github 上別人已經寫好的 Actions 腳本來執行命令，像是第一個 <code class=\"language-text\">uses: actions/checkout@v2</code> 就是李用 Github 上別人已經寫好的 <code class=\"language-text\">git checkout</code> 命令來把專案 checkout 到容器中。</p>\n<p>第二個部分也是使用別人已經寫好的腳本，快速的安裝 Hugo 到容器內，用別人寫好的東西來完成工作，避免不必要的重複造輪子。</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n    <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">submodules</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>  <span class=\"token comment\"># Fetch Hugo themes (true OR recursive)</span>\n        <span class=\"token key atrule\">fetch-depth</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span>    <span class=\"token comment\"># Fetch all history for .GitInfo and .Lastmod</span>\n\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Hugo\n    <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>hugo@v2\n    <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">hugo-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'latest'</span>\n        <span class=\"token key atrule\">extended</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build\n    <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> hugo <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>minify\n\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Deploy\n    <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>gh<span class=\"token punctuation\">-</span>pages@v3\n    <span class=\"token key atrule\">if</span><span class=\"token punctuation\">:</span> github.ref == 'refs/heads/master'\n    <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">github_token</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.ACCESS_TOKEN <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n        <span class=\"token key atrule\">publish_dir</span><span class=\"token punctuation\">:</span> ./public</code></pre></div>\n<p>看到這裡也可以發現任務也是分很多步驟，第三部分的 Build 就是像是我們在本機目錄的產生方法一樣，直接輸入 <code class=\"language-text\">hugo</code> 命令產生靜態網頁。</p>\n<p>第四部分的 Deploy 就會比較複雜，這邊也是利用別人寫好用來發布 Github Pages 的任務，他會需要一個 Github Token，這個 Token 是要用來對 Repository 有 Push 的權限，雖然可以直接寫在腳本裡，但是就所有人都看得到你的 Token，那就會產生資安問題。所以 Github 提供 Secrets 的模式，可以把不方便直接寫在專案裡的機敏資料，放在 Github 上。</p>\n<p>所以我們現在會有兩件事要做：</p>\n<ol>\n<li>產生 Token</li>\n<li>把 Token 放到專案的 Secrets 中</li>\n</ol>\n<p>我們先來產生 Token，先到個人的設定頁面找到 Developer settings：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9cec1b4f-5bf6-4e41-9177-3cbe9ccfd400/large\" alt=\"img\"></p>\n<p>再到 Token 的頁面產生新的 Token：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/dfa652f6-b8b1-4df2-5b7f-ccdda2e8df00/large\" alt=\"img\"></p>\n<p>名稱可以自己隨意訂，Repo 的權限就全部打開，除了 Repo 以外的權限則都不需要。都確定後直接拉到最下面產生 Token：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/94de0480-f57a-4bef-b1e1-9ce3f75d2c00/large\" alt=\"img\"></p>\n<p>會得到一組新的 Token，請注意不要像我一樣 Show 出來給別人看，請妥善保存，而且 Github 也只會顯示這一次，以後想要看都看不到，只能產生新的 Token。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/13bcbfe0-5bbc-4292-5679-cd5d1dba9f00/large\" alt=\"img\"></p>\n<p>複製下 Token 後，我們到專案層級的設定，注意是<strong>專案</strong>的設定，不是個人設定：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d5b06f39-8b64-4f76-3f68-84d30fbc9a00/large\" alt=\"img\"></p>\n<p>找到 Secrets 並新增 Secrets：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/409789e1-87f4-4469-fcf4-032a27e05700/large\" alt=\"img\"></p>\n<p>名字取好後，填入剛剛拿到的 Token，注意名稱要和剛剛在腳本中寫的一樣：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8e7912d5-53fc-491a-a638-bee48f87be00/large\" alt=\"img\"></p>\n<p>都填完後就大功告成，基本上只要 Push 到 Github 上，應該就會自動觸發上面寫的工作，以後只要文章有新的變動，Push 上來就會自動更新網頁網頁到專案的 <code class=\"language-text\">gh-pages</code> 分之上。想要進一步看到 Pages 的設定，可以到專案下的 Pages 的設定下看看，也可以在這裡自訂 Domian。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/e1c327a2-2e73-45ff-7305-a8440010d600/large\" alt=\"img\"></p>","rawMarkdownBody":"\nGithub Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到 `gh-pages` 的 git 分支。\n\n<!--more-->\n\nGithub Actions 也是容器化技術的一環，也是類似 Docker 容器的一種，如果對 Docker 還不熟悉，應該會對本文有點吃力，但也可以對完全不了解 Docker 的人，多一點對容器化技術的認識。\n\n## 編寫 Workflows 檔案\n\nWorkflows 工作流檔案，就是在 CI/CD 中最重要的檔案，這個檔案寫下這個專案的工作流程，像是如何 Test、交付成品，都是寫在這的檔案裡，Github 會自動讀取所有工作留檔案和自動執行，所以只要寫好一次，基本上就一勞永逸，每次只需要 Push，Gihtub 就會按照腳本完成指定的工作。\n\nGithub Actions 的 Worksflows 檔案都是放在專案跟目錄的 `/.github/workflows` 這個資料夾中，Github 會讀取這個資料夾中的 `*.yml` 檔案，並且自動執行他們。我們現在在這個目錄下新增一個叫做 `hugo-public.yml` 的檔案，檔名可以自訂沒關係，Github 不會關心檔名長怎樣，如果有多個檔案也每個都會分別執行。\n\n我們在現在 `/.github/workflows/hugo-public.yml` 的檔案中新增如下的腳本：\n\n```yml\nname: github pages\n\non:\n  push:\n    branches:\n      - master # Set a branch to deploy\n  pull_request:\n\njobs:\n  deploy:\n    runs-on: ubuntu-20.04\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          submodules: true # Fetch Hugo themes (true OR recursive)\n          fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod\n\n      - name: Setup Hugo\n        uses: peaceiris/actions-hugo@v2\n        with:\n          hugo-version: \"latest\"\n          extended: true\n\n      - name: Build\n        run: hugo --minify\n\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        if: github.ref == 'refs/heads/master'\n        with:\n          github_token: ${{ secrets.ACCESS_TOKEN }}\n          publish_dir: ./public\n```\n\n下面我們分段來解釋上面腳本每行的意思。\n\n## Name\n\n基本上就是這個腳本的名稱，可以隨意自訂不會影響結果。\n\n## On\n\n```yml\non:\n  push:\n    branches:\n      - master # Set a branch to deploy\n  pull_request:\n```\n\n`on` 區段定義了這個腳本什麼時候會被執行，我們現在這個範例中，定義了這個腳本會在 `master` 這個分支被 push 的時候自動執行。Github 現在預設的分支名稱是 `main`，如果是 `main` 的人千萬要記得改，以免這個腳本永遠不會執行。\n\n## Jobs\n\n```yml\njobs:\n  deploy:\n    # 以下省略\n```\n\njobs 是整個檔案中最核心的部分，可以分成許多不同的 Job，目前我們只有一個叫做 `deploy` 的 Job，這個名稱也是可以自訂的，這裡只是取叫 `deploy` 看不順眼可以自己換。如果還需要有其他工作，可以自己視情況增加。\n\n### Job\n\n終於來到最核心的部分，deploy 任務中的第一行，就定義了這個任務要 Run 在哪個容器內，或是稱作哪個系統內。這邊是用 `ubuntu` 的 20.04，建議不要亂改，因為其他的 Linux 不一定可以完任務。\n\n```yml\ndeploy:\n  runs-on: ubuntu-20.04\n  ## 以下省略\n```\n\n### Steps\n\n接下來就是分步驟執行命令，`uses` 是利用 Github 上別人已經寫好的 Actions 腳本來執行命令，像是第一個 `uses: actions/checkout@v2` 就是李用 Github 上別人已經寫好的 `git checkout` 命令來把專案 checkout 到容器中。\n\n第二個部分也是使用別人已經寫好的腳本，快速的安裝 Hugo 到容器內，用別人寫好的東西來完成工作，避免不必要的重複造輪子。\n\n```yml\nsteps:\n    - uses: actions/checkout@v2\n    with:\n        submodules: true  # Fetch Hugo themes (true OR recursive)\n        fetch-depth: 0    # Fetch all history for .GitInfo and .Lastmod\n\n    - name: Setup Hugo\n    uses: peaceiris/actions-hugo@v2\n    with:\n        hugo-version: 'latest'\n        extended: true\n\n    - name: Build\n    run: hugo --minify\n\n    - name: Deploy\n    uses: peaceiris/actions-gh-pages@v3\n    if: github.ref == 'refs/heads/master'\n    with:\n        github_token: ${{ secrets.ACCESS_TOKEN }}\n        publish_dir: ./public\n```\n\n看到這裡也可以發現任務也是分很多步驟，第三部分的 Build 就是像是我們在本機目錄的產生方法一樣，直接輸入 `hugo` 命令產生靜態網頁。\n\n第四部分的 Deploy 就會比較複雜，這邊也是利用別人寫好用來發布 Github Pages 的任務，他會需要一個 Github Token，這個 Token 是要用來對 Repository 有 Push 的權限，雖然可以直接寫在腳本裡，但是就所有人都看得到你的 Token，那就會產生資安問題。所以 Github 提供 Secrets 的模式，可以把不方便直接寫在專案裡的機敏資料，放在 Github 上。\n\n所以我們現在會有兩件事要做：\n\n1. 產生 Token\n2. 把 Token 放到專案的 Secrets 中\n\n我們先來產生 Token，先到個人的設定頁面找到 Developer settings：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9cec1b4f-5bf6-4e41-9177-3cbe9ccfd400/large)\n\n再到 Token 的頁面產生新的 Token：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/dfa652f6-b8b1-4df2-5b7f-ccdda2e8df00/large)\n\n名稱可以自己隨意訂，Repo 的權限就全部打開，除了 Repo 以外的權限則都不需要。都確定後直接拉到最下面產生 Token：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/94de0480-f57a-4bef-b1e1-9ce3f75d2c00/large)\n\n會得到一組新的 Token，請注意不要像我一樣 Show 出來給別人看，請妥善保存，而且 Github 也只會顯示這一次，以後想要看都看不到，只能產生新的 Token。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/13bcbfe0-5bbc-4292-5679-cd5d1dba9f00/large)\n\n複製下 Token 後，我們到專案層級的設定，注意是**專案**的設定，不是個人設定：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d5b06f39-8b64-4f76-3f68-84d30fbc9a00/large)\n\n找到 Secrets 並新增 Secrets：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/409789e1-87f4-4469-fcf4-032a27e05700/large)\n\n名字取好後，填入剛剛拿到的 Token，注意名稱要和剛剛在腳本中寫的一樣：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8e7912d5-53fc-491a-a638-bee48f87be00/large)\n\n都填完後就大功告成，基本上只要 Push 到 Github 上，應該就會自動觸發上面寫的工作，以後只要文章有新的變動，Push 上來就會自動更新網頁網頁到專案的 `gh-pages` 分之上。想要進一步看到 Pages 的設定，可以到專案下的 Pages 的設定下看看，也可以在這裡自訂 Domian。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/e1c327a2-2e73-45ff-7305-a8440010d600/large)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Hugo/hugo-github-actions.md","excerpt":"Github Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到  …","frontmatter":{"title":"用 Github Actions 來發布 Hugo 靜態網頁","date":"2021-06-07T14:00:53.000Z","draft":false,"tags":["hugo","github","github-actions","web"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/3820056d-8496-4b29-efa0-716d71a45100/public","description":"Github Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到 gh-pages 的 git 分支。"}}}]}},"pageContext":{"limit":8,"skip":16,"numPages":4,"currentPage":3}},"staticQueryHashes":[]}