{"componentChunkName":"component---src-templates-article-template-tsx","path":"/posts/datastructure/binary-heap","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"913a51ce-b612-5f6a-a75c-b9317702c31f","html":"<p>資料結構中有一種很特別的樹，很接近一般的二元樹。</p>\n<h2>Heap Tree 基本特性</h2>\n<ul>\n<li>每個節點 (Node) 最多兩個子節點 (Child Node)</li>\n<li>每層由左到右新增資料</li>\n<li>Min Heap 的節點都比自己的子節點小，Max Heap 則相反</li>\n<li>承上可以發現，Min Heap 的根節點 (Root Node) 會是全部資料中最小的，Max Heap 則相反</li>\n</ul>\n<p>下面是一個 Min Heap 的範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">        1\n      /   \\\n    2      4\n   /  \\\n  8    5</code></pre></div>\n<h2>Array v.s. Heap</h2>\n<p>因為 Heap Tree 由右到左存放資料的特性，所以非常適合使用陣列來儲存資料。</p>\n<p>順便複習一下用陣列儲存二元樹的方式，從一開始跟從零開始都複習：</p>\n<p>陣列從 <code class=\"language-text\">1</code> 開始存：</p>\n<ul>\n<li>n 的父節點：n / 2</li>\n<li>n 的左節點：2 * n</li>\n<li>n 的右節點：2 * n + 1</li>\n</ul>\n<p>陣列從 <code class=\"language-text\">0</code> 開始存，我之後的範例程式以這個為準：</p>\n<ul>\n<li>n 的父節點：(n - 1) / 2</li>\n<li>n 的左節點：(2 * n) + 1</li>\n<li>n 的右節點：(2 * n) + 2</li>\n</ul>\n<p>可以看看下面的比較：</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">        1\n      /   \\\n    2      4\n   /  \\\n  8    5\n\nindex:  1  2  3  4  5\nindex:  0  1  2  3  4\n  arr: [1, 2, 4, 8, 5]</code></pre></div>\n<h2>新增節點</h2>\n<h2>刪除節點</h2>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://medium.com/@Kadai/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%A4%A7%E4%BE%BF%E7%95%B6-binary-heap-ec47ca7aebac\">資料結構大便當： Binary Heap</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/binary-heap/\">Binary Heap - GeeksforGeeks</a></li>\n</ul>","rawMarkdownBody":"\n資料結構中有一種很特別的樹，很接近一般的二元樹。\n\n## Heap Tree 基本特性\n\n- 每個節點 (Node) 最多兩個子節點 (Child Node)\n- 每層由左到右新增資料\n- Min Heap 的節點都比自己的子節點小，Max Heap 則相反\n- 承上可以發現，Min Heap 的根節點 (Root Node) 會是全部資料中最小的，Max Heap 則相反\n\n下面是一個 Min Heap 的範例：\n\n```txt\n        1\n      /   \\\n    2      4\n   /  \\\n  8    5\n```\n\n## Array v.s. Heap\n\n因為 Heap Tree 由右到左存放資料的特性，所以非常適合使用陣列來儲存資料。\n\n順便複習一下用陣列儲存二元樹的方式，從一開始跟從零開始都複習：\n\n陣列從 `1` 開始存：\n\n- n 的父節點：n / 2\n- n 的左節點：2 \\* n\n- n 的右節點：2 \\* n + 1\n\n陣列從 `0` 開始存，我之後的範例程式以這個為準：\n\n- n 的父節點：(n - 1) / 2\n- n 的左節點：(2 \\* n) + 1\n- n 的右節點：(2 \\* n) + 2\n\n可以看看下面的比較：\n\n```txt\n        1\n      /   \\\n    2      4\n   /  \\\n  8    5\n\nindex:  1  2  3  4  5\nindex:  0  1  2  3  4\n  arr: [1, 2, 4, 8, 5]\n```\n\n## 新增節點\n\n## 刪除節點\n\n## Reference\n\n- [資料結構大便當： Binary Heap](https://medium.com/@Kadai/資料結構大便當-binary-heap-ec47ca7aebac)\n- [Binary Heap - GeeksforGeeks](https://www.geeksforgeeks.org/binary-heap/)\n","excerpt":"資料結構中有一種很特別的樹，很接近一般的二元樹。 Heap Tree 基本特性 每個節點 (Node) 最多兩個子節點 (Child Node) 每層由左到右新增資料 Min Heap 的節點都比自己的子節點小，Max Heap 則相反 承上可以發現，Min Heap 的根節點 (Root Node) 會是全部資料中最小的，Max Heap 則相反 下面是一個 Min Heap 的範例： Arr…","frontmatter":{"title":"Binary Heap","date":"2021-11-24T08:28:51.000Z","draft":true,"tags":["binary-heap","binary","heap","data-structure","data","structure"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b8c0336c-3dab-407e-e3c5-0e9db8d93700/public","description":"資料結構中有一種很特別的樹，很接近一般的二元樹。"}}}]}},"pageContext":{"id":"913a51ce-b612-5f6a-a75c-b9317702c31f"}},"staticQueryHashes":[]}