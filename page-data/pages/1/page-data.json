{"componentChunkName":"component---src-templates-article-list-page-template-tsx","path":"/pages/1","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"59f97761-859b-55ad-aabc-9c01b316ded3","html":"<p>本文翻譯自 Medium。<a href=\"https://medium.flutterdevs.com/multithreading-in-flutter-aa07e2ae2971\">原文網址</a>，請在閱讀前先去幫原作者拍拍手。另外，我也有在原文中加入一些我自己的理解。</p>\n<p>Flutter 是由 Google 開發的跨平台框架，因其出色的用戶界面能力和動畫而引起了廣泛關注。如果我們遇到畫面卡住、動畫未按預期工作以及螢幕跳躍等問題，它的威力就會受到阻礙，進而導致整個用戶體驗變得很糟糕。通常，觸發這種現象的原因可能是同步訪問多個 API 請求、圖像處理、動畫或任何其他耗時操作。</p>\n<p>很多開發人員希望在他們的應用程式中解決此問題，以便讓程式不會出現這種情況。可以通過創建多個隔離線程 <code class=\"language-text\">Isolate</code>，這些線程具有自己的事件循環並與運行 Flutter 的主執行緒 (Main Thread) 不共享記憶體來完成此操作。此過程稱為多執行緒處理。</p>\n<!--more-->\n<p>Dart 是一種單線程語言：所有的 Dart 程式碼都在一個 <code class=\"language-text\">Isolate</code> 中運行，這讓它們非常重要，整個 Dart 應用程序都在一個隔離體中運行。</p>\n<blockquote>\n<p>在 Flutter 中，每一個執行緒 (Thread) 就稱做一個 Isolate。</p>\n</blockquote>\n<h2>Need for Isolate</h2>\n<p>在 Flutter 中，即使是使用 async/await 的情況下，所有程式碼都在 Main Isolate 中執行 (雖然看起來是非同步的執行，但他們只是在 Main Isolate 中輪流執行，所以 async/await 數量一多還是會造成卡頓)，因此多線程是必不可少的。</p>\n<p><code class=\"language-text\">Isolate</code> 非常有用，可以運行需要很長時間才能完成而不會阻塞主線程的程式碼，這對於提供流暢和反應靈敏的用戶體驗非常重要。多線程允許程式的兩部分或更多部分並行執行，利用 CPU 的多核心。同時也可以讓程式同時執行多項任務，以減少對用戶輸入等事件做出反應時間。</p>\n<p>在深入探討 <code class=\"language-text\">Isolate</code> 的類型之前，有幾件事情需要記住：</p>\n<ul>\n<li>線程之間無法相互通訊：創建的隔離體之間沒有通訊，包括在 Flutter Isolate 中的自定的對象。</li>\n<li>通訊是透過 <code class=\"language-text\">port</code> 完成的：線程之間的任何通訊都是通過 port 進行的。</li>\n</ul>\n<h2>Types Of Isolate In Flutter</h2>\n<p>在 Flutter 中有兩種方式可以創建 Isolate：</p>\n<ul>\n<li><code class=\"language-text\">Compute</code> function</li>\n<li><code class=\"language-text\">Spawn</code> function</li>\n</ul>\n<h3>Spawn Function</h3>\n<p>使用 <code class=\"language-text\">spawn</code> 創建 Isolate 很簡單，它需要兩個參數：一個 Function 和 （可選的）Function 傳入值。</p>\n<p>以下是如何使用 Isolate.spawn 創建 Isolate 的範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">import</span> <span class=\"token string-literal\"><span class=\"token string\">'dart:isolate'</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// create the isolate</span>\n    <span class=\"token class-name\">Isolate</span><span class=\"token punctuation\">.</span><span class=\"token function\">spawn</span><span class=\"token punctuation\">(</span>isolateFunction<span class=\"token punctuation\">,</span> <span class=\"token string-literal\"><span class=\"token string\">\"Hello from the main isolate!\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">isolateFunction</span><span class=\"token punctuation\">(</span>dynmic message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這會創建一個 Isolate 並在背景中執行 <code class=\"language-text\">isolateFunction</code> 中的程式碼。Main Isolate 將字串 \"Hello from the main isolate!\"，傳給新的 Isolate，這個字串會被新的 Isolate 接收到並且印出來。</p>\n<p>請注意，Isolate 是被不同的 Thread 執行的，他們並不共享記憶體，這意味著你需要用 Isolate 之間的通訊技術來在不同的 Isolate 中傳遞數據（就像面的範例是在創建 Isolate 時傳入，或是晚點會介紹的 Port）。</p>\n<h3>Compute Function</h3>\n<p>Flutter 中。你可以使用 Compute function 在單獨的 Isolate 中執行 function，Compute function 是一個 <code class=\"language-text\">Isolate.spawn</code> 的包裝器 (wrapper)，讓 Isolate 執行計算密集型的任務更方便一點。</p>\n<p>下面是一個在 Flutter 中使用 Comput function 創建 Isolate 的範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">import</span> <span class=\"token string-literal\"><span class=\"token string\">'dart:async'</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">></span></span> computeFunction <span class=\"token keyword\">async</span> <span class=\"token punctuation\">{</span>\n    int result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span>computeIntensiveFunction<span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nint <span class=\"token function\">computeInstensiveFunction</span><span class=\"token punctuation\">(</span>int value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 執行一些計算密集型任務</span>\n    <span class=\"token keyword\">return</span> value <span class=\"token operator\">*</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在這個例子中，使用 <code class=\"language-text\">compute()</code> 來創建一個獨立的 Isolate 來執行 <code class=\"language-text\">computeInstensiveFunction</code> 中的程式碼。Compute function 會回傳一個 <code class=\"language-text\">Future</code> ，會在 Function 執行完成時，回傳 Function 的回傳值。在這個例子中是會回傳 100 * 100 = 10000，所以 result 的直是 10000。</p>\n<p>請注意，傳遞給 Comput function 的 Function，必須是頂層函數 (top-level function)，或是 static method，並且傳入值和回傳值的型態都是 dynmic。</p>\n<h2>Isolate 們如何相互溝通</h2>\n<p>要在 Isolate 之間通訊，可以使用 <code class=\"language-text\">SendPort</code> 和 <code class=\"language-text\">ReceivePort</code>。</p>\n<p>以下是一個範例，告訴你如何使用這兩個 classes 來將訊息從 Main Isolate 傳送到新的 Isolate：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">import</span> <span class=\"token string-literal\"><span class=\"token string\">'dart:isolate'</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 創建一個 SentPort 來將訊息傳送到新的 Isolate</span>\n    <span class=\"token keyword\">final</span> sendPort <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SendPort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 創建一個新的 Isolate</span>\n    <span class=\"token class-name\">Isolate</span><span class=\"token punctuation\">.</span><span class=\"token function\">spawn</span><span class=\"token punctuation\">(</span>isolateEntryPoint<span class=\"token punctuation\">,</span> sendPort<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">isolateEntryPoint</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SendPort</span> sendPort<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 創建一個 ReceivePort 來接從 Main Isolate 接收訊息</span>\n    <span class=\"token keyword\">final</span> receivePort <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RceivePort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 傳送 receivePort 的 sendPort 給 Main Isolate，來讓 Main Isolate 可以傳送訊息到這個 Isolate</span>\n    sendPort<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>receivePort<span class=\"token punctuation\">.</span>sendPort<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 監聽來自 Main Isolate 的訊息</span>\n    receivePort<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">'Message received: </span><span class=\"token interpolation\"><span class=\"token punctuation\">$</span><span class=\"token expression\">message</span></span><span class=\"token string\">'</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>要從新的 Isolate 傳送訊息回到 Main Isolate，可以用從 Main Isolate 傳入的 SendPort。</p>\n<p>以下是如何使用此 SendPort 將訊息傳回 Main Isolate：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">void</span> <span class=\"token function\">isolateEntryPoint</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SendPort</span> sendPort<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 創建一個 ReceivePort 來接從 Main Isolate 接收訊息</span>\n    <span class=\"token keyword\">final</span> receivePort <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RceivePort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 傳送 receivePort 的 sendPort 給 Main Isolate，來讓 Main Isolate 可以傳送訊息到這個 Isolate</span>\n    sendPort<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>receivePort<span class=\"token punctuation\">.</span>sendPort<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 監聽來自 Main Isolate 的訊息</span>\n    receivePort<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">'Message received: </span><span class=\"token interpolation\"><span class=\"token punctuation\">$</span><span class=\"token expression\">message</span></span><span class=\"token string\">'</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 傳送訊息回 Main Isolate</span>\n        sendPort<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Hello from the isolate!\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在 Main Isolate 中，你可以使用 ReceivePort 來監聽來自新的 Isolate 的訊息：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">import</span> <span class=\"token string-literal\"><span class=\"token string\">'dart:isolate'</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 創建一個 SentPort 來將訊息傳送到新的 Isolate</span>\n    <span class=\"token keyword\">final</span> sendPort <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SendPort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 創建一個新的 Isolate</span>\n    <span class=\"token class-name\">Isolate</span><span class=\"token punctuation\">.</span><span class=\"token function\">spawn</span><span class=\"token punctuation\">(</span>isolateEntryPoint<span class=\"token punctuation\">,</span> sendPort<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 創建一個 RecivePort 來接收來自新 Isolate 的訊息</span>\n    <span class=\"token keyword\">final</span> receivePort <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReceivePort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 傳送 ReceivePort 的 SendPort 給新的 Isolate</span>\n    sendPort<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>receivePort<span class=\"token punctuation\">.</span>sendPort<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 監聽訊息</span>\n    receivePort<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">'Message received: </span><span class=\"token interpolation\"><span class=\"token punctuation\">$</span><span class=\"token expression\">message</span></span><span class=\"token string\">'</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">flutter_isolate</code> 套件提供了一種在單獨 Isolate（單獨的執行 Context）中運行 Dart 程式碼的方法。 Isolate 用於並行執行程式碼，可以用於實現負載平衡，因為它們允許你將工作負載分佈到多個線程中。</p>\n<p>以下是如何在 Flutter 中使用 <code class=\"language-text\">flutter_isolate</code> 來平衡工作量的範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">import</span> <span class=\"token string-literal\"><span class=\"token string\">'package:flutter_isolate/flutter_isolate.dart'</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 創建一個要負載平衡的 function</span>\n    <span class=\"token keyword\">final</span> workload <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Do some work here</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 創建一個列表的 Isolate</span>\n    <span class=\"token keyword\">final</span> isolates <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token class-name\">IsolateRunner</span><span class=\"token punctuation\">(</span>workload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token class-name\">IsolateRunner</span><span class=\"token punctuation\">(</span>workload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token class-name\">IsolateRunner</span><span class=\"token punctuation\">(</span>workload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 執行每一個 Isolate</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> isolate <span class=\"token keyword\">in</span> isolates<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        isolate<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這個範例創建了一個包含三個 Isolate 的列表，每一個 Isolate 都有相同的工作，你可以呼叫每個 Isolate <code class=\"language-text\">run()</code> 來執行他們。</p>\n<p>其他使用方法可以看 <a href=\"https://pub.dev/packages/flutter_isolate\">flutter_isolate 的官方文件</a></p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://medium.flutterdevs.com/multithreading-in-flutter-aa07e2ae2971\">原文網址</a></li>\n<li><a href=\"https://pub.dev/packages/flutter_isolate\">flutter_isolate</a></li>\n</ul>","rawMarkdownBody":"\n本文翻譯自 Medium。[原文網址](https://medium.flutterdevs.com/multithreading-in-flutter-aa07e2ae2971)，請在閱讀前先去幫原作者拍拍手。另外，我也有在原文中加入一些我自己的理解。\n\nFlutter 是由 Google 開發的跨平台框架，因其出色的用戶界面能力和動畫而引起了廣泛關注。如果我們遇到畫面卡住、動畫未按預期工作以及螢幕跳躍等問題，它的威力就會受到阻礙，進而導致整個用戶體驗變得很糟糕。通常，觸發這種現象的原因可能是同步訪問多個 API 請求、圖像處理、動畫或任何其他耗時操作。\n\n很多開發人員希望在他們的應用程式中解決此問題，以便讓程式不會出現這種情況。可以通過創建多個隔離線程 `Isolate`，這些線程具有自己的事件循環並與運行 Flutter 的主執行緒 (Main Thread) 不共享記憶體來完成此操作。此過程稱為多執行緒處理。\n\n<!--more-->\n\nDart 是一種單線程語言：所有的 Dart 程式碼都在一個 `Isolate` 中運行，這讓它們非常重要，整個 Dart 應用程序都在一個隔離體中運行。\n\n> 在 Flutter 中，每一個執行緒 (Thread) 就稱做一個 Isolate。\n\n## Need for Isolate\n\n在 Flutter 中，即使是使用 async/await 的情況下，所有程式碼都在 Main Isolate 中執行 (雖然看起來是非同步的執行，但他們只是在 Main Isolate 中輪流執行，所以 async/await 數量一多還是會造成卡頓)，因此多線程是必不可少的。\n\n`Isolate` 非常有用，可以運行需要很長時間才能完成而不會阻塞主線程的程式碼，這對於提供流暢和反應靈敏的用戶體驗非常重要。多線程允許程式的兩部分或更多部分並行執行，利用 CPU 的多核心。同時也可以讓程式同時執行多項任務，以減少對用戶輸入等事件做出反應時間。\n\n在深入探討 `Isolate` 的類型之前，有幾件事情需要記住：\n\n- 線程之間無法相互通訊：創建的隔離體之間沒有通訊，包括在 Flutter Isolate 中的自定的對象。\n- 通訊是透過 `port` 完成的：線程之間的任何通訊都是通過 port 進行的。\n\n## Types Of Isolate In Flutter\n\n在 Flutter 中有兩種方式可以創建 Isolate：\n\n- `Compute` function\n- `Spawn` function\n\n### Spawn Function\n\n使用 `spawn` 創建 Isolate 很簡單，它需要兩個參數：一個 Function 和 （可選的）Function 傳入值。\n\n以下是如何使用 Isolate.spawn 創建 Isolate 的範例：\n\n```dart\nimport 'dart:isolate';\n\nvoid main() {\n    // create the isolate\n    Isolate.spawn(isolateFunction, \"Hello from the main isolate!\");\n}\n\nvoid isolateFunction(dynmic message) {\n    print(message);\n}\n```\n\n這會創建一個 Isolate 並在背景中執行 `isolateFunction` 中的程式碼。Main Isolate 將字串 \"Hello from the main isolate!\"，傳給新的 Isolate，這個字串會被新的 Isolate 接收到並且印出來。\n\n請注意，Isolate 是被不同的 Thread 執行的，他們並不共享記憶體，這意味著你需要用 Isolate 之間的通訊技術來在不同的 Isolate 中傳遞數據（就像面的範例是在創建 Isolate 時傳入，或是晚點會介紹的 Port）。\n\n### Compute Function\n\nFlutter 中。你可以使用 Compute function 在單獨的 Isolate 中執行 function，Compute function 是一個 `Isolate.spawn` 的包裝器 (wrapper)，讓 Isolate 執行計算密集型的任務更方便一點。\n\n下面是一個在 Flutter 中使用 Comput function 創建 Isolate 的範例：\n\n```dart\nimport 'dart:async';\n\nFuture<void> computeFunction async {\n    int result = await compute(computeIntensiveFunction, 100);\n    print(result);\n}\n\nint computeInstensiveFunction(int value) {\n    // 執行一些計算密集型任務\n    return value * value;\n}\n```\n\n在這個例子中，使用 `compute()` 來創建一個獨立的 Isolate 來執行 `computeInstensiveFunction` 中的程式碼。Compute function 會回傳一個 `Future` ，會在 Function 執行完成時，回傳 Function 的回傳值。在這個例子中是會回傳 100 \\* 100 = 10000，所以 result 的直是 10000。\n\n請注意，傳遞給 Comput function 的 Function，必須是頂層函數 (top-level function)，或是 static method，並且傳入值和回傳值的型態都是 dynmic。\n\n## Isolate 們如何相互溝通\n\n要在 Isolate 之間通訊，可以使用 `SendPort` 和 `ReceivePort`。\n\n以下是一個範例，告訴你如何使用這兩個 classes 來將訊息從 Main Isolate 傳送到新的 Isolate：\n\n```dart\nimport 'dart:isolate';\n\nvoid main() {\n    // 創建一個 SentPort 來將訊息傳送到新的 Isolate\n    final sendPort = new SendPort();\n    // 創建一個新的 Isolate\n    Isolate.spawn(isolateEntryPoint, sendPort);\n}\n\nvoid isolateEntryPoint(SendPort sendPort) {\n    // 創建一個 ReceivePort 來接從 Main Isolate 接收訊息\n    final receivePort = new RceivePort();\n\n    // 傳送 receivePort 的 sendPort 給 Main Isolate，來讓 Main Isolate 可以傳送訊息到這個 Isolate\n    sendPort.send(receivePort.sendPort);\n\n    // 監聽來自 Main Isolate 的訊息\n    receivePort.listen((message) {\n        print('Message received: $message');\n    });\n}\n```\n\n要從新的 Isolate 傳送訊息回到 Main Isolate，可以用從 Main Isolate 傳入的 SendPort。\n\n以下是如何使用此 SendPort 將訊息傳回 Main Isolate：\n\n```dart\nvoid isolateEntryPoint(SendPort sendPort) {\n    // 創建一個 ReceivePort 來接從 Main Isolate 接收訊息\n    final receivePort = new RceivePort();\n\n    // 傳送 receivePort 的 sendPort 給 Main Isolate，來讓 Main Isolate 可以傳送訊息到這個 Isolate\n    sendPort.send(receivePort.sendPort);\n\n    // 監聽來自 Main Isolate 的訊息\n    receivePort.listen((message) {\n        print('Message received: $message');\n\n        // 傳送訊息回 Main Isolate\n        sendPort.send(\"Hello from the isolate!\");\n    });\n}\n```\n\n在 Main Isolate 中，你可以使用 ReceivePort 來監聽來自新的 Isolate 的訊息：\n\n```dart\nimport 'dart:isolate';\n\nvoid main() {\n    // 創建一個 SentPort 來將訊息傳送到新的 Isolate\n    final sendPort = new SendPort();\n\n    // 創建一個新的 Isolate\n    Isolate.spawn(isolateEntryPoint, sendPort);\n\n    // 創建一個 RecivePort 來接收來自新 Isolate 的訊息\n    final receivePort = new ReceivePort();\n\n    // 傳送 ReceivePort 的 SendPort 給新的 Isolate\n    sendPort.send(receivePort.sendPort);\n\n    // 監聽訊息\n    receivePort.listen((message) {\n        print('Message received: $message');\n    });\n}\n```\n\n`flutter_isolate` 套件提供了一種在單獨 Isolate（單獨的執行 Context）中運行 Dart 程式碼的方法。 Isolate 用於並行執行程式碼，可以用於實現負載平衡，因為它們允許你將工作負載分佈到多個線程中。\n\n以下是如何在 Flutter 中使用 `flutter_isolate` 來平衡工作量的範例：\n\n```dart\nimport 'package:flutter_isolate/flutter_isolate.dart';\n\nvoid main() {\n    // 創建一個要負載平衡的 function\n    final workload = () {\n        // Do some work here\n    };\n\n    // 創建一個列表的 Isolate\n    final isolates = [\n        IsolateRunner(workload),\n        IsolateRunner(workload),\n        IsolateRunner(workload),\n    ];\n\n    // 執行每一個 Isolate\n    for (final isolate in isolates) {\n        isolate.run();\n    }\n}\n```\n\n這個範例創建了一個包含三個 Isolate 的列表，每一個 Isolate 都有相同的工作，你可以呼叫每個 Isolate `run()` 來執行他們。\n\n其他使用方法可以看 [flutter_isolate 的官方文件](https://pub.dev/packages/flutter_isolate)\n\n## Reference\n\n- [原文網址](https://medium.flutterdevs.com/multithreading-in-flutter-aa07e2ae2971)\n- [flutter_isolate](https://pub.dev/packages/flutter_isolate)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Flutter/flutter-isolate.md","excerpt":"本文翻譯自 Medium。原文網址，請在閱讀前先去幫原作者拍拍手。另外，我也有在原文中加入一些我自己的理解。 Flutter 是由 Google 開發的跨平台框架，因其出色的用戶界面能力和動畫而引起了廣泛關注。如果我們遇到畫面卡住、動畫未按預期工作以及螢幕跳躍等問題，它的威力就會受到阻礙，進而導致整個用戶體驗變得很糟糕。通常，觸發這種現象的原因可能是同步訪問多個 API 請求、圖像處理、動畫或任…","frontmatter":{"title":"Flutter Isolate 多執行緒","date":"2023-03-15T01:53:01.621Z","draft":false,"tags":["flutter","dart","isolate","multithread"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/2aa71d52-6fd6-4086-80fc-ba6692219700/public","description":null}}},{"node":{"id":"0173acc9-1f30-5386-82d0-45d9174e7f25","html":"<p>使用自己的網域要收發電子郵件是一件麻煩事，自己架設 Email Server，發出去的信件大部分都會被當成垃圾信。簡單的解決方式，就是買下 Google Workspace，但是這真的蠻貴的，所以我發現了完全免費的解決方式，記錄一下。</p>\n<!--more-->\n<h2>思路</h2>\n<ul>\n<li>Cloudflare Email Routing 收電子郵件，並轉到自己的 Gmail</li>\n<li>Google SMTP 發電子郵件</li>\n</ul>\n<h2>Email 轉址</h2>\n<p>Cloudflare 的佛心服務之一，就是可以幫忙把 Email 轉址，只要網域託管給 Cloudflare 就可以免費使用，沒有任何限制，真的是完全免費。</p>\n<p>只要在 Cloudflare 的網域設定中設定一個自己想要接收 Email 的位置和用戶名，並轉發到自己的 Gmail 即可。這樣以後只要寄 Email 到設定的位置，全部都會轉發到自己的 Gmail。</p>\n<p>設定時 Cloudflare 會寄一封信到要被轉發的 Gmail 中確認。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/87cbdb38-c1cc-41b9-759b-1c453e204f00/public\" alt=\"img\"></p>\n<h2>發送 Email</h2>\n<p>解決了收信的問題，現在來解決發信的問題。Gmail 有提供免費的 Email SMTP Server 供免費發送電子郵件，不管任何的網域都可以，只要有 Google 帳號，就可以每天寄送 500 封 Email。</p>\n<p>到 Gamil 的設定中，新增用來寄 Email 的地址，這可以設定很多個。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b02717d8-d39d-4fa7-9151-601ccb7beb00/public\" alt=\"img\"></p>\n<p>輸入剛剛在 Cloudflare 設定的 Email，名稱填自己發信時想要顯示的名字。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8354f94e-c13f-4e72-d717-685dd7af1900/public\" alt=\"img\"></p>\n<p>免費的 Gmail SMTP 設定值如下：</p>\n<ul>\n<li>SMTP Server: <code class=\"language-text\">smtp.gmail.com</code></li>\n<li>使用者名稱：自己的 Gmail 帳號</li>\n<li>密碼：Gmail 密碼 (如果 Google 帳號有設定 2FA，可以到 <a href=\"https://myaccount.google.com/apppasswords\">https://myaccount.google.com/apppasswords</a> 產生專用密碼)</li>\n</ul>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6905c1eb-b1de-4a3d-81fa-e938302b2500/public\" alt=\"img\"></p>\n<p>新增後，Google 也會寄一封確認信到你要被轉發的信箱，確認你真的擁有這個地址的使用權，避免濫用。因為剛剛已經叫 Cloudflare 轉發郵件到你的 Gmail，所以可以直接在你的 Gmail 收認證信。</p>\n<p>這樣就大功告成，用兩個免費的服務給解決自己的網域的收發信問題，而且是由 Gmail 的 SMTP 寄出，也比較不會被擋信。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://developers.cloudflare.com/email-routing/\">Cloudflare Email Routing</a></li>\n<li><a href=\"https://kinsta.com/blog/gmail-smtp-server/\">How to Use the Gmail SMTP Server to Send Emails for Free</a></li>\n</ul>","rawMarkdownBody":"\n使用自己的網域要收發電子郵件是一件麻煩事，自己架設 Email Server，發出去的信件大部分都會被當成垃圾信。簡單的解決方式，就是買下 Google Workspace，但是這真的蠻貴的，所以我發現了完全免費的解決方式，記錄一下。\n\n<!--more-->\n\n## 思路\n\n- Cloudflare Email Routing 收電子郵件，並轉到自己的 Gmail\n- Google SMTP 發電子郵件\n\n## Email 轉址\n\nCloudflare 的佛心服務之一，就是可以幫忙把 Email 轉址，只要網域託管給 Cloudflare 就可以免費使用，沒有任何限制，真的是完全免費。\n\n只要在 Cloudflare 的網域設定中設定一個自己想要接收 Email 的位置和用戶名，並轉發到自己的 Gmail 即可。這樣以後只要寄 Email 到設定的位置，全部都會轉發到自己的 Gmail。\n\n設定時 Cloudflare 會寄一封信到要被轉發的 Gmail 中確認。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/87cbdb38-c1cc-41b9-759b-1c453e204f00/public)\n\n## 發送 Email\n\n解決了收信的問題，現在來解決發信的問題。Gmail 有提供免費的 Email SMTP Server 供免費發送電子郵件，不管任何的網域都可以，只要有 Google 帳號，就可以每天寄送 500 封 Email。\n\n到 Gamil 的設定中，新增用來寄 Email 的地址，這可以設定很多個。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b02717d8-d39d-4fa7-9151-601ccb7beb00/public)\n\n輸入剛剛在 Cloudflare 設定的 Email，名稱填自己發信時想要顯示的名字。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8354f94e-c13f-4e72-d717-685dd7af1900/public)\n\n免費的 Gmail SMTP 設定值如下：\n\n- SMTP Server: `smtp.gmail.com`\n- 使用者名稱：自己的 Gmail 帳號\n- 密碼：Gmail 密碼 (如果 Google 帳號有設定 2FA，可以到 [https://myaccount.google.com/apppasswords](https://myaccount.google.com/apppasswords) 產生專用密碼)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6905c1eb-b1de-4a3d-81fa-e938302b2500/public)\n\n新增後，Google 也會寄一封確認信到你要被轉發的信箱，確認你真的擁有這個地址的使用權，避免濫用。因為剛剛已經叫 Cloudflare 轉發郵件到你的 Gmail，所以可以直接在你的 Gmail 收認證信。\n\n這樣就大功告成，用兩個免費的服務給解決自己的網域的收發信問題，而且是由 Gmail 的 SMTP 寄出，也比較不會被擋信。\n\n## Reference\n\n- [Cloudflare Email Routing](https://developers.cloudflare.com/email-routing/)\n- [How to Use the Gmail SMTP Server to Send Emails for Free](https://kinsta.com/blog/gmail-smtp-server/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Others/cf-email-routing-gmail.md","excerpt":"使用自己的網域要收發電子郵件是一件麻煩事，自己架設 Email Server，發出去的信件大部分都會被當成垃圾信。簡單的解決方式，就是買下 Google Workspace，但是這真的蠻貴的，所以我發現了完全免費的解決方式，記錄一下。 思路 Cloudflare Email Routing 收電子郵件，並轉到自己的 Gmail Google SMTP 發電子郵件 Email 轉址 Cloudfl…","frontmatter":{"title":"自訂網域免費收發信 -- Cloudflare Email Routing 搭配 Gmail SMTP","date":"2022-10-27T13:44:50.631Z","draft":false,"tags":["cloudflare","email","gmail"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9269c238-393f-40f8-9617-2416ff0de100/public","description":null}}},{"node":{"id":"505740d3-a1e0-50b9-881b-985e3deedb79","html":"<p>持續更新</p>\n<!--more-->\n<h2>主要功能</h2>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/fe62dea5-6895-41d6-0d77-aea084d0a400/public\" alt=\"img\"></p>\n<h2>主頁 - 顯示附近的換電站</h2>\n<p>點擊電池圖示，可進入換電站詳細資料</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/501bf8bd-ad8e-4ebf-77b5-9e593effe500/public\" alt=\"img\"></p>\n<h2>Go Station 列表</h2>\n<ul>\n<li>顯示所有換電站</li>\n<li>以使用者目前位置與換電站位置直線距離排序</li>\n<li>可點擊進入換電站詳細資訊</li>\n</ul>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/cc6dc1f6-37e6-4825-b1e0-ca390f7cf200/public\" alt=\"img\"></p>\n<h2>換電站的涵蓋範圍</h2>\n<ul>\n<li>預設涵蓋範圍為 50 公里，可在設定中變更 (1 ~ 100)</li>\n<li>以這個換電站為中心，可以用 <strong>道路</strong> 到達地方</li>\n<li>計算是包含高快速公路等禁行機車路段，使用時需多加注意</li>\n<li>計算不考慮上升或下降海拔</li>\n<li>點一下空白處，即可關閉</li>\n</ul>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/83e32a54-f6fc-49f2-3d36-6fdead20a200/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/934c92d3-257c-4816-ccb5-9ee5d8e16000/public\" alt=\"img\"></p>\n<h2>其他</h2>\n<p>本程式與 「Gogoro 睿能創意股份有限公司」無關</p>","rawMarkdownBody":"\n持續更新\n\n<!--more-->\n\n## 主要功能\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/fe62dea5-6895-41d6-0d77-aea084d0a400/public)\n\n## 主頁 - 顯示附近的換電站\n\n點擊電池圖示，可進入換電站詳細資料\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/501bf8bd-ad8e-4ebf-77b5-9e593effe500/public)\n\n## Go Station 列表\n\n- 顯示所有換電站\n- 以使用者目前位置與換電站位置直線距離排序\n- 可點擊進入換電站詳細資訊\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/cc6dc1f6-37e6-4825-b1e0-ca390f7cf200/public)\n\n## 換電站的涵蓋範圍\n\n- 預設涵蓋範圍為 50 公里，可在設定中變更 (1 ~ 100)\n- 以這個換電站為中心，可以用 **道路** 到達地方\n- 計算是包含高快速公路等禁行機車路段，使用時需多加注意\n- 計算不考慮上升或下降海拔\n- 點一下空白處，即可關閉\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/83e32a54-f6fc-49f2-3d36-6fdead20a200/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/934c92d3-257c-4816-ccb5-9ee5d8e16000/public)\n\n## 其他\n\n本程式與 「Gogoro 睿能創意股份有限公司」無關\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Others/itsgo-doc.md","excerpt":"持續更新 主要功能 img 主頁 - 顯示附近的換電站 點擊電池圖示，可進入換電站詳細資料 img Go Station 列表 顯示所有換電站 以使用者目前位置與換電站位置直線距離排序 可點擊進入換電站詳細資訊 img 換電站的涵蓋範圍 預設涵蓋範圍為 50 公里，可在設定中變更 (1 ~ 100) 以這個換電站為中心，可以用 道路 到達地方 計算是包含高快速公路等禁行機車路段，使用時需多加注意…","frontmatter":{"title":"這就 Go -- 使用說明","date":"2022-10-16T13:44:50.631Z","draft":false,"tags":["gogoro","itsgo"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f69f0eb7-8df6-42c2-7cd5-c8499f2e8f00/public","description":null}}},{"node":{"id":"56c03060-dd39-55f0-84b4-0eec1af77639","html":"<p>我的專案只要有關 js 的，我都會用 prettier 來自動排版，因為 prettier 能確保大家的程式碼風格一致。但是，我常常會有忘記 prettier 一下就直接 push 到 GitHub 上，我就想到說如果 GitHub Actions 可以幫忙檢查 prettier 應該也可以就直接幫忙 prettier 後 push 上來吧。今天我就把我寫好的 GitHub Actions 腳本記錄一下。</p>\n<!--more-->\n<h2>思路</h2>\n<p>我把他分為兩個 job 來做：</p>\n<ol>\n<li>執行 prettier check</li>\n<li>如果步驟 1 失敗，執行 prettier write 並 push</li>\n</ol>\n<p>完整的 yml 檔我放在最後面了，有需要的人可以直接拿去用。</p>\n<h2>Prettier Check</h2>\n<p>執行 prettier check 應該是很簡單的步驟，許多 GitHub 上的開源專案應該都寫的差不多。簡單來說，就是設定好 node 後，直接 run <code class=\"language-text\">npx prettier --check .</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">prettier-check</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Checkout\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Node\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/setup<span class=\"token punctuation\">-</span>node@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">node-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"14\"</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Run Prettier Check\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          npx prettier --check .</span></code></pre></div>\n<h2>Prettier Write</h2>\n<p>這步驟比較會遇到問題的部分就是要如何判斷上一步驟 prettier check 執行失敗，我翻了一下 GitHub Actions 的文件，發現可以用 if 來決定一個 job 要不要執行，所以我們會需要 prettier check 的執行結果，才決定要不要 prettie write。Actions 有一個 <code class=\"language-text\">needs</code> 的邏輯，可以用來等待另一個 job 完成，然後使用他的執行結果。所以目前為止，可以先寫成下面這樣：</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">prettier-write</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\n    <span class=\"token key atrule\">needs</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> prettier<span class=\"token punctuation\">-</span>check\n    <span class=\"token key atrule\">if</span><span class=\"token punctuation\">:</span> always() <span class=\"token important\">&amp;&amp;</span> (needs.prettier<span class=\"token punctuation\">-</span>check.result == 'failure')</code></pre></div>\n<p>接下來來寫 prettier write 和 git push，我在這邊遇到的問題是，如果 git checkout 的時候沒有給 Token，GitHub 預設會讓由 Actions push 的 Commit 不會觸發任的 Actions，這也不難理解，怕 Actions 彼此呼相 Call，然後進到無限回圈停不下來。但我今天還是希望他 prettier 完後可以觸發 Build 的 Actions，所以我們就要在 git checkout 的時候給他自訂的 Token，這樣等等在 push 的時候，也會幫我們用這個 Token Push。</p>\n<p>就不在另外上程式碼，直接去下方看完整邏輯吧。</p>\n<h2>完整的 GitHub Actions 檔</h2>\n<p>結合上面兩個步驟：</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> prettier\n\n<span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">prettier-check</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Checkout\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">token</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.MY_GITHUB_TOKEN <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Node\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/setup<span class=\"token punctuation\">-</span>node@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">node-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"14\"</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Run Prettier Check\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          npx prettier --check .</span>\n  <span class=\"token key atrule\">prettier-write</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\n    <span class=\"token key atrule\">needs</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> prettier<span class=\"token punctuation\">-</span>check\n    <span class=\"token key atrule\">if</span><span class=\"token punctuation\">:</span> always() <span class=\"token important\">&amp;&amp;</span> (needs.prettier<span class=\"token punctuation\">-</span>check.result == 'failure')\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Checkout\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">token</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.MY_GITHUB_TOKEN <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Node\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/setup<span class=\"token punctuation\">-</span>node@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">node-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"14\"</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Write Prettier\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          npx prettier --write .</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Commit and Push\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> EndBug/add<span class=\"token punctuation\">-</span>and<span class=\"token punctuation\">-</span>commit@v9\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">add</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\".\"</span>\n          <span class=\"token key atrule\">message</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"Prettier\"</span>\n          <span class=\"token key atrule\">committer_name</span><span class=\"token punctuation\">:</span> TonyPepeBear\n          <span class=\"token key atrule\">committer_email</span><span class=\"token punctuation\">:</span> tonybear55665566@gmail.com</code></pre></div>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://docs.github.com/en/actions\">GitHub Actions</a></li>\n</ul>","rawMarkdownBody":"\n我的專案只要有關 js 的，我都會用 prettier 來自動排版，因為 prettier 能確保大家的程式碼風格一致。但是，我常常會有忘記 prettier 一下就直接 push 到 GitHub 上，我就想到說如果 GitHub Actions 可以幫忙檢查 prettier 應該也可以就直接幫忙 prettier 後 push 上來吧。今天我就把我寫好的 GitHub Actions 腳本記錄一下。\n\n<!--more-->\n\n## 思路\n\n我把他分為兩個 job 來做：\n\n1. 執行 prettier check\n2. 如果步驟 1 失敗，執行 prettier write 並 push\n\n完整的 yml 檔我放在最後面了，有需要的人可以直接拿去用。\n\n## Prettier Check\n\n執行 prettier check 應該是很簡單的步驟，許多 GitHub 上的開源專案應該都寫的差不多。簡單來說，就是設定好 node 後，直接 run `npx prettier --check .`：\n\n```yml\njobs:\n  prettier-check:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: \"14\"\n\n      - name: Run Prettier Check\n        run: |\n          npx prettier --check .\n```\n\n## Prettier Write\n\n這步驟比較會遇到問題的部分就是要如何判斷上一步驟 prettier check 執行失敗，我翻了一下 GitHub Actions 的文件，發現可以用 if 來決定一個 job 要不要執行，所以我們會需要 prettier check 的執行結果，才決定要不要 prettie write。Actions 有一個 `needs` 的邏輯，可以用來等待另一個 job 完成，然後使用他的執行結果。所以目前為止，可以先寫成下面這樣：\n\n```yml\njobs:\n  prettier-write:\n    runs-on: ubuntu-latest\n    needs:\n      - prettier-check\n    if: always() && (needs.prettier-check.result == 'failure')\n```\n\n接下來來寫 prettier write 和 git push，我在這邊遇到的問題是，如果 git checkout 的時候沒有給 Token，GitHub 預設會讓由 Actions push 的 Commit 不會觸發任的 Actions，這也不難理解，怕 Actions 彼此呼相 Call，然後進到無限回圈停不下來。但我今天還是希望他 prettier 完後可以觸發 Build 的 Actions，所以我們就要在 git checkout 的時候給他自訂的 Token，這樣等等在 push 的時候，也會幫我們用這個 Token Push。\n\n就不在另外上程式碼，直接去下方看完整邏輯吧。\n\n## 完整的 GitHub Actions 檔\n\n結合上面兩個步驟：\n\n```yml\nname: prettier\n\non:\n  push:\n\njobs:\n  prettier-check:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n        with:\n          token: ${{ secrets.MY_GITHUB_TOKEN }}\n\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: \"14\"\n\n      - name: Run Prettier Check\n        run: |\n          npx prettier --check .\n  prettier-write:\n    runs-on: ubuntu-latest\n    needs:\n      - prettier-check\n    if: always() && (needs.prettier-check.result == 'failure')\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n        with:\n          token: ${{ secrets.MY_GITHUB_TOKEN }}\n\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: \"14\"\n\n      - name: Write Prettier\n        run: |\n          npx prettier --write .\n      - name: Commit and Push\n        uses: EndBug/add-and-commit@v9\n        with:\n          add: \".\"\n          message: \"Prettier\"\n          committer_name: TonyPepeBear\n          committer_email: tonybear55665566@gmail.com\n```\n\n## Reference\n\n- [GitHub Actions](https://docs.github.com/en/actions)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/GitHub/github-actions-prettier.md","excerpt":"我的專案只要有關 js 的，我都會用 prettier 來自動排版，因為 prettier 能確保大家的程式碼風格一致。但是，我常常會有忘記 prettier 一下就直接 push 到 GitHub 上，我就想到說如果 GitHub Actions 可以幫忙檢查 prettier 應該也可以就直接幫忙 prettier 後 push 上來吧。今天我就把我寫好的 GitHub Actions 腳本…","frontmatter":{"title":"讓 GitHub Actions 來幫你 Prettier","date":"2022-10-04T13:44:50.631Z","draft":false,"tags":["prettier","github","github-actions"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b33c3519-4782-4519-e113-3aadf3bf8800/public","description":null}}},{"node":{"id":"2797652b-b371-5832-b5ca-7639e58b787e","html":"<p>維基百科是大家的好朋友，但他的網頁排版感覺已經幾十年沒有更新過，閱讀起來有點不方便，而 Wikiwand 就是來幫助維基百科排版成更容易閱讀的形式，在 Google Chrome 上有官方的擴充功能可以將 Wiki 的網址直接重新導向到 Wikiwand，而 Safari 好像是因為 Apple 嚴格的條件所以沒有擴充功能，但我今天發現的一個技巧可以協助將網頁直接重新導向到 Wikiwand。</p>\n<!--more-->\n<h2>Wikiwand 比較</h2>\n<p>原版維基：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0a6c340c-becb-4748-a9d3-949a48241600/public\" alt=\"img\"></p>\n<p>Wikiwand:</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6023546f-67b9-4524-df91-33bc53f34f00/public\" alt=\"img\"></p>\n<h2>利用 AdGuard</h2>\n<p>這個技巧是利用廣告過濾器來協助網頁重新導向，而我是用 AdGuard 來幫助我們完成，我也只在 AdGuard 上用過，其他廣告過濾器我就不知道可不可以利用這個技巧了。如過沒有 AdGuard 的話，也可以去下載試用看看，自己用了很久覺得還不錯。</p>\n<p>整個過程只需要一步</p>\n<p>在 AdGuard 的設定中，在過濾器選項中新增使用者自訂的過濾器：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">@@<span class=\"token operator\">||</span>wikipedia<span class=\"token punctuation\">.</span>org<span class=\"token operator\">^</span>$generichide<span class=\"token punctuation\">,</span>badfilter\nwikipedia<span class=\"token punctuation\">.</span>org#<span class=\"token operator\">%</span>#<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>search <span class=\"token operator\">===</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">var</span> lang <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>hostname<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">var</span> article <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>pathname<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>href <span class=\"token operator\">=</span> <span class=\"token string\">\"http://www.wikiwand.com/\"</span> <span class=\"token operator\">+</span> lang <span class=\"token operator\">+</span> <span class=\"token string\">\"/\"</span> <span class=\"token operator\">+</span> article<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4296f199-0bb2-4c34-922f-b45a5c280100/public\" alt=\"img\"></p>\n<p>大功告成</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"http://sebastiangrans.github.io/Wikiwand-on-Safari-13/\">Wikiwand on Safari</a></li>\n</ul>","rawMarkdownBody":"\n維基百科是大家的好朋友，但他的網頁排版感覺已經幾十年沒有更新過，閱讀起來有點不方便，而 Wikiwand 就是來幫助維基百科排版成更容易閱讀的形式，在 Google Chrome 上有官方的擴充功能可以將 Wiki 的網址直接重新導向到 Wikiwand，而 Safari 好像是因為 Apple 嚴格的條件所以沒有擴充功能，但我今天發現的一個技巧可以協助將網頁直接重新導向到 Wikiwand。\n\n<!--more-->\n\n## Wikiwand 比較\n\n原版維基：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0a6c340c-becb-4748-a9d3-949a48241600/public)\n\nWikiwand:\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6023546f-67b9-4524-df91-33bc53f34f00/public)\n\n## 利用 AdGuard\n\n這個技巧是利用廣告過濾器來協助網頁重新導向，而我是用 AdGuard 來幫助我們完成，我也只在 AdGuard 上用過，其他廣告過濾器我就不知道可不可以利用這個技巧了。如過沒有 AdGuard 的話，也可以去下載試用看看，自己用了很久覺得還不錯。\n\n整個過程只需要一步\n\n在 AdGuard 的設定中，在過濾器選項中新增使用者自訂的過濾器：\n\n```js\n@@||wikipedia.org^$generichide,badfilter\nwikipedia.org#%#if (window.location.search === \"\") { var lang = window.location.hostname.split('.')[0]; var article = window.location.pathname.split('/')[2]; window.location.href = \"http://www.wikiwand.com/\" + lang + \"/\" + article; }\n```\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4296f199-0bb2-4c34-922f-b45a5c280100/public)\n\n大功告成\n\n## Reference\n\n- [Wikiwand on Safari](http://sebastiangrans.github.io/Wikiwand-on-Safari-13/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Others/Wikiwand on Safari.md","excerpt":"維基百科是大家的好朋友，但他的網頁排版感覺已經幾十年沒有更新過，閱讀起來有點不方便，而 Wikiwand 就是來幫助維基百科排版成更容易閱讀的形式，在 Google Chrome 上有官方的擴充功能可以將 Wiki 的網址直接重新導向到 Wikiwand，而 Safari 好像是因為 Apple 嚴格的條件所以沒有擴充功能，但我今天發現的一個技巧可以協助將網頁直接重新導向到 Wikiwand。 …","frontmatter":{"title":"Wikiwand on Safari","date":"2022-08-26T13:44:50.631Z","draft":false,"tags":["wiki","wikiwand","adguard"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/70c00ace-d3b4-4326-cd8c-938fe0cc7200/public","description":null}}},{"node":{"id":"abbc4a5c-22fa-521b-8c76-c393653c057b","html":"<p>Amend Commit 就是用來修改最新 Commit 的指令，如果要修改更之前的 Commit，就要用 Rebase 或是 Reset 了。</p>\n<!--more-->\n<h2>修改 Commit Message</h2>\n<p>如果最新的 Commit Message 亂寫或是寫的什麼不該寫的，就可以用 Amend Commit 來修改。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> commit --amend -m <span class=\"token string\">\"新的 Commit Message\"</span></code></pre></div>\n<h2>壓進前一次 Commit</h2>\n<p>我常常會先將目前的修改給 Commit 一下當作存檔，但如果每次都只有小修改就 Commit 一次也會造成 Commit 非常多，所以我們可以在 Commit 的時候用 Amend Commit 壓進前一次 Commit，或是想像成修改上一次的 Commit 把這次的修改給加進去。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span>\n<span class=\"token function\">git</span> commit --amend</code></pre></div>","rawMarkdownBody":"\nAmend Commit 就是用來修改最新 Commit 的指令，如果要修改更之前的 Commit，就要用 Rebase 或是 Reset 了。\n\n<!--more-->\n\n## 修改 Commit Message\n\n如果最新的 Commit Message 亂寫或是寫的什麼不該寫的，就可以用 Amend Commit 來修改。\n\n```bash\ngit commit --amend -m \"新的 Commit Message\"\n```\n\n## 壓進前一次 Commit\n\n我常常會先將目前的修改給 Commit 一下當作存檔，但如果每次都只有小修改就 Commit 一次也會造成 Commit 非常多，所以我們可以在 Commit 的時候用 Amend Commit 壓進前一次 Commit，或是想像成修改上一次的 Commit 把這次的修改給加進去。\n\n```bash\ngit add .\ngit commit --amend\n```\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Git/amend.md","excerpt":"Amend Commit 就是用來修改最新 Commit 的指令，如果要修改更之前的 Commit，就要用 Rebase 或是 Reset 了。 修改 Commit Message 如果最新的 Commit Message 亂寫或是寫的什麼不該寫的，就可以用 Amend Commit 來修改。 壓進前一次 Commit 我常常會先將目前的修改給 Commit 一下當作存檔，但如果每次都只有小修改…","frontmatter":{"title":"Git Amend Commit","date":"2022-08-11T13:44:12.703Z","draft":false,"tags":["git","amend","commit"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/aa912c60-37ce-4fc5-6187-568499120700/public","description":null}}},{"node":{"id":"4c2b84a4-ff67-5922-b2e9-703e3980c137","html":"<p>今天把一台古老的 Samsung Galaxy S7 從 Android 6M 刷上 Android 11R，使用 Pixle Experience ROM，並安裝 Magisk 和 GPS JoyStick 來玩 Pokemon Go。過程不難，一步步做就不會出錯，從 Andoird 6 升到 11 也沒有早成手機有明顯卡頓，佩服作者。</p>\n<!--more-->\n<p>這次的動機主要是 Pokemon Go 最近開始不支援 Android 6 以下的裝置遊玩，只好升級原本的裝置。</p>\n<h2>步驟概覽</h2>\n<ol>\n<li>刷入 TWRP</li>\n<li>刷入 Pixle Experience</li>\n<li>安裝 Magisk</li>\n<li>安裝 SmaliPatcher</li>\n<li>安裝 SafetyNet Fix</li>\n<li>安裝並設定 GPS JoyStick</li>\n<li>玩</li>\n</ol>\n<p>手機應該不一定要是 S7 也可以照著這些思路完成。</p>\n<h2>手機事前準備</h2>\n<p>開啟 USB 偵錯和 OEM 解鎖。</p>\n<p>看完本文，並可以先把會用到的東西都下載下來。</p>\n<h2>刷入 TWRP</h2>\n<ol>\n<li>進入 Download Mode</li>\n<li>用 Odin 寫入 TWRP Recovery</li>\n<li>進入 TWRP</li>\n</ol>\n<p>下載最新的 Odin 版本 (目前是 3.13.1)，<a href=\"https://odindownload.com/\">Odin 官網</a></p>\n<p>下載 <a href=\"https://twrp.me/samsung/samsunggalaxys7.html\">TWRP for Samsung Galaxy S7</a> (目前是 3.6.2)。</p>\n<p>將手機連上電腦，並關機後進入 Download Mode (POWER + VOL DOWN + HOME)。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4d367c79-5c09-4118-6b49-f09f918b8600/public\" alt=\"img\"></p>\n<p>開啟 Odin 並點 AP 選擇刷入 TWRP 檔案，關閉 Auto Reboot 後 Start，應該只要幾秒就會完成。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/dacd3ce6-e43e-490d-0a1f-4f6b430e7800/public\" alt=\"img\"></p>\n<p>強制關機 (POWER + VOL DOWN + HOME) 螢幕黑掉後馬上把音量鍵下換成音量鍵上 (POWER + VOL UP + HOME) 進入 Recovery Mode，如果到目前為止都成功的話應該就會看到 TWRP 的介面。</p>\n<h2>刷入 Pixle Experience ROM</h2>\n<p>下載 <a href=\"https://download.pixelexperience.org/herolte\">Galaxy S7 Pixle Experience</a>，目前最新版本是 (20210923-1530)。</p>\n<p>進入 TWRP 先 Wipe 四個分區：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/eed93d6e-153c-43d5-eac0-7eceeee50b00/public\" alt=\"img\"></p>\n<p>如果 Wipe 失敗且是因為沒辦法 mount data，可以參考<a href=\"https://forum.xda-developers.com/t/how-to-fix-unable-to-mount-data-internal-storage-0mb-in-twrp-permanently.3830897/\">這篇文章</a>。</p>\n<p>接下來可以選擇先將 ROM 放入 SD 卡，或是直接用 adb 命令刷 (電腦當然要裝好 adb，最快的方法還是用 Chocolatey)，我自己是直接用 adb 的命令刷。在 TWRP 主畫面選 Advanced，然後使用 ADB Sideload。</p>\n<p>開啟電腦 Terminal，cd 到放剛剛下載的 ROM 的目錄，並輸入以下命令 (檔名記得替換自己的)：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">adb sideload .\\PixelExperience_herolte-11.0-20210923-1530-OFFICIAL.zip</code></pre></div>\n<p>這個會是全部耗費最久的步驟，要有耐心地等久一點。</p>\n<p>完成後 Reboot 沒問題的話，等一兩分鐘 (官方好像是說 15 分鐘內，但我沒遇到那麼久) 應該就可以進入到系統。進入到系統後可以先做一些手機的初始化，確定手機使用上沒甚麼大問題後，可以先到 Google Play 下載 Pokemon Go 再繼續。</p>\n<h2>安裝 Magisk</h2>\n<p><a href=\"https://magiskmanager.com/\">Magisk</a> 是所有 Root 玩家應該都會用到的好東西，應該也是下載最新版就可以(目前是 25.1)。下載後要將副檔名改成 zip。可以用手機直接下載，或是用電腦下載後用 adb 命令 push 到手機中，我還是選擇用 adb，指令如下。：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">adb push magisk.zip /sdcard/Download</code></pre></div>\n<p>關機後再次進入 TWRP，這次選擇 Install，並安裝剛剛 push 到手機中的 Magisk.zip。安裝後重開機，再開啟 Magisk App 完成安裝。</p>\n<p>安裝完成 Magisk 後，進入 Magisk 右上角的設定，選擇隱藏 Magisk，取一個自己喜歡的名字，避免被 Pokemon Go 偵測到 Magisk 的存在。</p>\n<p>最後開啟兩個選項：Zygisk、強制黑名單，開啟這兩個選項後，需要再次重開機，並在<strong>設定黑名單選項</strong>中把 Pokemon Go (Pokemon Go App 好像有兩個 Package name 記得都要勾) 選擇起來。</p>\n<h2>安裝 SmaliPatcher 和 SafetyNet Fix</h2>\n<p>SmaliPatcher 是為了讓 Pokemon Go 偵測不到手機是用模擬的位置，SafetyNet 好像是讓 Pokemon Go 偵測不到有 Root (這我不是很確定，我只知道不裝進不了遊戲)</p>\n<p>繼續將手機連機到電腦，用點腦下載 <a href=\"https://forum.xda-developers.com/t/module-smali-patcher-7-4.3680053/\">SamliPatcher</a>(目前最新是 0.0.7.4)，解壓縮後是個執行檔，用系統管理員的身分執行，並勾如圖的選項 (我是勾了這三個，但聽說好像只勾第一個也可以)：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/5678afd4-b35f-4d1b-94ec-f12496862700/public\" alt=\"img\"></p>\n<p>確定手機連接到電腦後按下 ADD PATCH，這會需要跑一陣子，也需要有點內心的等候，完成會在執行檔的目錄拿到一個檔名類似 SmaliPatcherModule 的壓縮檔，一樣可以用剛剛的 adb 命令 push 到手機中，最後用 Magisk 安裝這個模組後重開機即可。</p>\n<blockquote>\n<p>SmaliPatcher 截至目前是不支援 Android 12 的，我因為這個坑卡了整個下午，Pokemon Go 都會偵測到模擬位置</p>\n</blockquote>\n<p>最後一個要安裝的東西，<a href=\"https://github.com/kdrag0n/safetynet-fix/releases\">SafetyNet Fix</a> (目前版本是 2.3.1)，可用剛剛的方式在電腦下載 zip 後 push 到手機，或是直接在手機下載，然後還是用 Magisk 安裝模組重開機即可。</p>\n<h2>設定 GPS JoyStick</h2>\n<p>不要從 Google Play 下載 GPS JoyStick，到他的<a href=\"http://gpsjoystick.theappninjas.com/\">官網</a>下載 Unlock Version (最新版本是 4.3.2)。</p>\n<p>開啟 GPS JoyStick 會看到一個隱私模式，這也是為了避免被 Pokemon Go 偵測到這個 App 的存在，所以也是自己開心取個名字重新安裝。</p>\n<p>到設定中關閉 <code class=\"language-text\">啟用間接模擬</code>，這選項預設是開啟的，一定要把它關閉。然後到開發人員選項中把模擬位置的選項設定成自己的 JoyStick 名字。</p>\n<h2>開啟 Pokemon Go</h2>\n<p>無須設定，大功告成</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://download.pixelexperience.org/herolte\">Galaxy S7 Pixle Experience</a></li>\n<li><a href=\"https://odindownload.com/\">Odin</a></li>\n<li><a href=\"https://twrp.me/samsung/samsunggalaxys7.html\">TWRP for Samsung Galaxy S7</a></li>\n<li><a href=\"https://magiskmanager.com/\">Magisk</a></li>\n<li><a href=\"https://forum.xda-developers.com/t/module-smali-patcher-7-4.3680053/\">SamliPatcher</a></li>\n<li><a href=\"http://gpsjoystick.theappninjas.com/\">GPS JoyStick</a></li>\n</ul>","rawMarkdownBody":"\n今天把一台古老的 Samsung Galaxy S7 從 Android 6M 刷上 Android 11R，使用 Pixle Experience ROM，並安裝 Magisk 和 GPS JoyStick 來玩 Pokemon Go。過程不難，一步步做就不會出錯，從 Andoird 6 升到 11 也沒有早成手機有明顯卡頓，佩服作者。\n\n<!--more-->\n\n這次的動機主要是 Pokemon Go 最近開始不支援 Android 6 以下的裝置遊玩，只好升級原本的裝置。\n\n## 步驟概覽\n\n1. 刷入 TWRP\n2. 刷入 Pixle Experience\n3. 安裝 Magisk\n4. 安裝 SmaliPatcher\n5. 安裝 SafetyNet Fix\n6. 安裝並設定 GPS JoyStick\n7. 玩\n\n手機應該不一定要是 S7 也可以照著這些思路完成。\n\n## 手機事前準備\n\n開啟 USB 偵錯和 OEM 解鎖。\n\n看完本文，並可以先把會用到的東西都下載下來。\n\n## 刷入 TWRP\n\n1. 進入 Download Mode\n2. 用 Odin 寫入 TWRP Recovery\n3. 進入 TWRP\n\n下載最新的 Odin 版本 (目前是 3.13.1)，[Odin 官網](https://odindownload.com/)\n\n下載 [TWRP for Samsung Galaxy S7](https://twrp.me/samsung/samsunggalaxys7.html) (目前是 3.6.2)。\n\n將手機連上電腦，並關機後進入 Download Mode (POWER + VOL DOWN + HOME)。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4d367c79-5c09-4118-6b49-f09f918b8600/public)\n\n開啟 Odin 並點 AP 選擇刷入 TWRP 檔案，關閉 Auto Reboot 後 Start，應該只要幾秒就會完成。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/dacd3ce6-e43e-490d-0a1f-4f6b430e7800/public)\n\n強制關機 (POWER + VOL DOWN + HOME) 螢幕黑掉後馬上把音量鍵下換成音量鍵上 (POWER + VOL UP + HOME) 進入 Recovery Mode，如果到目前為止都成功的話應該就會看到 TWRP 的介面。\n\n## 刷入 Pixle Experience ROM\n\n下載 [Galaxy S7 Pixle Experience](https://download.pixelexperience.org/herolte)，目前最新版本是 (20210923-1530)。\n\n進入 TWRP 先 Wipe 四個分區：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/eed93d6e-153c-43d5-eac0-7eceeee50b00/public)\n\n如果 Wipe 失敗且是因為沒辦法 mount data，可以參考[這篇文章](https://forum.xda-developers.com/t/how-to-fix-unable-to-mount-data-internal-storage-0mb-in-twrp-permanently.3830897/)。\n\n接下來可以選擇先將 ROM 放入 SD 卡，或是直接用 adb 命令刷 (電腦當然要裝好 adb，最快的方法還是用 Chocolatey)，我自己是直接用 adb 的命令刷。在 TWRP 主畫面選 Advanced，然後使用 ADB Sideload。\n\n開啟電腦 Terminal，cd 到放剛剛下載的 ROM 的目錄，並輸入以下命令 (檔名記得替換自己的)：\n\n```sh\nadb sideload .\\PixelExperience_herolte-11.0-20210923-1530-OFFICIAL.zip\n```\n\n這個會是全部耗費最久的步驟，要有耐心地等久一點。\n\n完成後 Reboot 沒問題的話，等一兩分鐘 (官方好像是說 15 分鐘內，但我沒遇到那麼久) 應該就可以進入到系統。進入到系統後可以先做一些手機的初始化，確定手機使用上沒甚麼大問題後，可以先到 Google Play 下載 Pokemon Go 再繼續。\n\n## 安裝 Magisk\n\n[Magisk](https://magiskmanager.com/) 是所有 Root 玩家應該都會用到的好東西，應該也是下載最新版就可以(目前是 25.1)。下載後要將副檔名改成 zip。可以用手機直接下載，或是用電腦下載後用 adb 命令 push 到手機中，我還是選擇用 adb，指令如下。：\n\n```sh\nadb push magisk.zip /sdcard/Download\n```\n\n關機後再次進入 TWRP，這次選擇 Install，並安裝剛剛 push 到手機中的 Magisk.zip。安裝後重開機，再開啟 Magisk App 完成安裝。\n\n安裝完成 Magisk 後，進入 Magisk 右上角的設定，選擇隱藏 Magisk，取一個自己喜歡的名字，避免被 Pokemon Go 偵測到 Magisk 的存在。\n\n最後開啟兩個選項：Zygisk、強制黑名單，開啟這兩個選項後，需要再次重開機，並在**設定黑名單選項**中把 Pokemon Go (Pokemon Go App 好像有兩個 Package name 記得都要勾) 選擇起來。\n\n## 安裝 SmaliPatcher 和 SafetyNet Fix\n\nSmaliPatcher 是為了讓 Pokemon Go 偵測不到手機是用模擬的位置，SafetyNet 好像是讓 Pokemon Go 偵測不到有 Root (這我不是很確定，我只知道不裝進不了遊戲)\n\n繼續將手機連機到電腦，用點腦下載 [SamliPatcher](https://forum.xda-developers.com/t/module-smali-patcher-7-4.3680053/)(目前最新是 0.0.7.4)，解壓縮後是個執行檔，用系統管理員的身分執行，並勾如圖的選項 (我是勾了這三個，但聽說好像只勾第一個也可以)：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/5678afd4-b35f-4d1b-94ec-f12496862700/public)\n\n確定手機連接到電腦後按下 ADD PATCH，這會需要跑一陣子，也需要有點內心的等候，完成會在執行檔的目錄拿到一個檔名類似 SmaliPatcherModule 的壓縮檔，一樣可以用剛剛的 adb 命令 push 到手機中，最後用 Magisk 安裝這個模組後重開機即可。\n\n> SmaliPatcher 截至目前是不支援 Android 12 的，我因為這個坑卡了整個下午，Pokemon Go 都會偵測到模擬位置\n\n最後一個要安裝的東西，[SafetyNet Fix](https://github.com/kdrag0n/safetynet-fix/releases) (目前版本是 2.3.1)，可用剛剛的方式在電腦下載 zip 後 push 到手機，或是直接在手機下載，然後還是用 Magisk 安裝模組重開機即可。\n\n## 設定 GPS JoyStick\n\n不要從 Google Play 下載 GPS JoyStick，到他的[官網](http://gpsjoystick.theappninjas.com/)下載 Unlock Version (最新版本是 4.3.2)。\n\n開啟 GPS JoyStick 會看到一個隱私模式，這也是為了避免被 Pokemon Go 偵測到這個 App 的存在，所以也是自己開心取個名字重新安裝。\n\n到設定中關閉 `啟用間接模擬`，這選項預設是開啟的，一定要把它關閉。然後到開發人員選項中把模擬位置的選項設定成自己的 JoyStick 名字。\n\n## 開啟 Pokemon Go\n\n無須設定，大功告成\n\n## Reference\n\n- [Galaxy S7 Pixle Experience](https://download.pixelexperience.org/herolte)\n- [Odin](https://odindownload.com/)\n- [TWRP for Samsung Galaxy S7](https://twrp.me/samsung/samsunggalaxys7.html)\n- [Magisk](https://magiskmanager.com/)\n- [SamliPatcher](https://forum.xda-developers.com/t/module-smali-patcher-7-4.3680053/)\n- [GPS JoyStick](http://gpsjoystick.theappninjas.com/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Android/S7 Poekmon Root.md","excerpt":"今天把一台古老的 Samsung Galaxy S7 從 Android 6M 刷上 Android 11R，使用 Pixle Experience ROM，並安裝 Magisk 和 GPS JoyStick 來玩 Pokemon Go。過程不難，一步步做就不會出錯，從 Andoird 6 升到 11 也沒有早成手機有明顯卡頓，佩服作者。 這次的動機主要是 Pokemon Go 最近開始不支援 …","frontmatter":{"title":"S7 刷 Android 11 + Pokemon Go 飛人簡單紀錄","date":"2022-07-17T13:39:39.000Z","draft":false,"tags":["android","samsung","s7","twrp","pokemon","joystick","gps","pixle","magisk","odin"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d0d9494e-6a67-4237-77aa-c4d7f059b400/public","description":null}}},{"node":{"id":"497c64d1-c2d9-57b6-bd9f-9c60e6829fa5","html":"<p>紀錄一下網站成效</p>\n<!--more-->\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/7e18d41e-67cc-45cb-92fc-2e1373ba2a00/public\" alt=\"img\"></p>\n<p>兩篇成效意外好的坑</p>\n<blockquote>\n<p>廢文沒錯</p>\n</blockquote>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://search.google.com/\">Google Search Console</a></li>\n</ul>","rawMarkdownBody":"\n紀錄一下網站成效\n\n<!--more-->\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/7e18d41e-67cc-45cb-92fc-2e1373ba2a00/public)\n\n兩篇成效意外好的坑\n\n> 廢文沒錯\n\n## Reference\n\n- [Google Search Console](https://search.google.com/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Blog/20220708 review.md","excerpt":"紀錄一下網站成效 img 兩篇成效意外好的坑 廢文沒錯 Reference Google Search Console","frontmatter":{"title":"本站 2022/7/8 成效紀錄","date":"2022-07-08T05:24:40.177Z","draft":false,"tags":["blog","gatsby","google","search"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/46de886b-02a6-48d1-e5f5-1486881dcc00/public","description":null}}}]}},"pageContext":{"limit":8,"skip":0,"numPages":5,"currentPage":1}},"staticQueryHashes":[]}