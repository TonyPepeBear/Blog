{"componentChunkName":"component---src-templates-article-list-page-template-tsx","path":"/pages/3","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"9c3da1a2-833a-52a8-9d4e-e9194f199199","html":"<p>Telegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。</p>\n<!--more-->\n<h2>新增自己的 Bot</h2>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/fbf36cb0-84f4-4f7a-2553-04ecccf44800/public\" alt=\"image\"></p>\n<p>Telegram 非常有趣，要新增自己的 Bot，只要跟 Telegram 上的 <a href=\"https://telegram.me/BotFather\">BotFather</a> <code class=\"language-text\">說一下</code>，他就會給你一個 Bot。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9200bc38-828c-4ad4-a022-d34c3a692d00/public\" alt=\"image\"></p>\n<p>按 BotFather 給你的步驟做，最後可以看到他會提供一個 API Token 給你，只要有這個 Token 就可以跟 Bot 溝通，要保存好，等等會用到，也不要給別人看到，以免自己的 Bot 變成別人的玩具。</p>\n<h2>go-telegram-bot-api</h2>\n<p>Go 已經有社區開發的函式庫可以用 <a href=\"https://github.com/go-telegram-bot-api/telegram-bot-api\">telegram-bot-api</a>。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">go get -u github.com/go-telegram-bot-api/telegram-bot-api/v5\n</code></pre></div>\n<p>之後只要 import 就可以使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    tgbotapi <span class=\"token string\">\"github.com/go-telegram-bot-api/telegram-bot-api/v5\"</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<h2>連線到 Telegram Bot</h2>\n<p>利用剛剛 import 的函式庫，只需要剛剛創建好的 Bot 的 API Token 就可以連線到 Telegram。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">bot<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewBotAPI</span><span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span><span class=\"token function\">Getenv</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TELEGRAM_API_TOKEN\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面用環境變數的方式來取得 TOKEN，避免需要直接寫在程式碼裡，如果覺得在測試時設定環境變數很麻煩，可以用 JetBrains 的 <a href=\"https://www.jetbrains.com/go/\">GoLand</a>，設定 Runtime 的環境變數：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9af5d8a5-3504-479d-ab04-f8b0adf93500/public\" alt=\"image\"></p>\n<h2>處理 Update</h2>\n<p>要接收使用者傳過來的訊息，Telegram API 稱為 Update，我們使用的函示庫基本上都自動處理好了，只需要接收一個 Channel 就好。使用 <code class=\"language-text\">bot.GetUpdatesChan(config)</code> 會需要給一個 Config，這可以用 <code class=\"language-text\">tgbotapi.NewUpdate(0)</code> 來生，然後這邊設定 Timeout 為 60，如果對這個設定值有興趣，可以去看 Telegram 的文件。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">updateConfig <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewUpdate</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\nupdateConfig<span class=\"token punctuation\">.</span>Timeout <span class=\"token operator\">=</span> <span class=\"token number\">60</span>\nupdates <span class=\"token operator\">:=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">GetUpdatesChan</span><span class=\"token punctuation\">(</span>updateConfig<span class=\"token punctuation\">)</span></code></pre></div>\n<h2>回復</h2>\n<p>我們先簡單寫一隻鸚鵡，把用戶傳過來的 Text，直接傳回去。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/19bbc73e-3090-4a0d-0eec-d65671c01900/public\" alt=\"image\"></p>\n<p>用 for 把 Channel 中的 Update 一個一個拿出來，然後用 <code class=\"language-text\">tgbotapi</code> 產生一個 Message 物件，裡面放在聊天室的 ID 和要回傳的 Text，最後用 bot 把 Message 傳回去。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> update <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> updates <span class=\"token punctuation\">{</span>\n    text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n    chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n    replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n    <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>簡單鸚鵡的完整程式碼</h2>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    tgbotapi <span class=\"token string\">\"github.com/go-telegram-bot-api/telegram-bot-api/v5\"</span>\n    <span class=\"token string\">\"os\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    bot<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewBotAPI</span><span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span><span class=\"token function\">Getenv</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TELEGRAM_API_TOKEN\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    bot<span class=\"token punctuation\">.</span>Debug <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    updateConfig <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewUpdate</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    updateConfig<span class=\"token punctuation\">.</span>Timeout <span class=\"token operator\">=</span> <span class=\"token number\">60</span>\n    updates <span class=\"token operator\">:=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">GetUpdatesChan</span><span class=\"token punctuation\">(</span>updateConfig<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> update <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> updates <span class=\"token punctuation\">{</span>\n        text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n        chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n        replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n        <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>改寫成非阻塞的 Goroutine</h2>\n<p>因為每次處理和回復都會需要一點時間，甚至是要去 DB 找資料，如果用上面的寫法，在處理多人或高速傳訊息的時候會被卡住，一次只能處理的一個訊息。還好 Go 的併發寫法非常簡單，只要放一個 go 在前面，就可以非阻塞的執行 function 中的內容。</p>\n<p>我們先把 <code class=\"language-text\">handleUpdate</code> 提取成一個 function，然後再用 go 去執行他：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    bot<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewBotAPI</span><span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span><span class=\"token function\">Getenv</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TELEGRAM_API_TOKEN\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    bot<span class=\"token punctuation\">.</span>Debug <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    updateConfig <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewUpdate</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    updateConfig<span class=\"token punctuation\">.</span>Timeout <span class=\"token operator\">=</span> <span class=\"token number\">60</span>\n    updates <span class=\"token operator\">:=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">GetUpdatesChan</span><span class=\"token punctuation\">(</span>updateConfig<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> update <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> updates <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">go</span> <span class=\"token function\">handleUpdate</span><span class=\"token punctuation\">(</span>bot<span class=\"token punctuation\">,</span> update<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">handleUpdate</span><span class=\"token punctuation\">(</span>bot <span class=\"token operator\">*</span>tgbotapi<span class=\"token punctuation\">.</span>BotAPI<span class=\"token punctuation\">,</span> update tgbotapi<span class=\"token punctuation\">.</span>Update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n    chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n    replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n    <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>回復特定訊息</h2>\n<p>要回復 <code class=\"language-text\">回復訊息</code> ，像是下面的效果也很簡單：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/22010000-e325-45e6-52f9-64eec6b28500/public\" alt=\"image\"></p>\n<p>只需要設定 <code class=\"language-text\">replyMsg.ReplyToMessageID</code> 就可以回復特定的訊息，下面就是直接回覆接收到的訊息：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">handleUpdate</span><span class=\"token punctuation\">(</span>bot <span class=\"token operator\">*</span>tgbotapi<span class=\"token punctuation\">.</span>BotAPI<span class=\"token punctuation\">,</span> update tgbotapi<span class=\"token punctuation\">.</span>Update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n    chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n    replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n    replyMsg<span class=\"token punctuation\">.</span>ReplyToMessageID <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>MessageID\n    <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>處理 Command</h2>\n<p>Telegram 中，用 <code class=\"language-text\">/</code> 開頭的文字就是 Command，這個函示庫也有寫好處理 Command 的方法，只需要用 <code class=\"language-text\">isCommand()</code>，確認一下是不是 Command 就可以：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">handleUpdate</span><span class=\"token punctuation\">(</span>bot <span class=\"token operator\">*</span>tgbotapi<span class=\"token punctuation\">.</span>BotAPI<span class=\"token punctuation\">,</span> update tgbotapi<span class=\"token punctuation\">.</span>Update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n    chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n    replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span><span class=\"token function\">IsCommand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">switch</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span><span class=\"token function\">Command</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> <span class=\"token string\">\"start\"</span><span class=\"token punctuation\">:</span>\n            replyMsg<span class=\"token punctuation\">.</span>Text <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello \"</span> <span class=\"token operator\">+</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>From<span class=\"token punctuation\">.</span>FirstName\n        <span class=\"token keyword\">case</span> <span class=\"token string\">\"help\"</span><span class=\"token punctuation\">:</span>\n            replyMsg<span class=\"token punctuation\">.</span>Text <span class=\"token operator\">=</span> <span class=\"token string\">\"What can I help you?\"</span>\n        <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n            replyMsg<span class=\"token punctuation\">.</span>Text <span class=\"token operator\">=</span> <span class=\"token string\">\"No such command!!!\"</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的程式碼其實也可以看到如何拿到傳送者的一些基本資料。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0fd54240-5c18-4b75-c7be-981cdb144e00/public\" alt=\"image\"></p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://core.telegram.org/\">Telegram APIs</a></li>\n<li><a href=\"https://github.com/go-telegram-bot-api/telegram-bot-api\">Golang bindings for the Telegram Bot API - GitHub</a></li>\n</ul>","rawMarkdownBody":"\nTelegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。\n\n<!--more-->\n\n## 新增自己的 Bot\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/fbf36cb0-84f4-4f7a-2553-04ecccf44800/public)\n\nTelegram 非常有趣，要新增自己的 Bot，只要跟 Telegram 上的 [BotFather](https://telegram.me/BotFather) `說一下`，他就會給你一個 Bot。\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9200bc38-828c-4ad4-a022-d34c3a692d00/public)\n\n按 BotFather 給你的步驟做，最後可以看到他會提供一個 API Token 給你，只要有這個 Token 就可以跟 Bot 溝通，要保存好，等等會用到，也不要給別人看到，以免自己的 Bot 變成別人的玩具。\n\n## go-telegram-bot-api\n\nGo 已經有社區開發的函式庫可以用 [telegram-bot-api](https://github.com/go-telegram-bot-api/telegram-bot-api)。\n\n```shell\ngo get -u github.com/go-telegram-bot-api/telegram-bot-api/v5\n\n```\n\n之後只要 import 就可以使用：\n\n```go\nimport (\n    tgbotapi \"github.com/go-telegram-bot-api/telegram-bot-api/v5\"\n)\n```\n\n## 連線到 Telegram Bot\n\n利用剛剛 import 的函式庫，只需要剛剛創建好的 Bot 的 API Token 就可以連線到 Telegram。\n\n```go\nbot, err := tgbotapi.NewBotAPI(os.Getenv(\"TELEGRAM_API_TOKEN\"))\nif err != nil {\n    panic(err)\n}\n```\n\n上面用環境變數的方式來取得 TOKEN，避免需要直接寫在程式碼裡，如果覺得在測試時設定環境變數很麻煩，可以用 JetBrains 的 [GoLand](https://www.jetbrains.com/go/)，設定 Runtime 的環境變數：\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9af5d8a5-3504-479d-ab04-f8b0adf93500/public)\n\n## 處理 Update\n\n要接收使用者傳過來的訊息，Telegram API 稱為 Update，我們使用的函示庫基本上都自動處理好了，只需要接收一個 Channel 就好。使用 `bot.GetUpdatesChan(config)` 會需要給一個 Config，這可以用 `tgbotapi.NewUpdate(0)` 來生，然後這邊設定 Timeout 為 60，如果對這個設定值有興趣，可以去看 Telegram 的文件。\n\n```go\nupdateConfig := tgbotapi.NewUpdate(0)\nupdateConfig.Timeout = 60\nupdates := bot.GetUpdatesChan(updateConfig)\n```\n\n## 回復\n\n我們先簡單寫一隻鸚鵡，把用戶傳過來的 Text，直接傳回去。\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/19bbc73e-3090-4a0d-0eec-d65671c01900/public)\n\n用 for 把 Channel 中的 Update 一個一個拿出來，然後用 `tgbotapi` 產生一個 Message 物件，裡面放在聊天室的 ID 和要回傳的 Text，最後用 bot 把 Message 傳回去。\n\n```go\nfor update := range updates {\n    text := update.Message.Text\n    chatID := update.Message.Chat.ID\n    replyMsg := tgbotapi.NewMessage(chatID, text)\n    _, _ = bot.Send(replyMsg)\n}\n```\n\n## 簡單鸚鵡的完整程式碼\n\n```go\npackage main\n\nimport (\n    tgbotapi \"github.com/go-telegram-bot-api/telegram-bot-api/v5\"\n    \"os\"\n)\n\nfunc main() {\n    bot, err := tgbotapi.NewBotAPI(os.Getenv(\"TELEGRAM_API_TOKEN\"))\n    if err != nil {\n        panic(err)\n    }\n    bot.Debug = true\n    updateConfig := tgbotapi.NewUpdate(0)\n    updateConfig.Timeout = 60\n    updates := bot.GetUpdatesChan(updateConfig)\n    for update := range updates {\n        text := update.Message.Text\n        chatID := update.Message.Chat.ID\n        replyMsg := tgbotapi.NewMessage(chatID, text)\n        _, _ = bot.Send(replyMsg)\n    }\n}\n```\n\n## 改寫成非阻塞的 Goroutine\n\n因為每次處理和回復都會需要一點時間，甚至是要去 DB 找資料，如果用上面的寫法，在處理多人或高速傳訊息的時候會被卡住，一次只能處理的一個訊息。還好 Go 的併發寫法非常簡單，只要放一個 go 在前面，就可以非阻塞的執行 function 中的內容。\n\n我們先把 `handleUpdate` 提取成一個 function，然後再用 go 去執行他：\n\n```go\nfunc main() {\n    bot, err := tgbotapi.NewBotAPI(os.Getenv(\"TELEGRAM_API_TOKEN\"))\n    if err != nil {\n        panic(err)\n    }\n    bot.Debug = true\n    updateConfig := tgbotapi.NewUpdate(0)\n    updateConfig.Timeout = 60\n    updates := bot.GetUpdatesChan(updateConfig)\n    for update := range updates {\n        go handleUpdate(bot, update)\n    }\n}\n\nfunc handleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n    text := update.Message.Text\n    chatID := update.Message.Chat.ID\n    replyMsg := tgbotapi.NewMessage(chatID, text)\n    _, _ = bot.Send(replyMsg)\n}\n```\n\n## 回復特定訊息\n\n要回復 `回復訊息` ，像是下面的效果也很簡單：\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/22010000-e325-45e6-52f9-64eec6b28500/public)\n\n只需要設定 `replyMsg.ReplyToMessageID` 就可以回復特定的訊息，下面就是直接回覆接收到的訊息：\n\n```go\nfunc handleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n    text := update.Message.Text\n    chatID := update.Message.Chat.ID\n    replyMsg := tgbotapi.NewMessage(chatID, text)\n    replyMsg.ReplyToMessageID = update.Message.MessageID\n    _, _ = bot.Send(replyMsg)\n}\n```\n\n## 處理 Command\n\nTelegram 中，用 `/` 開頭的文字就是 Command，這個函示庫也有寫好處理 Command 的方法，只需要用 `isCommand()`，確認一下是不是 Command 就可以：\n\n```go\nfunc handleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n    text := update.Message.Text\n    chatID := update.Message.Chat.ID\n    replyMsg := tgbotapi.NewMessage(chatID, text)\n    if update.Message.IsCommand() {\n        switch update.Message.Command() {\n        case \"start\":\n            replyMsg.Text = \"Hello \" + update.Message.From.FirstName\n        case \"help\":\n            replyMsg.Text = \"What can I help you?\"\n        default:\n            replyMsg.Text = \"No such command!!!\"\n        }\n    }\n    _, _ = bot.Send(replyMsg)\n}\n```\n\n上面的程式碼其實也可以看到如何拿到傳送者的一些基本資料。\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0fd54240-5c18-4b75-c7be-981cdb144e00/public)\n\n## Reference\n\n- [Telegram APIs](https://core.telegram.org/)\n- [Golang bindings for the Telegram Bot API - GitHub](https://github.com/go-telegram-bot-api/telegram-bot-api)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Telegram/go-tg-bot.md","excerpt":"Telegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。 新增自己的 Bot image Telegram 非常有趣，要新增自己的 Bot，只要跟 Telegram 上的 BotFather ，他就會給你一個 Bot。 image 按 BotFather 給你的步驟做，最後可以看到他會提供一個 API Token …","frontmatter":{"title":"用 Go 寫 Telegram Bot","date":"2021-12-11T14:30:15.000Z","draft":false,"tags":["go","golang","telegram","bot","telegram-bot"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f8c04956-a2ef-4cba-b9fe-2a5ceff40b00/public","description":"Telegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。"}}},{"node":{"id":"d8fb3977-7c7f-57ad-83c2-8dc1d7ba1927","html":"<p>Flutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是 <code class=\"language-text\">() {}</code> 寫法，另一個是 <code class=\"language-text\">() =></code> 寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。</p>\n<!--more-->\n<h2>不同在哪</h2>\n<p>下面我用在寫 Flutter 中常見的創建一個有 10 個 Text 的 List 舉例。</p>\n<p>創建一個有 10 項元素的 List：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Text</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">.</span><span class=\"token function\">generate</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>上面就是輸出一個帶有 0-9 的 List，那現在假設我會需要再創建 Text 前，根據 index 來做一些改變，下面就做最簡單的平方。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Text</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">.</span><span class=\"token function\">generate</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do some work</span>\n    <span class=\"token keyword\">var</span> text <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">*</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>觀察上面兩個例子，不難發現兩個的差別，第一個寫法 <code class=\"language-text\">() =></code> 後面直接接上一個表達式(Expression)，當作回傳值。而 <code class=\"language-text\">() {}</code> 則是在大括號中寫一個完整的 Function，所以要寫一個 return。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/51868395/flutter-dart-difference-between-and\">Flutter/Dart - Difference between () {} and () => {}</a></li>\n</ul>","rawMarkdownBody":"\nFlutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是 `() {}` 寫法，另一個是 `() =>` 寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。\n\n<!--more-->\n\n## 不同在哪\n\n下面我用在寫 Flutter 中常見的創建一個有 10 個 Text 的 List 舉例。\n\n創建一個有 10 項元素的 List：\n\n```dart\nList<Text> list = List.generate(10, (index) => Text(index.toString()));\n```\n\n上面就是輸出一個帶有 0-9 的 List，那現在假設我會需要再創建 Text 前，根據 index 來做一些改變，下面就做最簡單的平方。\n\n```dart\nList<Text> list = List.generate(10, (index) {\n    // do some work\n    var text = (index * index).toString();\n    return Text(text);\n});\n```\n\n觀察上面兩個例子，不難發現兩個的差別，第一個寫法 `() =>` 後面直接接上一個表達式(Expression)，當作回傳值。而 `() {}` 則是在大括號中寫一個完整的 Function，所以要寫一個 return。\n\n## Reference\n\n- [Flutter/Dart - Difference between () {} and () => {}](https://stackoverflow.com/questions/51868395/flutter-dart-difference-between-and)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Flutter/Dart Function Lambda diff.md","excerpt":"Flutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是  寫法，另一個是  寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。 不同在哪 下面我用在寫 Flutter 中常見的創建一個有 10 個 Text 的 List 舉例。 創建一個有 10 項元素的 List： 上面就是輸出一個帶有 0-9…","frontmatter":{"title":"Flutter/Dart (){} 和 () => 的差別","date":"2021-11-04T05:52:44.000Z","draft":false,"tags":["dart","flutter","function"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f8a3eaa5-e9c2-455f-d301-43fc77fee200/large","description":"Flutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是 () {} 寫法，另一個是 () => 寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。"}}},{"node":{"id":"5a287e0a-4039-585c-b56d-03d41cb6b549","html":"<p>上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。</p>\n<!--more-->\n<blockquote>\n<p>No one likes to wait. Internet impatience is something we all suffer from.</p>\n</blockquote>\n<p>文章一開頭就用一句點出大家在上網時會遇到的狀況，沒有人喜歡等待，可是所有人都在上網時身受其害，相信大家都遇過下面的情況：</p>\n<ol>\n<li>等待 App 完成內容更新</li>\n<li>等待網頁出現</li>\n<li>等待電影開始播放</li>\n</ol>\n<p>但有寫過程式或服務的都知道，人一多，就一定慢，非常的難避免，<del>所以這時候就要用 Cloudflare</del>，這時又宣傳了一下 Cloudflare。</p>\n<p>許多使用者家裡都會覺得網路很慢，然後買了很快很快的網速，像是 100Mbpa, 1Gbps 甚至 2Gbps，但其實就算家裡的網路再怎麼快，你連線的 Server 就是很慢，你的上網體驗還是大打折扣。</p>\n<p>如果要讓自己的服務不卡，只需要完成下面三樣要求：</p>\n<ol>\n<li>Server 有充足的帶寬</li>\n<li>讓 Server 盡量接近 User</li>\n<li>讓你的 Web 或 App 盡量得快</li>\n</ol>\n<p>看起來很簡單，但如果要完成這三個要求，都會耗費極大的成本。</p>\n<h2>DNS</h2>\n<p>現今的網路世界主要是由 ipv4 組成，也就是說，如果沒有 ipv4 地址，所有的網路連線都不會發生，如果我只知道 <a href=\"www.fcu.edu.tw\">www.fcu.edu.tw</a>，是完全沒有辦法上網的，因為我並不知道這個網址對應的 ip 是多少 (像是 140.134.xxx.xxx)，就完全沒有辦法和伺服器產生連線。DNS 出現前，大家都是直接用 ip 溝通，快速方便，最大的缺點就是非常難記。所以 DNS 就出現了，DNS 就像你打電話會需要電話簿一樣，我只我需要一個簡單好記的名字，再去電話簿搜尋真正的電話號碼就好。</p>\n<p>在知道電話號碼前，所有網路連線都不會發生，所以用最快速的方式查找電話簿絕對是上網速度最重要的一環，如果光是要知道 ip 位置就花掉 50ms(甚至更多)，上網效率就會大大降低。如今網路上有許多的 DNS 提供商，為大家記下這龐大的 DNS 電話簿，最著名的就是 Google 的 <a href=\"8.8.8.8\">8.8.8.8</a>，和 Cloudflare 的 <a href=\"1.1.1.1\">1.1.1.1</a>，Cloudflare 宣稱他是全世界最快的 DNS 提供商，(雖然在台灣好像未必)，但 Cloudflare 承諾他不會<strong>紀錄</strong>使用者查過的 DNS 紀錄，或上過什麼網頁 (好像是在暗示競爭對手會這麼做)。</p>\n<p>另外，就算 DNS 伺服器完全不假思索 (沒有反應時間) 就回傳 DNS 的查詢結果，這也付出了至少一個<a href=\"#%E5%85%89%E9%80%9F%E6%90%8D%E8%80%97\"><strong>光速的代價</strong></a>，聽起來好像沒什麼影響，但可以看看下面簡單的計算。</p>\n<h3>光速損耗</h3>\n<p>假設我家和 DNS 伺服器之間的直線距離是 100 公里，而且中華電信筆直的連接了一條筆直光纖到 DNS 伺服器，而光在光纖中的速度是 200,000,000 公尺/秒，往返需要 200,000 公尺。經過這樣簡單的計算，光是光速就已經耗費整整 1 毫秒(ms)，可以試著想想看更糟的情況，光速已經開始在嚴重拖累網速。</p>\n<h2>Hello Hello OK</h2>\n<p>知道了 ip 後，瀏覽器終於可以連上目標伺服器取得網頁，不久後就可以看到網頁出現在眼前。</p>\n<p>上面的步驟，幾乎都是由 TCP 協定完成，協定的第一步就是你的電腦和伺服器互相同意連線，這個過程稱作三向交握 (Three-Way Handshake)，步驟如下：</p>\n<ol>\n<li>Client 對 Server 說：Hello</li>\n<li>Server 對 Client 說：我聽到你說 Hello</li>\n<li>Client 對 Server 說：我聽到 -- 你說你聽到我說 Hello，我們現在可以溝通了。</li>\n</ol>\n<p>從上面的步驟就可以發現，已經至少耗費了<a href=\"#%E5%85%89%E9%80%9F%E6%90%8D%E8%80%97\">一個光速的時間</a>，所以也是一樣，伺服器愈靠近用戶，網速就愈快。這也是為什麼 Cloudflare 在世界各地廣設伺服器。</p>\n<h3>TLS/SSL</h3>\n<p>有了 TCP 我們就可以安全的連線了嗎？當然不是，TCP 一點也不安全，現在的網路連線幾乎都是透過 TLS (或稱作 SSL) 加密連線，所以 TCP 連線後，下一步是建立安全的加密連線。</p>\n<p>TLS 是一個非常複雜的加密協定，會牽涉到下面的設備：網路瀏覽器、建立鑰匙的伺服器，而且還要有一個可以證明他的身分的伺服器，因為不會想要和銀行建立安全連線，但你根本不確定他是不是你的銀行。</p>\n<p>上面的步驟也會需要好幾次<a href=\"#%E5%85%89%E9%80%9F%E6%90%8D%E8%80%97\">光速損耗</a>，所以讓伺服器愈靠近用戶端愈好。另外，也要盡量使用最新的 TLS 標準 (現在是 TLS 1.3)。</p>\n<h2>後記</h2>\n<p>我覺得這篇文章最有趣的的部分就是一直在討論光速對網路連線的影響，以往我都覺得光速很快，但光就算很快，光也是要跑很長一段距離，這樣耗損來回個幾次就已經對網路連線產生極大的影響了，而且更何況一個連線就一定會需要來回溝通好幾次。這篇文章後面還有蠻多內容，但我覺得沒有那麼重要就懶得寫了，有興趣的話可以自己繼續往下看。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://blog.cloudflare.com/fastest-internet/\">Welcome to Speed Week and a Waitless Internet</a></li>\n</ul>","rawMarkdownBody":"\n上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。\n\n<!--more-->\n\n> No one likes to wait. Internet impatience is something we all suffer from.\n\n文章一開頭就用一句點出大家在上網時會遇到的狀況，沒有人喜歡等待，可是所有人都在上網時身受其害，相信大家都遇過下面的情況：\n\n1. 等待 App 完成內容更新\n2. 等待網頁出現\n3. 等待電影開始播放\n\n但有寫過程式或服務的都知道，人一多，就一定慢，非常的難避免，~~所以這時候就要用 Cloudflare~~，這時又宣傳了一下 Cloudflare。\n\n許多使用者家裡都會覺得網路很慢，然後買了很快很快的網速，像是 100Mbpa, 1Gbps 甚至 2Gbps，但其實就算家裡的網路再怎麼快，你連線的 Server 就是很慢，你的上網體驗還是大打折扣。\n\n如果要讓自己的服務不卡，只需要完成下面三樣要求：\n\n1. Server 有充足的帶寬\n2. 讓 Server 盡量接近 User\n3. 讓你的 Web 或 App 盡量得快\n\n看起來很簡單，但如果要完成這三個要求，都會耗費極大的成本。\n\n## DNS\n\n現今的網路世界主要是由 ipv4 組成，也就是說，如果沒有 ipv4 地址，所有的網路連線都不會發生，如果我只知道 [www.fcu.edu.tw](www.fcu.edu.tw)，是完全沒有辦法上網的，因為我並不知道這個網址對應的 ip 是多少 (像是 140.134.xxx.xxx)，就完全沒有辦法和伺服器產生連線。DNS 出現前，大家都是直接用 ip 溝通，快速方便，最大的缺點就是非常難記。所以 DNS 就出現了，DNS 就像你打電話會需要電話簿一樣，我只我需要一個簡單好記的名字，再去電話簿搜尋真正的電話號碼就好。\n\n在知道電話號碼前，所有網路連線都不會發生，所以用最快速的方式查找電話簿絕對是上網速度最重要的一環，如果光是要知道 ip 位置就花掉 50ms(甚至更多)，上網效率就會大大降低。如今網路上有許多的 DNS 提供商，為大家記下這龐大的 DNS 電話簿，最著名的就是 Google 的 [8.8.8.8](8.8.8.8)，和 Cloudflare 的 [1.1.1.1](1.1.1.1)，Cloudflare 宣稱他是全世界最快的 DNS 提供商，(雖然在台灣好像未必)，但 Cloudflare 承諾他不會**紀錄**使用者查過的 DNS 紀錄，或上過什麼網頁 (好像是在暗示競爭對手會這麼做)。\n\n另外，就算 DNS 伺服器完全不假思索 (沒有反應時間) 就回傳 DNS 的查詢結果，這也付出了至少一個[**光速的代價**](#光速損耗)，聽起來好像沒什麼影響，但可以看看下面簡單的計算。\n\n### 光速損耗\n\n假設我家和 DNS 伺服器之間的直線距離是 100 公里，而且中華電信筆直的連接了一條筆直光纖到 DNS 伺服器，而光在光纖中的速度是 200,000,000 公尺/秒，往返需要 200,000 公尺。經過這樣簡單的計算，光是光速就已經耗費整整 1 毫秒(ms)，可以試著想想看更糟的情況，光速已經開始在嚴重拖累網速。\n\n## Hello Hello OK\n\n知道了 ip 後，瀏覽器終於可以連上目標伺服器取得網頁，不久後就可以看到網頁出現在眼前。\n\n上面的步驟，幾乎都是由 TCP 協定完成，協定的第一步就是你的電腦和伺服器互相同意連線，這個過程稱作三向交握 (Three-Way Handshake)，步驟如下：\n\n1. Client 對 Server 說：Hello\n2. Server 對 Client 說：我聽到你說 Hello\n3. Client 對 Server 說：我聽到 -- 你說你聽到我說 Hello，我們現在可以溝通了。\n\n從上面的步驟就可以發現，已經至少耗費了[一個光速的時間](#光速損耗)，所以也是一樣，伺服器愈靠近用戶，網速就愈快。這也是為什麼 Cloudflare 在世界各地廣設伺服器。\n\n### TLS/SSL\n\n有了 TCP 我們就可以安全的連線了嗎？當然不是，TCP 一點也不安全，現在的網路連線幾乎都是透過 TLS (或稱作 SSL) 加密連線，所以 TCP 連線後，下一步是建立安全的加密連線。\n\nTLS 是一個非常複雜的加密協定，會牽涉到下面的設備：網路瀏覽器、建立鑰匙的伺服器，而且還要有一個可以證明他的身分的伺服器，因為不會想要和銀行建立安全連線，但你根本不確定他是不是你的銀行。\n\n上面的步驟也會需要好幾次[光速損耗](#光速損耗)，所以讓伺服器愈靠近用戶端愈好。另外，也要盡量使用最新的 TLS 標準 (現在是 TLS 1.3)。\n\n## 後記\n\n我覺得這篇文章最有趣的的部分就是一直在討論光速對網路連線的影響，以往我都覺得光速很快，但光就算很快，光也是要跑很長一段距離，這樣耗損來回個幾次就已經對網路連線產生極大的影響了，而且更何況一個連線就一定會需要來回溝通好幾次。這篇文章後面還有蠻多內容，但我覺得沒有那麼重要就懶得寫了，有興趣的話可以自己繼續往下看。\n\n## Reference\n\n- [Welcome to Speed Week and a Waitless Internet](https://blog.cloudflare.com/fastest-internet/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/Cloudflare Speed Week.md","excerpt":"上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。 No one likes to wait. Internet impatienc…","frontmatter":{"title":"Cloudflare Speed Week","date":"2021-10-05T16:10:58.000Z","draft":false,"tags":["cloudflare","web","internet","tcp"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/be2106f3-0557-4e94-803a-9dda63550300/public","description":"上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。"}}},{"node":{"id":"829e849f-13bc-5b82-8699-88b701b8f0e3","html":"<p>Kotlin 在非同步處理上有新的方法，協程 <code class=\"language-text\">Coroutine</code>。<code class=\"language-text\">Coroutine</code> 不會像 <code class=\"language-text\">Thread</code> 會耗費大量的資源，能在原本的<code class=\"language-text\">線程</code>上創建極為輕量的<code class=\"language-text\">協程</code>，且較不會發生記憶體洩漏的情況。</p>\n<!--more-->\n<h2>導入 Coroutine</h2>\n<p>在 <code class=\"language-text\">build.gradle</code> 中添加依賴項</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">dependencies <span class=\"token punctuation\">{</span>\n    implementation <span class=\"token string\">'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2'</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>若要在 <code class=\"language-text\">Android</code> 中使用需要再添加 <code class=\"language-text\">Android</code> 依賴</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">implementation <span class=\"token string\">'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2'</span></code></pre></div>\n<h2>第一個 Coroutine</h2>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">//在後台啟動一個新的縣協程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//非阻塞式的等待 1 秒鐘</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 阻塞主線程兩秒確保主線程存活</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的程式碼輸出結果：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">Hellow<span class=\"token punctuation\">,</span>\nWorld</code></pre></div>\n<p>基本上 <code class=\"language-text\">Coroutine</code> 就是輕量的協程</p>\n<p>也可以分別將 <code class=\"language-text\">GlobalScope.launch{...}</code> 和 <code class=\"language-text\">delay(...)</code> 替換成<code class=\"language-text\">thread { ... }</code> 和 <code class=\"language-text\">Thread.Sleap(...)</code>，也可以得到相同的結果，可以嘗試一下。</p>\n<p>如果只將 <code class=\"language-text\">GlobalScope.launch{...}</code> 替換成 <code class=\"language-text\">thread{...}</code> 你會得到以下錯誤：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another <span class=\"token function\">suspend</span> <span class=\"token keyword\">function</span></code></pre></div>\n<p>因為 <code class=\"language-text\">delay()</code> 是一個特殊的 <code class=\"language-text\">suspend function</code> (有人譯作 <code class=\"language-text\">掛起函數</code>)，他不會阻塞線程，但是會 <code class=\"language-text\">suspend</code> 協程，而且只能在協程中使用。</p>\n<h2>橋接阻塞和非阻塞的世界</h2>\n<p>上面的範例中同時使用了非阻塞式的 <code class=\"language-text\">delay()</code> 和阻塞式的 <code class=\"language-text\">Thread.sleap()</code>，這樣很容易讓我們混淆哪個會阻塞線程。下面我們使用 <code class=\"language-text\">runblocking{...}</code> 來阻塞線程</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 在後台啟動一個新的協程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    runBlocking <span class=\"token punctuation\">{</span>     <span class=\"token comment\">// 這個表達式會阻塞主線程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 延遲兩秒來確保主線程存活</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>結果基本上是相似的，只是都是使用了非組塞式的 <code class=\"language-text\">delay()</code>。調用了 <code class=\"language-text\">runblocking{...}</code> 的主線程會被阻塞直到 <code class=\"language-text\">runblocking{...}</code> 內的協程執行完畢。</p>\n<p>下面用一個更合乎慣用法的方法在寫一次，用 <code class=\"language-text\">runblocking{...}</code> 來包裝 <code class=\"language-text\">main</code> 方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 開始執行主協程</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 在後台啓動一個協程並繼續執行</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 延遲 2 秒來確保主線程存活</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這裡的 <code class=\"language-text\">runBlocking {...}</code> 用來啟動主線程。我們顯式指定了其返回類型 <code class=\"language-text\">Unit</code>，因為在 Kotlin 中 <code class=\"language-text\">main</code> 方法必須回傳 <code class=\"language-text\">Unit</code>。</p>\n<h2>等待一個作業完成</h2>\n<p>延遲一段時間來確保協程的運行並不是一個好辦法利用 <code class=\"language-text\">job.join()</code> 來確保工作執行結束。</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job<span class=\"token operator\">:</span> Job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">launch</code> 會回傳一個 <code class=\"language-text\">Job</code> 物件，而 <code class=\"language-text\">job.join()</code> 其實就是會等待 <code class=\"language-text\">job</code> 的工作完成再繼續持行。</p>\n<p>我們也可以利用 <code class=\"language-text\">job.cancel()</code> 取消協程：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job<span class=\"token operator\">:</span> Job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>但是如果 <code class=\"language-text\">job</code> 已經完成工作，<code class=\"language-text\">cancel</code> 是不會發生任何事。</p>\n<h2>參考資料</h2>\n<ul>\n<li><a href=\"https://kotlinlang.org/docs/reference/coroutines/basics.html\">Coroutine Basics</a></li>\n</ul>","rawMarkdownBody":"\nKotlin 在非同步處理上有新的方法，協程 `Coroutine`。`Coroutine` 不會像 `Thread` 會耗費大量的資源，能在原本的`線程`上創建極為輕量的`協程`，且較不會發生記憶體洩漏的情況。\n\n<!--more-->\n\n## 導入 Coroutine\n\n在 `build.gradle` 中添加依賴項\n\n```groovy\ndependencies {\n    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2'\n}\n```\n\n若要在 `Android` 中使用需要再添加 `Android` 依賴\n\n```groovy\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2'\n```\n\n## 第一個 Coroutine\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { //在後台啟動一個新的縣協程\n        delay(1000L) //非阻塞式的等待 1 秒鐘\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    Thread.sleep(2000L) // 阻塞主線程兩秒確保主線程存活\n}\n```\n\n上面的程式碼輸出結果：\n\n```kotlin\nHellow,\nWorld\n```\n\n基本上 `Coroutine` 就是輕量的協程\n\n也可以分別將 `GlobalScope.launch{...}` 和 `delay(...)` 替換成`thread { ... }` 和 `Thread.Sleap(...)`，也可以得到相同的結果，可以嘗試一下。\n\n如果只將 `GlobalScope.launch{...}` 替換成 `thread{...}` 你會得到以下錯誤：\n\n```shell\nError: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function\n```\n\n因為 `delay()` 是一個特殊的 `suspend function` (有人譯作 `掛起函數`)，他不會阻塞線程，但是會 `suspend` 協程，而且只能在協程中使用。\n\n## 橋接阻塞和非阻塞的世界\n\n上面的範例中同時使用了非阻塞式的 `delay()` 和阻塞式的 `Thread.sleap()`，這樣很容易讓我們混淆哪個會阻塞線程。下面我們使用 `runblocking{...}` 來阻塞線程\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { // 在後台啟動一個新的協程\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    runBlocking {     // 這個表達式會阻塞主線程\n        delay(2000L)  // 延遲兩秒來確保主線程存活\n    }\n}\n```\n\n結果基本上是相似的，只是都是使用了非組塞式的 `delay()`。調用了 `runblocking{...}` 的主線程會被阻塞直到 `runblocking{...}` 內的協程執行完畢。\n\n下面用一個更合乎慣用法的方法在寫一次，用 `runblocking{...}` 來包裝 `main` 方法：\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> { // 開始執行主協程\n    GlobalScope.launch { // 在後台啓動一個協程並繼續執行\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    delay(2000L)  // 延遲 2 秒來確保主線程存活\n}\n```\n\n這裡的 `runBlocking {...}` 用來啟動主線程。我們顯式指定了其返回類型 `Unit`，因為在 Kotlin 中 `main` 方法必須回傳 `Unit`。\n\n## 等待一個作業完成\n\n延遲一段時間來確保協程的運行並不是一個好辦法利用 `job.join()` 來確保工作執行結束。\n\n```kotlin\nval job: Job = GlobalScope.launch {\n    delay(1000L)\n    println(\"World!\")\n}\nprintln(\"Hello,\")\njob.join()\n```\n\n`launch` 會回傳一個 `Job` 物件，而 `job.join()` 其實就是會等待 `job` 的工作完成再繼續持行。\n\n我們也可以利用 `job.cancel()` 取消協程：\n\n```kotlin\nval job: Job = GlobalScope.launch {\n    delay(1000L)\n    println(\"World!\")\n}\nprintln(\"Hello,\")\njob.cancel()\n```\n\n但是如果 `job` 已經完成工作，`cancel` 是不會發生任何事。\n\n## 參考資料\n\n- [Coroutine Basics](https://kotlinlang.org/docs/reference/coroutines/basics.html)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Kotlin/kotlin coroutine.md","excerpt":"Kotlin 在非同步處理上有新的方法，協程 。 不會像  會耗費大量的資源，能在原本的上創建極為輕量的，且較不會發生記憶體洩漏的情況。 導入 Coroutine 在  中添加依賴項 若要在  中使用需要再添加  依賴 第一個 Coroutine 上面的程式碼輸出結果： 基本上  就是輕量的協程 也可以分別將  和  替換成 和 ，也可以得到相同的結果，可以嘗試一下。 如果只將  替換成  你會…","frontmatter":{"title":"Kotlin Coroutine","date":"2021-09-19T07:26:56.000Z","draft":false,"tags":["kotlin","coroutine"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6f11a63e-3923-4ce5-3b6e-d06243815300/public","description":"Kotlin 在非同步處理上有新的方法，協程 Coroutine，Coroutine 不會像 Thread 會耗費大量的資源，能在原本的線程上創建極為輕量的協程，且較不會發生記憶體洩漏的情況。"}}},{"node":{"id":"c18c63aa-34a1-5207-8f88-2ab72f9491df","html":"<p>要在一個 Git 專案中有子專案 (我都叫他 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄 submodule 的路徑和 commit 版本。</p>\n<!--more-->\n<h2>Add Submodule</h2>\n<p>要將專案新增到現有的目錄中，可以使用 <code class=\"language-text\">git submodule add</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> submodule <span class=\"token function\">add</span> <span class=\"token operator\">&lt;</span>repo_url<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>folder<span class=\"token operator\">></span></code></pre></div>\n<p>執行後，可以看到 git 會自動幫你把 submodule clone 到指定的目錄中，並多了一個檔案 <code class=\"language-text\">.gitmodules</code>，這個檔案就是上面說到的 Submodule 只紀錄 commit 版本，和 Submodule URL 的檔案。</p>\n<p>add submodule 後，還是要 commit，因為 Submodule 也就只是紀錄要用子專案的哪一個 commit 版本，所以也可以確保大家都是使用到同一個 Submodule 的版本。可以試著將專案 commit and push 到 GitHub 上，應該可以看到 Submodule 就是連結到另外一個專案的某一個 commit，下面是本站的 Hugo 主題的 submodule：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c4ba8819-787e-4726-fb58-db317f9ed400/public\" alt=\"image\"></p>\n<h2>Clone Submodule</h2>\n<p>在 Clone 含有 Submodule 的專案時，Git 預設是不會自動 clone 子專案的，需要加上 <code class=\"language-text\">--recursive</code> 這個參數，才會自動把 Submodule 也 Clone 下來。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> clone --recursive <span class=\"token operator\">&lt;</span>repo_url<span class=\"token operator\">></span></code></pre></div>\n<p>如果 Clone 下來後才發現有 Submodule，可以用下面的方式補救，把子專案都 Clone 下來：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> submodule init\n<span class=\"token function\">git</span> submodule update --recursive</code></pre></div>","rawMarkdownBody":"\n要在一個 Git 專案中有子專案 (我都叫他 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄 submodule 的路徑和 commit 版本。\n\n<!--more-->\n\n## Add Submodule\n\n要將專案新增到現有的目錄中，可以使用 `git submodule add`：\n\n```shell\ngit submodule add <repo_url> <folder>\n```\n\n執行後，可以看到 git 會自動幫你把 submodule clone 到指定的目錄中，並多了一個檔案 `.gitmodules`，這個檔案就是上面說到的 Submodule 只紀錄 commit 版本，和 Submodule URL 的檔案。\n\nadd submodule 後，還是要 commit，因為 Submodule 也就只是紀錄要用子專案的哪一個 commit 版本，所以也可以確保大家都是使用到同一個 Submodule 的版本。可以試著將專案 commit and push 到 GitHub 上，應該可以看到 Submodule 就是連結到另外一個專案的某一個 commit，下面是本站的 Hugo 主題的 submodule：\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c4ba8819-787e-4726-fb58-db317f9ed400/public)\n\n## Clone Submodule\n\n在 Clone 含有 Submodule 的專案時，Git 預設是不會自動 clone 子專案的，需要加上 `--recursive` 這個參數，才會自動把 Submodule 也 Clone 下來。\n\n```shell\ngit clone --recursive <repo_url>\n```\n\n如果 Clone 下來後才發現有 Submodule，可以用下面的方式補救，把子專案都 Clone 下來：\n\n```shell\ngit submodule init\ngit submodule update --recursive\n```\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Git/git submodule.md","excerpt":"要在一個 Git 專案中有子專案 (我都叫他 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄 submodule 的路徑和 commit 版本。 Add Submodule 要將專案新增到現有的目錄中，可以使用 ： 執行後，可以看到 git 會自動幫你把 submodul…","frontmatter":{"title":"Git Submodule","date":"2021-09-14T05:11:27.000Z","draft":false,"tags":["git","submodule","linux"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6c29c4ca-3fc9-49b2-3109-0876c7492400/public","description":"要在一個 Git 專案中有子專案 (我稱為 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄"}}},{"node":{"id":"a9e11a01-abab-5de8-b3ae-abccff685c14","html":"<p>在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。</p>\n<!--more-->\n<h2>ssh-keygen</h2>\n<p>要使用 ssh 非對稱加密，就會需要公鑰與私鑰，創建 ssh key 的方法就是 <code class=\"language-text\">ssh-keygen</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">user@66c0bf85e710:~$ ssh-keygen\nGenerating public/private rsa key pair.\nEnter <span class=\"token function\">file</span> <span class=\"token keyword\">in</span> <span class=\"token function\">which</span> to save the key <span class=\"token punctuation\">(</span>/home/user/.ssh/id_rsa<span class=\"token punctuation\">)</span>:\nCreated directory <span class=\"token string\">'/home/user/.ssh'</span><span class=\"token builtin class-name\">.</span>\nEnter passphrase <span class=\"token punctuation\">(</span>empty <span class=\"token keyword\">for</span> no passphrase<span class=\"token punctuation\">)</span>:\nEnter same passphrase again:\nYour identification has been saved <span class=\"token keyword\">in</span> /home/user/.ssh/id_rsa\nYour public key has been saved <span class=\"token keyword\">in</span> /home/user/.ssh/id_rsa.pub\nThe key fingerprint is:\nSHA256:+UUuTN0YLUi2eh7HJoJvuy0whUuLvXIQejjPPTZ9gw4 user@66c0bf85e710\nThe key's randomart image is:\n+---<span class=\"token punctuation\">[</span>RSA <span class=\"token number\">3072</span><span class=\"token punctuation\">]</span>----+\n<span class=\"token operator\">|</span>         .o<span class=\"token punctuation\">..</span>.   <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>         <span class=\"token punctuation\">..</span>o.+.  <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>       <span class=\"token builtin class-name\">.</span>  o +<span class=\"token punctuation\">..</span>  <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>    <span class=\"token builtin class-name\">.</span> o<span class=\"token punctuation\">..</span><span class=\"token operator\">=</span> +     <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>   o <span class=\"token operator\">=</span>.+S * *    <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>  + + *. <span class=\"token operator\">=</span> B     <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>   <span class=\"token operator\">=</span> <span class=\"token assign-left variable\">oE</span><span class=\"token operator\">=</span>o.o      <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>    + Bo+oo      <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>     + +++<span class=\"token punctuation\">..</span>     <span class=\"token operator\">|</span>\n+----<span class=\"token punctuation\">[</span>SHA256<span class=\"token punctuation\">]</span>-----+</code></pre></div>\n<p><code class=\"language-text\">ssh-keygen</code> 會問一些問題，最快的方式就是直接留白(保持預設)，一直按 enter 就可以看到已經在 <code class=\"language-text\">~/.ssh</code> 產生了兩個檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">user@66c0bf85e710:~$ <span class=\"token function\">ls</span> -l ~/.ssh\ntotal <span class=\"token number\">8</span>\n-rw------- <span class=\"token number\">1</span> user user <span class=\"token number\">2602</span> Sep <span class=\"token number\">12</span> <span class=\"token number\">22</span>:42 id_rsa\n-rw-r--r-- <span class=\"token number\">1</span> user user  <span class=\"token number\">571</span> Sep <span class=\"token number\">12</span> <span class=\"token number\">22</span>:42 id_rsa.pub\nuser@66c0bf85e710:~$</code></pre></div>\n<p><code class=\"language-text\">id_rsa</code> 就是私鑰，而多個 pub 結尾的 <code class=\"language-text\">id_rsa.pub</code> 就是公鑰。私鑰請不要傳給任何人，公鑰則提供給 GitHub。可以用 cat 將公鑰顯示出來並複製他：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.714d829xbug0.png\" alt=\"image\"></p>\n<h2>把公鑰交給 GitHub</h2>\n<p>到 GitHub 的 Settings -> SSH and GPG keys -> New SSH key：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.5frveu05dt00.png\" alt=\"image\"></p>\n<p>把剛剛複製下來的公鑰貼上，Title 可以自己隨便輸入或打這台電腦的名字：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.56vkhmb55ps0.png\" alt=\"image\"></p>\n<h2>測試連線</h2>\n<p>輸入下面命令就可以知道有沒有連線成功，如果有看到自己的使用者名稱，就代表已經完成 ssh 的認證：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">ssh</span> -T git@github.com</code></pre></div>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.5f99gnzo3ps0.png\" alt=\"image\"></p>\n<p>第一次連線可能會問要不要信任，輸入 <code class=\"language-text\">yes</code> 即可。</p>\n<blockquote>\n<p>如果覺得上面的方法麻煩，也可以直接創建一個私有 repo，然後試著 clone 和 push，就知道有沒有認證成功了。</p>\n</blockquote>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/testing-your-ssh-connection\">Testing your SSH connection</a></li>\n</ul>","rawMarkdownBody":"\n在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。\n\n<!--more-->\n\n## ssh-keygen\n\n要使用 ssh 非對稱加密，就會需要公鑰與私鑰，創建 ssh key 的方法就是 `ssh-keygen`：\n\n```shell\nuser@66c0bf85e710:~$ ssh-keygen\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/user/.ssh/id_rsa):\nCreated directory '/home/user/.ssh'.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/user/.ssh/id_rsa\nYour public key has been saved in /home/user/.ssh/id_rsa.pub\nThe key fingerprint is:\nSHA256:+UUuTN0YLUi2eh7HJoJvuy0whUuLvXIQejjPPTZ9gw4 user@66c0bf85e710\nThe key's randomart image is:\n+---[RSA 3072]----+\n|         .o...   |\n|         ..o.+.  |\n|       .  o +..  |\n|    . o..= +     |\n|   o =.+S * *    |\n|  + + *. = B     |\n|   = oE=o.o      |\n|    + Bo+oo      |\n|     + +++..     |\n+----[SHA256]-----+\n```\n\n`ssh-keygen` 會問一些問題，最快的方式就是直接留白(保持預設)，一直按 enter 就可以看到已經在 `~/.ssh` 產生了兩個檔案：\n\n```shell\nuser@66c0bf85e710:~$ ls -l ~/.ssh\ntotal 8\n-rw------- 1 user user 2602 Sep 12 22:42 id_rsa\n-rw-r--r-- 1 user user  571 Sep 12 22:42 id_rsa.pub\nuser@66c0bf85e710:~$\n```\n\n`id_rsa` 就是私鑰，而多個 pub 結尾的 `id_rsa.pub` 就是公鑰。私鑰請不要傳給任何人，公鑰則提供給 GitHub。可以用 cat 將公鑰顯示出來並複製他：\n\n![image](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.714d829xbug0.png)\n\n## 把公鑰交給 GitHub\n\n到 GitHub 的 Settings -> SSH and GPG keys -> New SSH key：\n\n![image](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.5frveu05dt00.png)\n\n把剛剛複製下來的公鑰貼上，Title 可以自己隨便輸入或打這台電腦的名字：\n\n![image](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.56vkhmb55ps0.png)\n\n## 測試連線\n\n輸入下面命令就可以知道有沒有連線成功，如果有看到自己的使用者名稱，就代表已經完成 ssh 的認證：\n\n```shell\nssh -T git@github.com\n```\n\n![image](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.5f99gnzo3ps0.png)\n\n第一次連線可能會問要不要信任，輸入 `yes` 即可。\n\n> 如果覺得上面的方法麻煩，也可以直接創建一個私有 repo，然後試著 clone 和 push，就知道有沒有認證成功了。\n\n## Reference\n\n- [Testing your SSH connection](https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/testing-your-ssh-connection)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Git/github ssh.md","excerpt":"在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。 ssh-keygen 要使用 ssh 非對稱加密，就會需要公鑰與私鑰，創建 ssh key 的方法就是 ：  會問一些問題，最快的方式就是直接留白(保持預設)，一直按 enter 就可以看到已經在  產生了兩個檔案：  就是私鑰，而多個 pub 結尾的…","frontmatter":{"title":"GitHub SSH","date":"2021-09-12T14:32:19.000Z","draft":false,"tags":["git","github","ssh"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8fdd1b8a-21b2-4d15-9947-a6bdcc6f1000/public","description":"在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。"}}},{"node":{"id":"6768d0b8-3c0c-5392-8320-9c2443f08519","html":"<p>紀錄一下我的 <a href=\"https://github.com/TonyPepeBear/cloud-ide-docker\">Cloud IDE Docker</a> 使用方法。</p>\n<!--more-->\n<h2>Pycharm Community</h2>\n<p><a href=\"https://hub.docker.com/r/tonypepe/pycharmc\">Docker Hub</a></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -dp <span class=\"token number\">8887</span>:8887 tonypepe/pycharmc</code></pre></div>","rawMarkdownBody":"\n紀錄一下我的 [Cloud IDE Docker](https://github.com/TonyPepeBear/cloud-ide-docker) 使用方法。\n\n<!--more-->\n\n## Pycharm Community\n\n[Docker Hub](https://hub.docker.com/r/tonypepe/pycharmc)\n\n```bash\ndocker run -dp 8887:8887 tonypepe/pycharmc\n```\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Dev/Cloud Ide Docker.md","excerpt":"紀錄一下我的 Cloud IDE Docker 使用方法。 Pycharm Community Docker Hub","frontmatter":{"title":"Cloud IDE Docker","date":"2021-08-30T08:13:47.000Z","draft":false,"tags":["ide","docker","jetbrains"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/87cfccae-9904-4391-0e52-2b001fffd500/public","description":null}}},{"node":{"id":"b04ee4c4-22aa-519f-a77a-6ab113d7d6a2","html":"<p>Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。</p>\n<!--more-->\n<h2>Docker v.s. VM</h2>\n<p>入門 Docker 最常見的問題就是，Docker 和 VM 差在哪裡？這個問題不難理解，VM 「虛擬機」，顧名思義是虛擬化「硬體」。而 Docker 則是只虛擬化作業系統，或是稱作「軟體」。</p>\n<p>大家都應該知道每創建一個虛擬機，都會耗費掉數分鐘的時間，若還要安裝環境，那耗費的時間則會相當可觀，也會耗費掉相當大的硬體資源。Docker 只虛擬化軟體的優勢，就是可以在幾秒內就啟動服務，耗費資源也相當少，還省去了建立環境的時間。</p>\n<h2>Docker Hub</h2>\n<blockquote>\n<p>Git 有 GitHub，Docker 有 Docker Hub</p>\n</blockquote>\n<p>Docker Hub 是 Docker 官方用來存放 Image 的倉庫 (Registry)，使用者也可以自架 Registry，但是如果未指定 Registry，Docker 預設會去找 Docker Hub 上的 Image。</p>\n<h2>Image</h2>\n<p>Image 通常可以是一個系統，也可以是一個已經安裝好特定執行環境 (像是 JAVA) 的系統。系統部分最常見的會是用 alpine linux，這是一個非常小的項目，只有一個系統，可以讓你在幾秒內就可以啟動服務，許多執行環境也會建構在這個系統上。現在可以先去 Docker Hub 上看看幾個前幾名的 Image，大概就會比較清楚 Image 的功用。</p>\n<p>Docker Image 可以由下列幾方式取得：</p>\n<ul>\n<li>從 Docker Hub 上下載</li>\n<li>由 Dockerfile 構建</li>\n<li>從其他電腦 import</li>\n</ul>\n<h2>Container</h2>\n<p>Docker 用 Image 創建 Container，也就是說，Container 是 Image 的實例，Container 基本上就是一個完整的作業系統，可以執行任何的程式。</p>\n<h2>Docker Run</h2>\n<p>我們簡單創建一個 Ubuntu 的 Container，並且啟動它：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run ubuntu</code></pre></div>\n<p>執行後可以看到 Docker 自動從 Docker Hub 上下載 Ubuntu 的 Image，但是開始執行後卻甚麼都沒發生就結束了。這是因為 Ubuntu 的 Image 預設是啟動一個 Shell，如果沒有 Attach 到 Sheel 上，Container 馬上就結束了。</p>\n<p>所以如果我們要 Attach 到 Ubuntu 的 Shell 上，可以這樣執行：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -it ubuntu</code></pre></div>\n<p>執行應該就會看到我們到 ubuntu 的 Shell 裡。</p>\n<h2>啟動一個網頁服務</h2>\n<p>Nginx 有官方的 Hello Image，可以更清楚的看到 Container 有在執行 Nginx 服務。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -p <span class=\"token number\">8080</span>:80 -d nginxdemos/hello</code></pre></div>\n<p>上面多了一個 <code class=\"language-text\">-p</code> 的參數，後面跟上 <code class=\"language-text\">8080:80</code>，意思是本機的 8080 Port 對到容器的 80 Port，這樣就可以讓我們在本機的 8080 Port 上看到 Nginx 的網頁了。</p>\n<h2>列出、刪除容器</h2>\n<p>列出正在執行的容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">ps</span></code></pre></div>\n<p>列出所有容器，包含已經停止的容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> -a</code></pre></div>\n<p>刪除容器，若是尚未停止的容器則無法刪除：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token operator\">&lt;</span>container_id<span class=\"token operator\">></span></code></pre></div>\n<p>加上 <code class=\"language-text\">-f</code> 參數，可強制刪除執行中的容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> -f <span class=\"token operator\">&lt;</span>container_id<span class=\"token operator\">></span></code></pre></div>\n<p>強制刪除所有容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> -aq<span class=\"token variable\">)</span></span></code></pre></div>\n<h2>創建自己的 Image</h2>\n<p>要教 Docker 怎麼創建 Image，需要先建立一個 <code class=\"language-text\">Dockerfile</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> ubuntu:latest</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> apt update <span class=\"token operator\">\\</span>\n    &amp;&amp; apt install vim git -y <span class=\"token operator\">\\</span>\n    &amp;&amp; rm -rf /var/lib/apt/lists/*</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"/bin/bash\"</span>]</span></code></pre></div>\n<p>Build Image:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> build -t my-ubuntu <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>注意上面的指令的最後面有一個 <code class=\"language-text\">.</code>，代表 Build 這個目錄。<code class=\"language-text\">-t</code> 的參數則是 Image 的名稱，或是稱作 Tag。</p>","rawMarkdownBody":"\nDocker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。\n\n<!--more-->\n\n## Docker v.s. VM\n\n入門 Docker 最常見的問題就是，Docker 和 VM 差在哪裡？這個問題不難理解，VM 「虛擬機」，顧名思義是虛擬化「硬體」。而 Docker 則是只虛擬化作業系統，或是稱作「軟體」。\n\n大家都應該知道每創建一個虛擬機，都會耗費掉數分鐘的時間，若還要安裝環境，那耗費的時間則會相當可觀，也會耗費掉相當大的硬體資源。Docker 只虛擬化軟體的優勢，就是可以在幾秒內就啟動服務，耗費資源也相當少，還省去了建立環境的時間。\n\n## Docker Hub\n\n> Git 有 GitHub，Docker 有 Docker Hub\n\nDocker Hub 是 Docker 官方用來存放 Image 的倉庫 (Registry)，使用者也可以自架 Registry，但是如果未指定 Registry，Docker 預設會去找 Docker Hub 上的 Image。\n\n## Image\n\nImage 通常可以是一個系統，也可以是一個已經安裝好特定執行環境 (像是 JAVA) 的系統。系統部分最常見的會是用 alpine linux，這是一個非常小的項目，只有一個系統，可以讓你在幾秒內就可以啟動服務，許多執行環境也會建構在這個系統上。現在可以先去 Docker Hub 上看看幾個前幾名的 Image，大概就會比較清楚 Image 的功用。\n\nDocker Image 可以由下列幾方式取得：\n\n- 從 Docker Hub 上下載\n- 由 Dockerfile 構建\n- 從其他電腦 import\n\n## Container\n\nDocker 用 Image 創建 Container，也就是說，Container 是 Image 的實例，Container 基本上就是一個完整的作業系統，可以執行任何的程式。\n\n## Docker Run\n\n我們簡單創建一個 Ubuntu 的 Container，並且啟動它：\n\n```bash\ndocker run ubuntu\n```\n\n執行後可以看到 Docker 自動從 Docker Hub 上下載 Ubuntu 的 Image，但是開始執行後卻甚麼都沒發生就結束了。這是因為 Ubuntu 的 Image 預設是啟動一個 Shell，如果沒有 Attach 到 Sheel 上，Container 馬上就結束了。\n\n所以如果我們要 Attach 到 Ubuntu 的 Shell 上，可以這樣執行：\n\n```bash\ndocker run -it ubuntu\n```\n\n執行應該就會看到我們到 ubuntu 的 Shell 裡。\n\n## 啟動一個網頁服務\n\nNginx 有官方的 Hello Image，可以更清楚的看到 Container 有在執行 Nginx 服務。\n\n```bash\ndocker run -p 8080:80 -d nginxdemos/hello\n```\n\n上面多了一個 `-p` 的參數，後面跟上 `8080:80`，意思是本機的 8080 Port 對到容器的 80 Port，這樣就可以讓我們在本機的 8080 Port 上看到 Nginx 的網頁了。\n\n## 列出、刪除容器\n\n列出正在執行的容器：\n\n```bash\ndocker ps\n```\n\n列出所有容器，包含已經停止的容器：\n\n```bash\ndocker ps -a\n```\n\n刪除容器，若是尚未停止的容器則無法刪除：\n\n```bash\ndocker rm <container_id>\n```\n\n加上 `-f` 參數，可強制刪除執行中的容器：\n\n```bash\ndocker rm -f <container_id>\n```\n\n強制刪除所有容器：\n\n```bash\ndocker rm $(docker ps -aq)\n```\n\n## 創建自己的 Image\n\n要教 Docker 怎麼創建 Image，需要先建立一個 `Dockerfile`：\n\n```dockerfile\nFROM ubuntu:latest\n\nRUN apt update \\\n    && apt install vim git -y \\\n    && rm -rf /var/lib/apt/lists/*\n\nCMD [\"/bin/bash\"]\n```\n\nBuild Image:\n\n```bash\ndocker build -t my-ubuntu .\n```\n\n注意上面的指令的最後面有一個 `.`，代表 Build 這個目錄。`-t` 的參數則是 Image 的名稱，或是稱作 Tag。\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Docker/docker.md","excerpt":"Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。 Docker v.s. VM 入門 Docker 最常見的問題就是，Docker 和 VM 差在哪裡？這個問題不難理解，VM 「虛擬機」，顧名思義是虛擬化「硬體」。而 Docker 則是只虛擬…","frontmatter":{"title":"Docker","date":"2021-08-25T18:31:57.000Z","draft":false,"tags":["docker"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/a45b7e65-d6dd-4ef5-23b4-44e2090c5b00/public","description":"Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。"}}}]}},"pageContext":{"limit":8,"skip":16,"numPages":5,"currentPage":3}},"staticQueryHashes":[]}