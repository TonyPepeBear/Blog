{"componentChunkName":"component---src-templates-article-template-tsx","path":"/posts/docker/docker","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"c2fce845-caca-5713-a1ce-38aae55a0978","html":"<p>Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。</p>\n<!--more-->\n<h2>Docker v.s. VM</h2>\n<p>入門 Docker 最常見的問題就是，Docker 和 VM 差在哪裡？這個問題不難理解，VM 「虛擬機」，顧名思義是虛擬化「硬體」。而 Docker 則是只虛擬化作業系統，或是稱作「軟體」。</p>\n<p>大家都應該知道每創建一個虛擬機，都會耗費掉數分鐘的時間，若還要安裝環境，那耗費的時間則會相當可觀，也會耗費掉相當大的硬體資源。Docker 只虛擬化軟體的優勢，就是可以在幾秒內就啟動服務，耗費資源也相當少，還省去了建立環境的時間。</p>\n<h2>Docker Hub</h2>\n<blockquote>\n<p>Git 有 GitHub，Docker 有 Docker Hub</p>\n</blockquote>\n<p>Docker Hub 是 Docker 官方用來存放 Image 的倉庫 (Registry)，使用者也可以自架 Registry，但是如果未指定 Registry，Docker 預設會去找 Docker Hub 上的 Image。</p>\n<h2>Image</h2>\n<p>Image 通常可以是一個系統，也可以是一個已經安裝好特定執行環境 (像是 JAVA) 的系統。系統部分最常見的會是用 alpine linux，這是一個非常小的項目，只有一個系統，可以讓你在幾秒內就可以啟動服務，許多執行環境也會建構在這個系統上。現在可以先去 Docker Hub 上看看幾個前幾名的 Image，大概就會比較清楚 Image 的功用。</p>\n<p>Docker Image 可以由下列幾方式取得：</p>\n<ul>\n<li>從 Docker Hub 上下載</li>\n<li>由 Dockerfile 構建</li>\n<li>從其他電腦 import</li>\n</ul>\n<h2>Container</h2>\n<p>Docker 用 Image 創建 Container，也就是說，Container 是 Image 的實例，Container 基本上就是一個完整的作業系統，可以執行任何的程式。</p>\n<h2>Docker Run</h2>\n<p>我們簡單創建一個 Ubuntu 的 Container，並且啟動它：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run ubuntu</code></pre></div>\n<p>執行後可以看到 Docker 自動從 Docker Hub 上下載 Ubuntu 的 Image，但是開始執行後卻甚麼都沒發生就結束了。這是因為 Ubuntu 的 Image 預設是啟動一個 Shell，如果沒有 Attach 到 Sheel 上，Container 馬上就結束了。</p>\n<p>所以如果我們要 Attach 到 Ubuntu 的 Shell 上，可以這樣執行：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -it ubuntu</code></pre></div>\n<p>執行應該就會看到我們到 ubuntu 的 Shell 裡。</p>\n<h2>啟動一個網頁服務</h2>\n<p>Nginx 有官方的 Hello Image，可以更清楚的看到 Container 有在執行 Nginx 服務。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -p <span class=\"token number\">8080</span>:80 -d nginxdemos/hello</code></pre></div>\n<p>上面多了一個 <code class=\"language-text\">-p</code> 的參數，後面跟上 <code class=\"language-text\">8080:80</code>，意思是本機的 8080 Port 對到容器的 80 Port，這樣就可以讓我們在本機的 8080 Port 上看到 Nginx 的網頁了。</p>\n<h2>列出、刪除容器</h2>\n<p>列出正在執行的容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">ps</span></code></pre></div>\n<p>列出所有容器，包含已經停止的容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> -a</code></pre></div>\n<p>刪除容器，若是尚未停止的容器則無法刪除：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token operator\">&lt;</span>container_id<span class=\"token operator\">></span></code></pre></div>\n<p>加上 <code class=\"language-text\">-f</code> 參數，可強制刪除執行中的容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> -f <span class=\"token operator\">&lt;</span>container_id<span class=\"token operator\">></span></code></pre></div>\n<p>強制刪除所有容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> -aq<span class=\"token variable\">)</span></span></code></pre></div>\n<h2>創建自己的 Image</h2>\n<p>要教 Docker 怎麼創建 Image，需要先建立一個 <code class=\"language-text\">Dockerfile</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> ubuntu:latest</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> apt update <span class=\"token operator\">\\</span>\n    &amp;&amp; apt install vim git -y <span class=\"token operator\">\\</span>\n    &amp;&amp; rm -rf /var/lib/apt/lists/*</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"/bin/bash\"</span>]</span></code></pre></div>\n<p>Build Image:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> build -t my-ubuntu <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>注意上面的指令的最後面有一個 <code class=\"language-text\">.</code>，代表 Build 這個目錄。<code class=\"language-text\">-t</code> 的參數則是 Image 的名稱，或是稱作 Tag。</p>","rawMarkdownBody":"\nDocker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。\n\n<!--more-->\n\n## Docker v.s. VM\n\n入門 Docker 最常見的問題就是，Docker 和 VM 差在哪裡？這個問題不難理解，VM 「虛擬機」，顧名思義是虛擬化「硬體」。而 Docker 則是只虛擬化作業系統，或是稱作「軟體」。\n\n大家都應該知道每創建一個虛擬機，都會耗費掉數分鐘的時間，若還要安裝環境，那耗費的時間則會相當可觀，也會耗費掉相當大的硬體資源。Docker 只虛擬化軟體的優勢，就是可以在幾秒內就啟動服務，耗費資源也相當少，還省去了建立環境的時間。\n\n## Docker Hub\n\n> Git 有 GitHub，Docker 有 Docker Hub\n\nDocker Hub 是 Docker 官方用來存放 Image 的倉庫 (Registry)，使用者也可以自架 Registry，但是如果未指定 Registry，Docker 預設會去找 Docker Hub 上的 Image。\n\n## Image\n\nImage 通常可以是一個系統，也可以是一個已經安裝好特定執行環境 (像是 JAVA) 的系統。系統部分最常見的會是用 alpine linux，這是一個非常小的項目，只有一個系統，可以讓你在幾秒內就可以啟動服務，許多執行環境也會建構在這個系統上。現在可以先去 Docker Hub 上看看幾個前幾名的 Image，大概就會比較清楚 Image 的功用。\n\nDocker Image 可以由下列幾方式取得：\n\n- 從 Docker Hub 上下載\n- 由 Dockerfile 構建\n- 從其他電腦 import\n\n## Container\n\nDocker 用 Image 創建 Container，也就是說，Container 是 Image 的實例，Container 基本上就是一個完整的作業系統，可以執行任何的程式。\n\n## Docker Run\n\n我們簡單創建一個 Ubuntu 的 Container，並且啟動它：\n\n```bash\ndocker run ubuntu\n```\n\n執行後可以看到 Docker 自動從 Docker Hub 上下載 Ubuntu 的 Image，但是開始執行後卻甚麼都沒發生就結束了。這是因為 Ubuntu 的 Image 預設是啟動一個 Shell，如果沒有 Attach 到 Sheel 上，Container 馬上就結束了。\n\n所以如果我們要 Attach 到 Ubuntu 的 Shell 上，可以這樣執行：\n\n```bash\ndocker run -it ubuntu\n```\n\n執行應該就會看到我們到 ubuntu 的 Shell 裡。\n\n## 啟動一個網頁服務\n\nNginx 有官方的 Hello Image，可以更清楚的看到 Container 有在執行 Nginx 服務。\n\n```bash\ndocker run -p 8080:80 -d nginxdemos/hello\n```\n\n上面多了一個 `-p` 的參數，後面跟上 `8080:80`，意思是本機的 8080 Port 對到容器的 80 Port，這樣就可以讓我們在本機的 8080 Port 上看到 Nginx 的網頁了。\n\n## 列出、刪除容器\n\n列出正在執行的容器：\n\n```bash\ndocker ps\n```\n\n列出所有容器，包含已經停止的容器：\n\n```bash\ndocker ps -a\n```\n\n刪除容器，若是尚未停止的容器則無法刪除：\n\n```bash\ndocker rm <container_id>\n```\n\n加上 `-f` 參數，可強制刪除執行中的容器：\n\n```bash\ndocker rm -f <container_id>\n```\n\n強制刪除所有容器：\n\n```bash\ndocker rm $(docker ps -aq)\n```\n\n## 創建自己的 Image\n\n要教 Docker 怎麼創建 Image，需要先建立一個 `Dockerfile`：\n\n```dockerfile\nFROM ubuntu:latest\n\nRUN apt update \\\n    && apt install vim git -y \\\n    && rm -rf /var/lib/apt/lists/*\n\nCMD [\"/bin/bash\"]\n```\n\nBuild Image:\n\n```bash\ndocker build -t my-ubuntu .\n```\n\n注意上面的指令的最後面有一個 `.`，代表 Build 這個目錄。`-t` 的參數則是 Image 的名稱，或是稱作 Tag。\n","excerpt":"Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。 Docker v.s. VM 入門 Docker 最常見的問題就是，Docker 和 VM 差在哪裡？這個問題不難理解，VM 「虛擬機」，顧名思義是虛擬化「硬體」。而 Docker 則是只虛擬…","frontmatter":{"title":"Docker","date":"2021-08-25T18:31:57.000Z","draft":false,"tags":["docker"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/a45b7e65-d6dd-4ef5-23b4-44e2090c5b00/public","description":"Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。"}}}]}},"pageContext":{"id":"c2fce845-caca-5713-a1ce-38aae55a0978"}},"staticQueryHashes":[]}