{"componentChunkName":"component---src-templates-article-list-page-template-tsx","path":"/pages/3","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"d10c8dbe-4624-5839-b50d-5bd798a5d0cc","html":"<p>打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210716235146.png\" alt=\"img\"></p>\n<!--more-->\n<p>我們今天主要會用到下面的幾樣技術：</p>\n<ol>\n<li><a href=\"https://zsh.sourceforge.io/\">zsh</a></li>\n<li><a href=\"https://github.com/romkatv/powerlevel10k\">powerlevel10K</a></li>\n<li><a href=\"https://zimfw.sh/#install\">zim</a></li>\n<li><a href=\"https://www.nerdfonts.com/\">Nerd Fonts</a></li>\n</ol>\n<p>看到這幾項技術其實可以自己先去研究一下，看看這些技術是不是自己需要的，以免亂裝一堆東西，搞的自己 Terminal 亂七八糟無法復原。另外，Windows 應該是無法安裝的，至少我自己是沒辦法，不過 WSL 倒是可以玩成這樣，畢竟就是 Linux 麻。</p>\n<p>很多人會推薦在 mac 上安裝 iTerm，我自己是沒裝，我覺得 mac 內建的 Terminal 足夠好用，沒必要安裝其他 Terminal。</p>\n<h2>Font</h2>\n<p>好看的第一步就是有好看的字體，<a href=\"https://www.nerdfonts.com/\">Nerd Fonts</a> 這個專案把一些開發者常用的字體，加上一些在 Terminal 中會用到的一些 icon 和 symbol，常見的 <code class=\"language-text\">Hack</code>、<code class=\"language-text\">Jetbrains Mono</code> 都有在這個專案裡。到 Nerd Fonts 的官網可以下載到這些字體，注意不要到字體們原本的管網下載，要到 Nerd Fonts 下載包含特殊符號的字體。</p>\n<p><img src=\"https://www.nerdfonts.com/assets/img/sankey-glyphs-combined-diagram.png\" alt=\"img\"></p>\n<p>下載安裝好字體後，記得到自己的 Terminal 中變更字體，選擇有包含 Nerd 的字體，以免等等字體都無法顯示，這部分教學我懶得寫，所以附一張圖：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717112205.png\" alt=\"img\"></p>\n<h2>zsh</h2>\n<p>zsh 可以說是 bash 的進階版，提供客製化自己在 Terminal 中想要的主題和功能。要安裝 zsh 通常各個系統都不一樣，自己上網根據系統安裝即可。安裝完成後也要將預設 shell 改成 zsh。</p>\n<p>ubuntu:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token function\">zsh</span>\nchsh -s /bin/zsh <span class=\"token variable\">$USRR</span></code></pre></div>\n<h2>powerlevel10k</h2>\n<p>powerlevel10k 是一個 zsh 主題，提供可高客製化的主題和客製化嚮導，可以簡單地就把 Terminal 變成自己喜歡的模樣，也是本文最重要的部分。powerlevel10k 提供許多安裝方法，可以透過 oh-my-zsh，也可以用腳本安裝，我是認為用腳本安裝就好，可以不用用到 oh-my-zsh，因我們之後會提到 zim 就提供許多可以替代 oh-my-zsh 的功能。</p>\n<p>用腳本安裝 powerlevel10k：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> clone --depth<span class=\"token operator\">=</span><span class=\"token number\">1</span> https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'source ~/powerlevel10k/powerlevel10k.zsh-theme'</span> <span class=\"token operator\">>></span>~/.zshrc</code></pre></div>\n<p>安裝方式可能會因版本變動而不一樣，建議還是到官方 Github 上看一下安裝方式。</p>\n<p>安裝完成後第一次進到 Terminal 會遇到一個安裝嚮導，可以根據自己喜好設定主題樣式。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717214526.gif\" alt=\"img\"></p>\n<p>完成到這裡，Terminal 應該已經變得美美的，如果遇到亂碼，可能是字型沒有調整好。</p>\n<p>powerlevel10k 會提供一個 <code class=\"language-text\">p10k</code> 的命令，可以用於重新啟動嚮導：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717174430.png\" alt=\"img\"></p>\n<h2>Zim</h2>\n<p>全名 Zsh IMproved FrameWork，主要是提供一些方便的 zsh plugin，像是自動補全、語法高亮等，如果是希望好看，不用好用，Zim 就可以不用安裝。</p>\n<p>安裝 Zim 也很簡單，只要 Run 下面的腳本就可以：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> -fsSL https://raw.githubusercontent.com/zimfw/install/master/install.zsh <span class=\"token operator\">|</span> <span class=\"token function\">zsh</span></code></pre></div>\n<p>到這就算是全部完成，如果有發現更多好用的 Terminal 工具，記得分享給我。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://zsh.sourceforge.io/\">zsh</a></li>\n<li><a href=\"https://github.com/romkatv/powerlevel10k\">powerlevel10K</a></li>\n<li><a href=\"https://zimfw.sh/#install\">zim</a></li>\n<li><a href=\"https://www.nerdfonts.com/\">Nerd Fonts</a></li>\n</ul>","rawMarkdownBody":"\n打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210716235146.png)\n\n<!--more-->\n\n我們今天主要會用到下面的幾樣技術：\n\n1. [zsh](https://zsh.sourceforge.io/)\n2. [powerlevel10K](https://github.com/romkatv/powerlevel10k)\n3. [zim](https://zimfw.sh/#install)\n4. [Nerd Fonts](https://www.nerdfonts.com/)\n\n看到這幾項技術其實可以自己先去研究一下，看看這些技術是不是自己需要的，以免亂裝一堆東西，搞的自己 Terminal 亂七八糟無法復原。另外，Windows 應該是無法安裝的，至少我自己是沒辦法，不過 WSL 倒是可以玩成這樣，畢竟就是 Linux 麻。\n\n很多人會推薦在 mac 上安裝 iTerm，我自己是沒裝，我覺得 mac 內建的 Terminal 足夠好用，沒必要安裝其他 Terminal。\n\n## Font\n\n好看的第一步就是有好看的字體，[Nerd Fonts](https://www.nerdfonts.com/) 這個專案把一些開發者常用的字體，加上一些在 Terminal 中會用到的一些 icon 和 symbol，常見的 `Hack`、`Jetbrains Mono` 都有在這個專案裡。到 Nerd Fonts 的官網可以下載到這些字體，注意不要到字體們原本的管網下載，要到 Nerd Fonts 下載包含特殊符號的字體。\n\n![img](https://www.nerdfonts.com/assets/img/sankey-glyphs-combined-diagram.png)\n\n下載安裝好字體後，記得到自己的 Terminal 中變更字體，選擇有包含 Nerd 的字體，以免等等字體都無法顯示，這部分教學我懶得寫，所以附一張圖：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717112205.png)\n\n## zsh\n\nzsh 可以說是 bash 的進階版，提供客製化自己在 Terminal 中想要的主題和功能。要安裝 zsh 通常各個系統都不一樣，自己上網根據系統安裝即可。安裝完成後也要將預設 shell 改成 zsh。\n\nubuntu:\n\n```bash\nsudo apt install zsh\nchsh -s /bin/zsh $USRR\n```\n\n## powerlevel10k\n\npowerlevel10k 是一個 zsh 主題，提供可高客製化的主題和客製化嚮導，可以簡單地就把 Terminal 變成自己喜歡的模樣，也是本文最重要的部分。powerlevel10k 提供許多安裝方法，可以透過 oh-my-zsh，也可以用腳本安裝，我是認為用腳本安裝就好，可以不用用到 oh-my-zsh，因我們之後會提到 zim 就提供許多可以替代 oh-my-zsh 的功能。\n\n用腳本安裝 powerlevel10k：\n\n```bash\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k\necho 'source ~/powerlevel10k/powerlevel10k.zsh-theme' >>~/.zshrc\n```\n\n安裝方式可能會因版本變動而不一樣，建議還是到官方 Github 上看一下安裝方式。\n\n安裝完成後第一次進到 Terminal 會遇到一個安裝嚮導，可以根據自己喜好設定主題樣式。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717214526.gif)\n\n完成到這裡，Terminal 應該已經變得美美的，如果遇到亂碼，可能是字型沒有調整好。\n\npowerlevel10k 會提供一個 `p10k` 的命令，可以用於重新啟動嚮導：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717174430.png)\n\n## Zim\n\n全名 Zsh IMproved FrameWork，主要是提供一些方便的 zsh plugin，像是自動補全、語法高亮等，如果是希望好看，不用好用，Zim 就可以不用安裝。\n\n安裝 Zim 也很簡單，只要 Run 下面的腳本就可以：\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/zimfw/install/master/install.zsh | zsh\n```\n\n到這就算是全部完成，如果有發現更多好用的 Terminal 工具，記得分享給我。\n\n## Reference\n\n- [zsh](https://zsh.sourceforge.io/)\n- [powerlevel10K](https://github.com/romkatv/powerlevel10k)\n- [zim](https://zimfw.sh/#install)\n- [Nerd Fonts](https://www.nerdfonts.com/)\n","fileAbsolutePath":"/home/runner/work/HugoBlog/HugoBlog/src/posts/Linux/Beautiful Terminal.md","excerpt":"打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。 img 我們今天主要會用到下面的幾樣技術： zsh powerlevel10K zim Nerd Fonts 看到這幾項技術其實可以自己先去研究一下，看看這些技術是不是自己需要的，以免亂裝一堆東西，搞的自己 Terminal 亂七八糟無法復原。另外，W…","frontmatter":{"title":"Beautiful Terminal","date":"2021-07-16T15:43:07.000Z","draft":false,"tags":["terminl","zsh","zim","powerlevel","powerlevel10k","nerd font","ubuntu","mac"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/939d8b79-aeab-465b-8bc7-fcf3cc4def00/public","description":"打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。"}}},{"node":{"id":"d8944f3e-15db-59a8-a3ce-04b0ca280252","html":"<p>Markdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。</p>\n<!--more-->\n<p>我們來看看 <a href=\"https://github.com/apple/swift\">Swift</a> 的官網，可以發現 <code class=\"language-text\">[README.md](http://readme.md)</code> 這個檔案就是由 Markdown 編寫，Github 也會自動將這個檔案渲染在網頁下方。到這裡可以發現，在 Github 上的所有開源專案的文件，幾乎都是由 Markdown 編寫。</p>\n<h2>哲學</h2>\n<p>引述自 <a href=\"https://markdown.tw\">https://markdown.tw</a></p>\n<blockquote>\n<p>Markdown 的目標是實現「易讀易寫」。<br>\n不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 語法受到一些既有 text-to-HTML 格式的影響，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，然而最大靈感來源其實是純文字的電子郵件格式。<br>\n因此 Markdown 的語法全由標點符號所組成，並經過嚴謹慎選，是為了讓它們看起來就像所要表達的意思。像是在文字兩旁加上星號，看起來就像<em>強調</em>。Markdown 的清單看起來，嗯，就是清單。假如你有使用過電子郵件，區塊引言看起來就真的像是引用一段文字。</p>\n</blockquote>\n<h2>Tools</h2>\n<p>Q: 那要用什麼來寫呢？</p>\n<p>因為 Markdown 基本上也是純文字檔案，所以只要是文字編輯器都可以編輯，你要用 txt 來寫也是個不錯的方法 ❤️。</p>\n<h3>VSCode</h3>\n<p>目前最推薦的就是工程師的好夥伴 <code class=\"language-text\">VSCode</code> ，VSCode 在寫 Markdown 時，有提供即時渲染，可以快速的看到結果，而且 VSCode 應該在各位工程師的電腦裡都應該有安裝才對。</p>\n<h3>HackMD</h3>\n<p>HackMD 是一個在網頁中的 Markdown 編輯器，可以方便地在網頁中編輯和看到編寫的結果，HackMD 最厲害的功能是可以將 Markdown 轉換成簡報，用 Markdown 取代 PowerPoint？這夠帥吧！</p>\n<h3>MarkText</h3>\n<p>這是一個在 <a href=\"https://github.com/marktext/marktext\">Github</a> 上的開源專案，可以所寫所得，方便使用，但我還是比較推薦新手使用上面兩項工具，因為這東西真的太方便了，有點沒有在寫 Markdown 的感覺。</p>\n<h3>Microsoft Word</h3>\n<p>推薦指數：⭐⭐⭐⭐⭐</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=X34ZmkeZDos\">[YouTube] Why Microsoft Word is the best IDE for programming</a></li>\n</ul>\n<h2>Markdown 語法</h2>\n<!-- markdownlint-disable MD025 -->\n<h1>大標題</h1>\n<!-- markdownlint-enable MD025 -->\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token title important\"><span class=\"token punctuation\">#</span> 大標題</span></code></pre></div>\n<hr>\n<h2>次標題</h2>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h2</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token title important\"><span class=\"token punctuation\">##</span> 次標題</span></code></pre></div>\n<hr>\n<h3>次次標題</h3>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h3</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token title important\"><span class=\"token punctuation\">###</span> 次次標題</span></code></pre></div>\n<hr>\n<h2>內文</h2>\n<p>內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文</p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>\n\n內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文</code></pre></div>\n<hr>\n<h2>斜體 粗體</h2>\n<p>內文內文內文<em>斜體</em>內文內文內文內文內文內文<br>\n內文內文內文<strong>粗體</strong>內文內文內文內文內文內文</p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">內文內文內文<span class=\"token italic\"><span class=\"token punctuation\">*</span><span class=\"token content\">斜體</span><span class=\"token punctuation\">*</span></span>內文內文內文內文內文內文  \n內文內文內文<span class=\"token bold\"><span class=\"token punctuation\">**</span><span class=\"token content\">粗體</span><span class=\"token punctuation\">**</span></span>內文內文內文內文內文內文</code></pre></div>\n<hr>\n<h2>有序清單</h2>\n<ol>\n<li>有序清單 1</li>\n<li>有序清單 2</li>\n<li>有序清單 3</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ol</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token list punctuation\">1.</span> 有序清單 1\n<span class=\"token list punctuation\">2.</span> 有序清單 2\n<span class=\"token list punctuation\">3.</span> 有序清單 3</code></pre></div>\n<hr>\n<h2>無序清單</h2>\n<ul>\n<li>無序清單 1</li>\n<li>無序清單 2</li>\n<li>無序清單 3</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token list punctuation\">-</span> 無序清單 1\n<span class=\"token list punctuation\">-</span> 無序清單 2\n<span class=\"token list punctuation\">-</span> 無序清單 3\n\n<span class=\"token list punctuation\">*</span> 無序清單 1\n<span class=\"token list punctuation\">*</span> 無序清單 2\n<span class=\"token list punctuation\">*</span> 無序清單 3\n\n<span class=\"token list punctuation\">-</span> 無序清單 1\n<span class=\"token list punctuation\">-</span> 無序清單 2\n<span class=\"token list punctuation\">-</span> 無序清單 3</code></pre></div>\n<hr>\n<h2>程式碼區塊</h2>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hi 程式碼區塊\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717220425.png\" alt=\"img\"></p>\n<hr>\n<h2>標記程式碼</h2>\n<p>inline <code class=\"language-text\">code</code></p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">inline <span class=\"token code-snippet code keyword\">`code`</span></code></pre></div>\n<hr>\n<h2>超連結</h2>\n<p><a href=\"https://google.com\">Google 首頁</a></p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token url\">[<span class=\"token content\">Google 首頁</span>](<span class=\"token url\">https://google.com</span>)</span></code></pre></div>\n<hr>\n<h2>圖片連結</h2>\n<p><img src=\"https://www.google.com.tw/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" alt=\"img\"></p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">![](https://www.google.com.tw/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png)</code></pre></div>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://markdown.tw/\">Markdown 文件</a></li>\n</ul>","rawMarkdownBody":"\nMarkdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。\n\n<!--more-->\n\n我們來看看 [Swift](https://github.com/apple/swift) 的官網，可以發現 `[README.md](http://readme.md)` 這個檔案就是由 Markdown 編寫，Github 也會自動將這個檔案渲染在網頁下方。到這裡可以發現，在 Github 上的所有開源專案的文件，幾乎都是由 Markdown 編寫。\n\n## 哲學\n\n引述自 [https://markdown.tw](https://markdown.tw)\n\n> Markdown 的目標是實現「易讀易寫」。  \n> 不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 語法受到一些既有 text-to-HTML 格式的影響，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，然而最大靈感來源其實是純文字的電子郵件格式。  \n> 因此 Markdown 的語法全由標點符號所組成，並經過嚴謹慎選，是為了讓它們看起來就像所要表達的意思。像是在文字兩旁加上星號，看起來就像*強調*。Markdown 的清單看起來，嗯，就是清單。假如你有使用過電子郵件，區塊引言看起來就真的像是引用一段文字。\n\n## Tools\n\nQ: 那要用什麼來寫呢？\n\n因為 Markdown 基本上也是純文字檔案，所以只要是文字編輯器都可以編輯，你要用 txt 來寫也是個不錯的方法 ❤️。\n\n### VSCode\n\n目前最推薦的就是工程師的好夥伴 `VSCode` ，VSCode 在寫 Markdown 時，有提供即時渲染，可以快速的看到結果，而且 VSCode 應該在各位工程師的電腦裡都應該有安裝才對。\n\n### HackMD\n\nHackMD 是一個在網頁中的 Markdown 編輯器，可以方便地在網頁中編輯和看到編寫的結果，HackMD 最厲害的功能是可以將 Markdown 轉換成簡報，用 Markdown 取代 PowerPoint？這夠帥吧！\n\n### MarkText\n\n這是一個在 [Github](https://github.com/marktext/marktext) 上的開源專案，可以所寫所得，方便使用，但我還是比較推薦新手使用上面兩項工具，因為這東西真的太方便了，有點沒有在寫 Markdown 的感覺。\n\n### Microsoft Word\n\n推薦指數：⭐⭐⭐⭐⭐\n\n- [[YouTube] Why Microsoft Word is the best IDE for programming](https://www.youtube.com/watch?v=X34ZmkeZDos)\n\n## Markdown 語法\n\n<!-- markdownlint-disable MD025 -->\n\n# 大標題\n\n<!-- markdownlint-enable MD025 -->\n\n```md\n<h1>\n\n# 大標題\n```\n\n---\n\n## 次標題\n\n```md\n<h2>\n\n## 次標題\n```\n\n---\n\n### 次次標題\n\n```md\n<h3>\n\n### 次次標題\n```\n\n---\n\n## 內文\n\n內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文\n\n```md\n<p>\n\n內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文\n```\n\n---\n\n## 斜體 粗體\n\n內文內文內文*斜體*內文內文內文內文內文內文  \n內文內文內文**粗體**內文內文內文內文內文內文\n\n```md\n內文內文內文*斜體*內文內文內文內文內文內文  \n內文內文內文**粗體**內文內文內文內文內文內文\n```\n\n---\n\n## 有序清單\n\n1. 有序清單 1\n2. 有序清單 2\n3. 有序清單 3\n\n```md\n<ol>\n\n1. 有序清單 1\n2. 有序清單 2\n3. 有序清單 3\n```\n\n---\n\n## 無序清單\n\n- 無序清單 1\n- 無序清單 2\n- 無序清單 3\n\n```md\n<ul>\n\n- 無序清單 1\n- 無序清單 2\n- 無序清單 3\n\n* 無序清單 1\n* 無序清單 2\n* 無序清單 3\n\n- 無序清單 1\n- 無序清單 2\n- 無序清單 3\n```\n\n---\n\n## 程式碼區塊\n\n```c\nprintf(\"Hi 程式碼區塊\");\n```\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717220425.png)\n\n---\n\n## 標記程式碼\n\ninline `code`\n\n```md\ninline `code`\n```\n\n---\n\n## 超連結\n\n[Google 首頁](https://google.com)\n\n```md\n[Google 首頁](https://google.com)\n```\n\n---\n\n## 圖片連結\n\n![img](https://www.google.com.tw/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png)\n\n```md\n![](https://www.google.com.tw/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png)\n```\n\n## Reference\n\n- [Markdown 文件](https://markdown.tw/)\n","fileAbsolutePath":"/home/runner/work/HugoBlog/HugoBlog/src/posts/Web/markdown.md","excerpt":"Markdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。 我們來看看 Swift 的官網，可以發現  這個檔案就是由 Markdown 編寫，Github 也會自動將這個檔案渲染在網頁下方。到這裡可以發現，在 Github 上的…","frontmatter":{"title":"Markdown","date":"2021-07-05T09:05:38.000Z","draft":false,"tags":["markdown"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0ecfde1e-521f-4e7c-ab46-30357d4e5e00/public","description":"Markdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。"}}},{"node":{"id":"d3a07546-93b9-5f8f-85e0-c59078a55754","html":"<p>frp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。</p>\n<!--more-->\n<p>frp 會需要一台 Server，Server 需要公網 ip，如果沒有公網 ip，可以使用 aws 或 gcp 買一個簡單的 VPS。</p>\n<h2>安裝</h2>\n<p>網路上有許多一鍵安裝的到腳本，但我們不使用那些，有興趣的自己上網搜尋。</p>\n<p>到官方 <a href=\"https://github.com/fatedier/frp/releases\">Release</a> 下載最新版，根據系統選擇，解壓後會看到 <code class=\"language-text\">frps</code> 、<code class=\"language-text\">frpc</code> 各有三個檔案，跟 <code class=\"language-text\">frps</code> 有關的就是 Server 端用的，<code class=\"language-text\">frpc</code> 的就是 Client 端用的。如果是 Server 端，就可以將 <code class=\"language-text\">frpc</code> 的檔案都刪除。</p>\n<h2>Server 端設定</h2>\n<p>在 Server 上打開設定文件 <code class=\"language-text\">frps.ini</code> 可以看到預設就有如下的內容：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">bind_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span></code></pre></div>\n<p><code class=\"language-text\">common</code> 內綁定了 7000 port，這個 port 是讓 client 端連接用的，基本現在不用改設定就可以直接用。執行 <code class=\"language-text\">frps</code> 要用 <code class=\"language-text\">-c</code> 參數給定設定檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">./frps -c ./frps.ini</code></pre></div>\n<p>如果沒看到問題，基本上 Server 端就設定好了，其他功能晚點再介紹，我們先設定好 Client。</p>\n<h2>Client 端設定</h2>\n<p>Client 就是要發布服務伺服器，所以雖然叫做 Client 但本身應該也是一台提供服務的 Server。Client 就可以刪除有關 <code class=\"language-text\">frps</code> 相關的檔案。</p>\n<p>一樣先打開設定檔 <code class=\"language-text\">frpc.ini</code>，也會有如下預設內容：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">server_addr</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">server_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span>\n\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">ssh</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">type</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">tcp</span>\n<span class=\"token key attr-name\">local_ip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">local_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">22</span>\n<span class=\"token key attr-name\">remote_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">6000</span></code></pre></div>\n<p>Client 端的設定檔就不能直接用，需要修改 Server ip 才行，更改 <code class=\"language-text\">server_addr</code> 為剛剛 Server 端的 ip 地址或是 Domain 都可以。</p>\n<p>下方方的 ssh 區塊設一個將 Client 端的 ssh 22 port 公開到 Server 端的 6000 port 的範本，如果有其他的 port 要開放，用相同的思維更改即可。像是如過要加 Minecraft 25565 port 也到 Server 端的 25565 port，就可以新增一個區塊：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">server_addr</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">example.com</span>\n<span class=\"token key attr-name\">server_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span>\n\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">ssh</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">type</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">tcp</span>\n<span class=\"token key attr-name\">local_ip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">local_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">22</span>\n<span class=\"token key attr-name\">remote_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">6000</span>\n\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">minecraft</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">type</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">tcp</span>\n<span class=\"token key attr-name\">local_ip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">local_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">25565</span>\n<span class=\"token key attr-name\">remote_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">25565</span></code></pre></div>\n<p>到目前為止應該就可以用 Server 端的 ip 連接到 Client 端了，如果連不上，可能要檢查一下 Server 端防火牆的設定，這邊就不贅述。</p>\n<h2>Token 認證</h2>\n<p>不知道大家有沒有發現，基本上只要知道你 Server ip 或 domain 的人都可以新增自己的 port，要避免這樣的狀況，我們可以使用 token。使用方法也很簡單，只要在 Server 和 Client 端的 <code class=\"language-text\">[common]</code> 都加上相同的 token 參數，就可以進行簡單的認證。</p>\n<p>Server 端範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">bind_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span>\n<span class=\"token key attr-name\">token</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7Jc2ZCvVzHu</span></code></pre></div>\n<p>Client 端範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">server_addr</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">example.com</span>\n<span class=\"token key attr-name\">server_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span>\n<span class=\"token key attr-name\">token</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7Jc2ZCvVzHu</span>\n\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">ssh</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">type</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">tcp</span>\n<span class=\"token key attr-name\">local_ip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">local_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">22</span>\n<span class=\"token key attr-name\">remote_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">6000</span></code></pre></div>\n<h2>Refrence</h2>\n<p><a href=\"https://github.com/fatedier/frp\">GitHub</a></p>\n<p><a href=\"https://gofrp.org/docs/\">中文文檔</a></p>","rawMarkdownBody":"\nfrp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。\n\n<!--more-->\n\nfrp 會需要一台 Server，Server 需要公網 ip，如果沒有公網 ip，可以使用 aws 或 gcp 買一個簡單的 VPS。\n\n## 安裝\n\n網路上有許多一鍵安裝的到腳本，但我們不使用那些，有興趣的自己上網搜尋。\n\n到官方 [Release](https://github.com/fatedier/frp/releases) 下載最新版，根據系統選擇，解壓後會看到 `frps` 、`frpc` 各有三個檔案，跟 `frps` 有關的就是 Server 端用的，`frpc` 的就是 Client 端用的。如果是 Server 端，就可以將 `frpc` 的檔案都刪除。\n\n## Server 端設定\n\n在 Server 上打開設定文件 `frps.ini` 可以看到預設就有如下的內容：\n\n```ini\n[common]\nbind_port = 7000\n```\n\n`common` 內綁定了 7000 port，這個 port 是讓 client 端連接用的，基本現在不用改設定就可以直接用。執行 `frps` 要用 `-c` 參數給定設定檔案：\n\n```shell\n./frps -c ./frps.ini\n```\n\n如果沒看到問題，基本上 Server 端就設定好了，其他功能晚點再介紹，我們先設定好 Client。\n\n## Client 端設定\n\nClient 就是要發布服務伺服器，所以雖然叫做 Client 但本身應該也是一台提供服務的 Server。Client 就可以刪除有關 `frps` 相關的檔案。\n\n一樣先打開設定檔 `frpc.ini`，也會有如下預設內容：\n\n```ini\n[common]\nserver_addr = 127.0.0.1\nserver_port = 7000\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n```\n\nClient 端的設定檔就不能直接用，需要修改 Server ip 才行，更改 `server_addr` 為剛剛 Server 端的 ip 地址或是 Domain 都可以。\n\n下方方的 ssh 區塊設一個將 Client 端的 ssh 22 port 公開到 Server 端的 6000 port 的範本，如果有其他的 port 要開放，用相同的思維更改即可。像是如過要加 Minecraft 25565 port 也到 Server 端的 25565 port，就可以新增一個區塊：\n\n```ini\n[common]\nserver_addr = example.com\nserver_port = 7000\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n\n[minecraft]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 25565\nremote_port = 25565\n```\n\n到目前為止應該就可以用 Server 端的 ip 連接到 Client 端了，如果連不上，可能要檢查一下 Server 端防火牆的設定，這邊就不贅述。\n\n## Token 認證\n\n不知道大家有沒有發現，基本上只要知道你 Server ip 或 domain 的人都可以新增自己的 port，要避免這樣的狀況，我們可以使用 token。使用方法也很簡單，只要在 Server 和 Client 端的 `[common]` 都加上相同的 token 參數，就可以進行簡單的認證。\n\nServer 端範例：\n\n```ini\n[common]\nbind_port = 7000\ntoken = 7Jc2ZCvVzHu\n```\n\nClient 端範例：\n\n```ini\n[common]\nserver_addr = example.com\nserver_port = 7000\ntoken = 7Jc2ZCvVzHu\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n```\n\n## Refrence\n\n[GitHub](https://github.com/fatedier/frp)\n\n[中文文檔](https://gofrp.org/docs/)\n","fileAbsolutePath":"/home/runner/work/HugoBlog/HugoBlog/src/posts/Linux/frp.md","excerpt":"frp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。 frp 會需要一台 Server，Server 需要公網 ip，如果沒有公網 ip，可以使用 aws 或 gcp 買一個簡單的 VPS。 安…","frontmatter":{"title":"Frp","date":"2021-06-20T13:48:33.000Z","draft":false,"tags":["frp","linux"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/34046c81-cb6e-40a5-7b3a-8623c613f400/public","description":"frp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。"}}},{"node":{"id":"44cfd44a-9733-56e8-8161-faf4d359aac4","html":"<p>我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。</p>\n<!--more-->\n<p>本篇使用 Kotlin 和 OKHttp，來嘗試撰寫一個應用程式，來協助發布 Markdwon 至 Medium，專案原始碼在 <a href=\"https://github.com/TonyPepeBear/MediumMarkdownUploader\">Github</a> 上。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/2021/02/10-21-47-48-%E6%88%AA%E5%9C%96%202021-02-10%20%E4%B8%8B%E5%8D%889.47.40.png\" alt=\"截圖 2021-02-10 下午9.47.40.png\"></p>\n<h2>申請 token</h2>\n<p>Medium API 的 <a href=\"https://github.com/Medium/medium-api-docs\">官方文件</a> 在這，可以用 <code class=\"language-text\">HTTP POST</code> 的方式來發布文章。要使用 API 第一件事就是要有 <code class=\"language-text\">token</code>，要申請 <code class=\"language-text\">token</code> 不用錢，官方目前好像也沒有使用限制，到 <a href=\"https://medium.com/me/settings\">用戶設定</a> 的頁面，找到 <code class=\"language-text\">Integration tokens</code> 的地方，申請一個 token，說明隨便輸入就好。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/2021/02/10-01-42-07-%E6%88%AA%E5%9C%96%202021-02-10%20%E4%B8%8A%E5%8D%881.42.04.png\" alt=\"img\"></p>\n<h2>UserID</h2>\n<p>根據官方文檔，想要發布文章，需要 UserID，我找了好久才發現 UserID 不是 Name 也不是 UserName，也是要先用 API 的方式取得。</p>\n<p>用 Http GET 的方式可以取得 token 主人資料，使用方式如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\">GET https://api.medium.com/v1/me</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">GET</span> <span class=\"token request-target url\">/v1/me</span> <span class=\"token http-version property\">HTTP/1.1</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">api.medium.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Authorization</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Bearer 181d415f34379af07b2c11d144dfbe35d</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept-Charset</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">utf-8</span></span></code></pre></div>\n<p><code class=\"language-text\">token</code> 是放在 Post 的 header，的 <code class=\"language-text\">Authorization:Bearer</code> 後方，下方是用 Kotlin 和 OKHttp 實作的方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> request <span class=\"token operator\">=</span> Request<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"https://api.medium.com/v1/me\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Authorization\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Bearer </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">token</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> response <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>範例的 Response 如下，可以拿到用 UserID、UserName 等資料：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"data\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"5303d74c64f66366f00cb9b2a94f3251bf5\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"username\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"majelbstoat\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Jamie Talbot\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://medium.com/@majelbstoat\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"imageUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://images.medium.com/0*fkfQiTzT7TlUGGyI.png\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>根據上方的 Json，可以產生 <code class=\"language-text\">Kotlin Data Class</code> 來放取回的資料：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">MediumApiMe</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> `<span class=\"token keyword\">data</span>`<span class=\"token operator\">:</span> MediumMeData\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">MediumMeData</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> id<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> imageUrl<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> url<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> username<span class=\"token operator\">:</span> String\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>取回的 Response 用 <code class=\"language-text\">gson</code> 轉換 json 到 Data Class，最後寫成一個完整的方法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">getUserData</span><span class=\"token punctuation\">(</span>token<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MediumApiMe <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> request <span class=\"token operator\">=</span> Request<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"https://api.medium.com/v1/me\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Authorization\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Bearer </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">token</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> response <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>code <span class=\"token operator\">!=</span> <span class=\"token number\">200</span> <span class=\"token operator\">||</span> response<span class=\"token punctuation\">.</span>body <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token function\">RuntimeException</span><span class=\"token punctuation\">(</span>\n            <span class=\"token string-literal singleline\"><span class=\"token string\">\"Can not get User info. Maybe token is wrong.\"</span></span> <span class=\"token operator\">+</span>\n            <span class=\"token punctuation\">{</span>response<span class=\"token punctuation\">.</span>body<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">byteStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">readLines</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">val</span> text <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>body<span class=\"token operator\">!!</span><span class=\"token punctuation\">.</span><span class=\"token function\">byteStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">readText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> gson<span class=\"token punctuation\">.</span><span class=\"token function\">fromJson</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">,</span> MediumApiMe<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上方的程式碼有判斷 Response Code 是否為 200，若不是 200 代表取得資料沒有成功，就拋出 Exception。</p>\n<h2>Post 文章</h2>\n<p>取得 UserID 後就可以用 Http Post 的方式向 Medium 發布文章。下方的 authorId 就是剛剛用 Http Get 的方式取得的 UserID。</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\">POST https://api.medium.com/v1/users/{{authorId}}/posts</code></pre></div>\n<p>下面是 Post 的範例，<code class=\"language-text\">token</code> 一樣是放在 <code class=\"language-text\">header</code> 裡。官方的範例是用 html 來發布文章，我們只要將 <code class=\"language-text\">contentFormat</code> 改成 markdown 就可以達成目的。</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">POST</span> <span class=\"token request-target url\">/v1/users/5303d74c64f66366f00cb9b2a94f3251bf5/posts</span> <span class=\"token http-version property\">HTTP/1.1</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">api.medium.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Authorization</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Bearer 181d415f34379af07b2c11d144dfbe35d</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept-Charset</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">utf-8</span></span>\n<span class=\"token application-json\">\n<span class=\"token punctuation\">{</span>\n  <span class=\"token string-property property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Liverpool FC\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string-property property\">\"contentFormat\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"html\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string-property property\">\"content\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"&lt;h1>Liverpool FC&lt;/h1>&lt;p>You’ll never walk alone.&lt;/p>\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string-property property\">\"canonicalUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://jamietalbot.com/posts/liverpool-fc\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string-property property\">\"tags\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"football\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"sport\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Liverpool\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string-property property\">\"publishStatus\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"public\"</span>\n<span class=\"token punctuation\">}</span></span></code></pre></div>\n<p>根據上面 Post 的 Json 範例，我們可以產生出如下的 Kotlin Data Class，我順便寫了一個快速轉成 Json 的方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">MediumApiPost</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> title<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> content<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> contentFormat<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> tags<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> publishStatus<span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"draft\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token comment\">//預設是草稿</span>\n    <span class=\"token keyword\">val</span> canonicalUrl<span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"\"</span></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">toJson</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> String <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> gson<span class=\"token punctuation\">.</span><span class=\"token function\">toJson</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>產生出 Data Class 就可以嘗試 Post 看看，是否會發布文章，直接利用剛剛寫好的 <code class=\"language-text\">getUserData</code> 拿到 UserID，之後在 Post：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> userID <span class=\"token operator\">=</span> <span class=\"token function\">getUserData</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">val</span> medimuApiPost <span class=\"token operator\">=</span>\n    <span class=\"token function\">MdieumApiPost</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Title\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"# Title\\nHi\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"markdown\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> request <span class=\"token operator\">=</span> Request<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"https://api.medium.com/v1/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">userID</span></span><span class=\"token string\">/posts\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span>mediumApiPost<span class=\"token punctuation\">.</span><span class=\"token function\">toJson</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toRequestBody</span><span class=\"token punctuation\">(</span>contentType <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"application/json\"</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">toMediaType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Authorization\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Bearer </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">token</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> response <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>如果發布成功，可以拿到 Response Code 201，其他的都代表發布失敗。</p>\n<p>寫成完整的發布方法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">newPost</span><span class=\"token punctuation\">(</span>token<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span> mediumApiPost<span class=\"token operator\">:</span> MediumApiPost<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> String <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> userID <span class=\"token operator\">=</span> <span class=\"token function\">getUserData</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>id\n\n    <span class=\"token keyword\">val</span> request <span class=\"token operator\">=</span> Request<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"https://api.medium.com/v1/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">userID</span></span><span class=\"token string\">/posts\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span>mediumApiPost<span class=\"token punctuation\">.</span><span class=\"token function\">toJson</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toRequestBody</span><span class=\"token punctuation\">(</span>contentType <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"application/json\"</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">toMediaType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Authorization\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Bearer </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">token</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> response <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>code <span class=\"token operator\">!=</span> <span class=\"token number\">201</span> <span class=\"token operator\">||</span> response<span class=\"token punctuation\">.</span>body <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token function\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Something Wrong. </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token expression\">response<span class=\"token punctuation\">.</span>body<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">byteStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">readText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">val</span> text <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>body<span class=\"token operator\">!!</span><span class=\"token punctuation\">.</span><span class=\"token function\">byteStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">readText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">var</span> json <span class=\"token operator\">=</span> gson<span class=\"token punctuation\">.</span><span class=\"token function\">fromJson</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">,</span> MediumNewPostResponse<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> json<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>url\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的方法會直接回傳發布成功的 URL，失敗則會直接拋出 Exception。</p>\n<h2>GUI</h2>\n<p>寫好方法後，最後再用 <code class=\"language-text\">TornadoFX</code> 寫 GUI，這邊就不講述 GUI 的部分，有興趣可以自己到 GitHub 上看專案的原始碼。</p>\n<h2>程式碼區塊</h2>\n<p>因為 Medium 目前並不支援程式碼高亮，傳上去的程式碼區塊都會變成黑底的，目前我有想到的解法是在 Post 上去之前，就先將程式碼區塊都換成 GitHub Gist，但這就需要更複雜的方式解決問題了，有興趣的人可以自己試試看。</p>\n<h2>Reference</h2>\n<p><a href=\"https://github.com/Medium/medium-api-docs\">Medium’s API Documentation</a></p>","rawMarkdownBody":"\n我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。\n\n<!--more-->\n\n本篇使用 Kotlin 和 OKHttp，來嘗試撰寫一個應用程式，來協助發布 Markdwon 至 Medium，專案原始碼在 [Github](https://github.com/TonyPepeBear/MediumMarkdownUploader) 上。\n\n![截圖 2021-02-10 下午9.47.40.png](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/2021/02/10-21-47-48-%E6%88%AA%E5%9C%96%202021-02-10%20%E4%B8%8B%E5%8D%889.47.40.png)\n\n## 申請 token\n\nMedium API 的 [官方文件](https://github.com/Medium/medium-api-docs) 在這，可以用 `HTTP POST` 的方式來發布文章。要使用 API 第一件事就是要有 `token`，要申請 `token` 不用錢，官方目前好像也沒有使用限制，到 [用戶設定](https://medium.com/me/settings) 的頁面，找到 `Integration tokens` 的地方，申請一個 token，說明隨便輸入就好。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/2021/02/10-01-42-07-%E6%88%AA%E5%9C%96%202021-02-10%20%E4%B8%8A%E5%8D%881.42.04.png)\n\n## UserID\n\n根據官方文檔，想要發布文章，需要 UserID，我找了好久才發現 UserID 不是 Name 也不是 UserName，也是要先用 API 的方式取得。\n\n用 Http GET 的方式可以取得 token 主人資料，使用方式如下：\n\n```http\nGET https://api.medium.com/v1/me\n```\n\n```http\nGET /v1/me HTTP/1.1\nHost: api.medium.com\nAuthorization: Bearer 181d415f34379af07b2c11d144dfbe35d\nContent-Type: application/json\nAccept: application/json\nAccept-Charset: utf-8\n```\n\n`token` 是放在 Post 的 header，的 `Authorization:Bearer` 後方，下方是用 Kotlin 和 OKHttp 實作的方法：\n\n```kotlin\nval request = Request.Builder()\n    .url(\"https://api.medium.com/v1/me\")\n    .get()\n    .addHeader(\"Authorization\", \"Bearer $token\")\n    .build()\nval response = client.newCall(request).execute()\n```\n\n範例的 Response 如下，可以拿到用 UserID、UserName 等資料：\n\n```json\n{\n  \"data\": {\n    \"id\": \"5303d74c64f66366f00cb9b2a94f3251bf5\",\n    \"username\": \"majelbstoat\",\n    \"name\": \"Jamie Talbot\",\n    \"url\": \"https://medium.com/@majelbstoat\",\n    \"imageUrl\": \"https://images.medium.com/0*fkfQiTzT7TlUGGyI.png\"\n  }\n}\n```\n\n根據上方的 Json，可以產生 `Kotlin Data Class` 來放取回的資料：\n\n```kotlin\ndata class MediumApiMe(\n    val `data`: MediumMeData\n)\n\ndata class MediumMeData(\n    val id: String,\n    val imageUrl: String,\n    val name: String,\n    val url: String,\n    val username: String\n)\n```\n\n取回的 Response 用 `gson` 轉換 json 到 Data Class，最後寫成一個完整的方法如下：\n\n```kotlin\nfun getUserData(token: String): MediumApiMe {\n    val request = Request.Builder()\n        .url(\"https://api.medium.com/v1/me\")\n        .get()\n        .addHeader(\"Authorization\", \"Bearer $token\")\n        .build()\n    val response = client.newCall(request).execute()\n    if (response.code != 200 || response.body == null)\n        throw RuntimeException(\n            \"Can not get User info. Maybe token is wrong.\" +\n            {response.body?.byteStream()?.reader()?.readLines()}\n        )\n\n    val text = response.body!!.byteStream()\n        .reader()\n        .readText()\n    return gson.fromJson(text, MediumApiMe::class.java)\n}\n```\n\n上方的程式碼有判斷 Response Code 是否為 200，若不是 200 代表取得資料沒有成功，就拋出 Exception。\n\n## Post 文章\n\n取得 UserID 後就可以用 Http Post 的方式向 Medium 發布文章。下方的 authorId 就是剛剛用 Http Get 的方式取得的 UserID。\n\n```http\nPOST https://api.medium.com/v1/users/{{authorId}}/posts\n```\n\n下面是 Post 的範例，`token` 一樣是放在 `header` 裡。官方的範例是用 html 來發布文章，我們只要將 `contentFormat` 改成 markdown 就可以達成目的。\n\n```http\nPOST /v1/users/5303d74c64f66366f00cb9b2a94f3251bf5/posts HTTP/1.1\nHost: api.medium.com\nAuthorization: Bearer 181d415f34379af07b2c11d144dfbe35d\nContent-Type: application/json\nAccept: application/json\nAccept-Charset: utf-8\n\n{\n  \"title\": \"Liverpool FC\",\n  \"contentFormat\": \"html\",\n  \"content\": \"<h1>Liverpool FC</h1><p>You’ll never walk alone.</p>\",\n  \"canonicalUrl\": \"http://jamietalbot.com/posts/liverpool-fc\",\n  \"tags\": [\"football\", \"sport\", \"Liverpool\"],\n  \"publishStatus\": \"public\"\n}\n```\n\n根據上面 Post 的 Json 範例，我們可以產生出如下的 Kotlin Data Class，我順便寫了一個快速轉成 Json 的方法：\n\n```kotlin\ndata class MediumApiPost(\n    val title: String,\n    val content: String,\n    val contentFormat: String,\n    val tags: List<String> = listOf(),\n    val publishStatus: String = \"draft\", //預設是草稿\n    val canonicalUrl: String = \"\",\n) {\n    fun toJson(): String {\n        return gson.toJson(this)\n    }\n}\n```\n\n產生出 Data Class 就可以嘗試 Post 看看，是否會發布文章，直接利用剛剛寫好的 `getUserData` 拿到 UserID，之後在 Post：\n\n```kotlin\nval userID = getUserData(token).data.id\nval medimuApiPost =\n    MdieumApiPost(\"Title\", \"# Title\\nHi\", \"markdown\")\nval request = Request.Builder()\n    .url(\"https://api.medium.com/v1/users/$userID/posts\")\n    .post(mediumApiPost.toJson().toRequestBody(contentType = \"application/json\".toMediaType()))\n    .addHeader(\"Authorization\", \"Bearer $token\")\n    .build()\nval response = client.newCall(request).execute()\n```\n\n如果發布成功，可以拿到 Response Code 201，其他的都代表發布失敗。\n\n寫成完整的發布方法如下：\n\n```kotlin\nfun newPost(token: String, mediumApiPost: MediumApiPost): String {\n    val userID = getUserData(token).data.id\n\n    val request = Request.Builder()\n        .url(\"https://api.medium.com/v1/users/$userID/posts\")\n        .post(mediumApiPost.toJson().toRequestBody(contentType = \"application/json\".toMediaType()))\n        .addHeader(\"Authorization\", \"Bearer $token\")\n        .build()\n    val response = client.newCall(request).execute()\n\n    if (response.code != 201 || response.body == null)\n        throw RuntimeException(\"Something Wrong. ${response.body?.byteStream()?.reader()?.readText()}\")\n\n    val text = response.body!!.byteStream().reader().readText()\n    println(text)\n\n    var json = gson.fromJson(text, MediumNewPostResponse::class.java)\n\n    return json.data.url\n}\n```\n\n上面的方法會直接回傳發布成功的 URL，失敗則會直接拋出 Exception。\n\n## GUI\n\n寫好方法後，最後再用 `TornadoFX` 寫 GUI，這邊就不講述 GUI 的部分，有興趣可以自己到 GitHub 上看專案的原始碼。\n\n## 程式碼區塊\n\n因為 Medium 目前並不支援程式碼高亮，傳上去的程式碼區塊都會變成黑底的，目前我有想到的解法是在 Post 上去之前，就先將程式碼區塊都換成 GitHub Gist，但這就需要更複雜的方式解決問題了，有興趣的人可以自己試試看。\n\n## Reference\n\n[Medium’s API Documentation](https://github.com/Medium/medium-api-docs)\n","fileAbsolutePath":"/home/runner/work/HugoBlog/HugoBlog/src/posts/Kotlin/medium-api.md","excerpt":"我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。 本篇…","frontmatter":{"title":"發布 Markdown 至 Medium","date":"2021-06-15T18:35:56.000Z","draft":false,"tags":["medium","markdown","kotlin","tornadofx"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/98587dc3-5d4e-446a-7d98-b0b1ad36d500/public","description":"我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。"}}},{"node":{"id":"452d39ba-0e74-5399-a486-613e25c014ac","html":"<p>其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩，要先經過不少設定。而且在官方的文件中，其實是教你怎麼建置專案，執行 Debug，如果只是寫一點簡單的小程式根本用不到那麼複雜的設定，所以本文是我目前發現比較容易在 VSCode 中執行 C 和 C++ 的方法。</p>\n<!--more-->\n<h2>gcc g++</h2>\n<p>在了解如何設定 vscode 前，我們先來了解一下基本的 gcc、g++ 指令，這是一個用來編譯 C 程式碼最快的方法，gcc 就是 C 的編譯器，g++ 則是 C++ 的。這裡不會解說如何安裝，在 Windows 下可以使用 MinGW，macOS 則是只要在 Terminal 下 gcc 指令，就會自動問你要不要安裝。</p>\n<p>下面的範例會編譯 <code class=\"language-text\">main.cpp</code> 的 C++ 檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">g++ main.cpp</code></pre></div>\n<p>執行上面的指令後，會產生名為 <code class=\"language-text\">a.out</code> 的檔案，因為我們沒有指定輸出檔名，所以預設就是 <code class=\"language-text\">a.out</code>，在 Windows 上則為 <code class=\"language-text\">a.exe</code> 的執行檔。如果要執行產生的執行檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">./a.out\n./a.exe <span class=\"token comment\"># On Windows</span></code></pre></div>\n<p>要指定輸出檔名也很簡單，加個 <code class=\"language-text\">-o</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">g++ -o main.out main.cpp</code></pre></div>\n<p>這樣就可以將 <code class=\"language-text\">main.cpp</code> 編譯成 <code class=\"language-text\">main.out</code> 的執行檔。</p>\n<p>上面這些不會也沒關係，但我還是建議了解一下，因為等一下要安裝的模組，只是幫你完成這些步驟，如果完全不了解指令的功能，發生問題可能自己會沒辦法解決。</p>\n<h2>設定 VSCode</h2>\n<p>第一步就是先在 VSCode 中安裝 <strong>C/C++</strong>，和 <strong>Code Runner</strong>，兩個延伸模組。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608014749.png\" alt=\"img\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608021309.png\" alt=\"img\"></p>\n<p>安裝完成後，應該就會看到右上角出現了一個執行的按鈕，可以按按看程式會不會執行。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608021808.png\" alt=\"img\"></p>\n<p>如果找不到按鈕，或是想要停下程式，也可以用按下 <code class=\"language-text\">f1</code> 的方式叫出 VSCode 的指令輸入窗，輸入 <code class=\"language-text\">Run Code</code> 或是 <code class=\"language-text\">Stop Code Run</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608022037.png\" alt=\"img\"></p>\n<h2>Run In Terminal</h2>\n<p>現在可能會發先一個問題，這種執行模式是沒有辦法接收鍵盤輸入的，如果想要接收鍵盤輸入，我們要把執行模式改成在 Terminal 中。所以我們要開啟 VSCode 的 <code class=\"language-text\">settings.json</code> 設定檔，來更改設定，一樣是用 <code class=\"language-text\">f1</code> 叫出命令輸入區，並尋找 <code class=\"language-text\">open settings json</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608024052.png\" alt=\"img\"></p>\n<p>打開後在裡面新增一行：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token property\">\"code-runner.runInTerminal\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span></code></pre></div>\n<p>如果前方有其他設定值，記得在前面的設定值的最後面加個逗號 <code class=\"language-text\">,</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608024259.png\" alt=\"img\"></p>\n<p>現在就可以方便的在 VSCode 中寫 C，和方便的執行他們。</p>","rawMarkdownBody":"\n其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩，要先經過不少設定。而且在官方的文件中，其實是教你怎麼建置專案，執行 Debug，如果只是寫一點簡單的小程式根本用不到那麼複雜的設定，所以本文是我目前發現比較容易在 VSCode 中執行 C 和 C++ 的方法。\n\n<!--more-->\n\n## gcc g++\n\n在了解如何設定 vscode 前，我們先來了解一下基本的 gcc、g++ 指令，這是一個用來編譯 C 程式碼最快的方法，gcc 就是 C 的編譯器，g++ 則是 C++ 的。這裡不會解說如何安裝，在 Windows 下可以使用 MinGW，macOS 則是只要在 Terminal 下 gcc 指令，就會自動問你要不要安裝。\n\n下面的範例會編譯 `main.cpp` 的 C++ 檔案：\n\n```bash\ng++ main.cpp\n```\n\n執行上面的指令後，會產生名為 `a.out` 的檔案，因為我們沒有指定輸出檔名，所以預設就是 `a.out`，在 Windows 上則為 `a.exe` 的執行檔。如果要執行產生的執行檔案：\n\n```bash\n./a.out\n./a.exe # On Windows\n```\n\n要指定輸出檔名也很簡單，加個 `-o`：\n\n```bash\ng++ -o main.out main.cpp\n```\n\n這樣就可以將 `main.cpp` 編譯成 `main.out` 的執行檔。\n\n上面這些不會也沒關係，但我還是建議了解一下，因為等一下要安裝的模組，只是幫你完成這些步驟，如果完全不了解指令的功能，發生問題可能自己會沒辦法解決。\n\n## 設定 VSCode\n\n第一步就是先在 VSCode 中安裝 **C/C++**，和 **Code Runner**，兩個延伸模組。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608014749.png)\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608021309.png)\n\n安裝完成後，應該就會看到右上角出現了一個執行的按鈕，可以按按看程式會不會執行。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608021808.png)\n\n如果找不到按鈕，或是想要停下程式，也可以用按下 `f1` 的方式叫出 VSCode 的指令輸入窗，輸入 `Run Code` 或是 `Stop Code Run`。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608022037.png)\n\n## Run In Terminal\n\n現在可能會發先一個問題，這種執行模式是沒有辦法接收鍵盤輸入的，如果想要接收鍵盤輸入，我們要把執行模式改成在 Terminal 中。所以我們要開啟 VSCode 的 `settings.json` 設定檔，來更改設定，一樣是用 `f1` 叫出命令輸入區，並尋找 `open settings json`：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608024052.png)\n\n打開後在裡面新增一行：\n\n```json\n\"code-runner.runInTerminal\": true\n```\n\n如果前方有其他設定值，記得在前面的設定值的最後面加個逗號 `,`：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608024259.png)\n\n現在就可以方便的在 VSCode 中寫 C，和方便的執行他們。\n","fileAbsolutePath":"/home/runner/work/HugoBlog/HugoBlog/src/posts/VSCode/vscode-clang.md","excerpt":"其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩，要先經過不少設定。而且在官方的文件中，其實是教你怎麼建置專案，執行 Debug，如果只是寫一點簡單的小程式根本用不到那麼複雜的設定，所以本文是我目前發現比較容易在 VSCode 中執行 C 和 C++ 的方法。 …","frontmatter":{"title":"用 VSCode 寫 C/C++","date":"2021-06-07T16:55:19.000Z","draft":false,"tags":["vscode","code","c","c++"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/48d8b9f1-209f-44ab-0f7b-92b5f082a500/public","description":"其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩。"}}},{"node":{"id":"e69b1e6f-731c-5bb3-9b80-b4702f9fa493","html":"<p>Github Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到 <code class=\"language-text\">gh-pages</code> 的 git 分支。</p>\n<!--more-->\n<p>Github Actions 也是容器化技術的一環，也是類似 Docker 容器的一種，如果對 Docker 還不熟悉，應該會對本文有點吃力，但也可以對完全不了解 Docker 的人，多一點對容器化技術的認識。</p>\n<h2>編寫 Workflows 檔案</h2>\n<p>Workflows 工作流檔案，就是在 CI/CD 中最重要的檔案，這個檔案寫下這個專案的工作流程，像是如何 Test、交付成品，都是寫在這的檔案裡，Github 會自動讀取所有工作留檔案和自動執行，所以只要寫好一次，基本上就一勞永逸，每次只需要 Push，Gihtub 就會按照腳本完成指定的工作。</p>\n<p>Github Actions 的 Worksflows 檔案都是放在專案跟目錄的 <code class=\"language-text\">/.github/workflows</code> 這個資料夾中，Github 會讀取這個資料夾中的 <code class=\"language-text\">*.yml</code> 檔案，並且自動執行他們。我們現在在這個目錄下新增一個叫做 <code class=\"language-text\">hugo-public.yml</code> 的檔案，檔名可以自訂沒關係，Github 不會關心檔名長怎樣，如果有多個檔案也每個都會分別執行。</p>\n<p>我們在現在 <code class=\"language-text\">/.github/workflows/hugo-public.yml</code> 的檔案中新增如下的腳本：</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> github pages\n\n<span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> master <span class=\"token comment\"># Set a branch to deploy</span>\n  <span class=\"token key atrule\">pull_request</span><span class=\"token punctuation\">:</span>\n\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span><span class=\"token number\">20.04</span>\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">submodules</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span> <span class=\"token comment\"># Fetch Hugo themes (true OR recursive)</span>\n          <span class=\"token key atrule\">fetch-depth</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token comment\"># Fetch all history for .GitInfo and .Lastmod</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Hugo\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>hugo@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">hugo-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"latest\"</span>\n          <span class=\"token key atrule\">extended</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> hugo <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>minify\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Deploy\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>gh<span class=\"token punctuation\">-</span>pages@v3\n        <span class=\"token key atrule\">if</span><span class=\"token punctuation\">:</span> github.ref == 'refs/heads/master'\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">github_token</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.ACCESS_TOKEN <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n          <span class=\"token key atrule\">publish_dir</span><span class=\"token punctuation\">:</span> ./public</code></pre></div>\n<p>下面我們分段來解釋上面腳本每行的意思。</p>\n<h2>Name</h2>\n<p>基本上就是這個腳本的名稱，可以隨意自訂不會影響結果。</p>\n<h2>On</h2>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> master <span class=\"token comment\"># Set a branch to deploy</span>\n  pull_request<span class=\"token punctuation\">:</span></code></pre></div>\n<p><code class=\"language-text\">on</code> 區段定義了這個腳本什麼時候會被執行，我們現在這個範例中，定義了這個腳本會在 <code class=\"language-text\">master</code> 這個分支被 push 的時候自動執行。Github 現在預設的分支名稱是 <code class=\"language-text\">main</code>，如果是 <code class=\"language-text\">main</code> 的人千萬要記得改，以免這個腳本永遠不會執行。</p>\n<h2>Jobs</h2>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 以下省略</span></code></pre></div>\n<p>jobs 是整個檔案中最核心的部分，可以分成許多不同的 Job，目前我們只有一個叫做 <code class=\"language-text\">deploy</code> 的 Job，這個名稱也是可以自訂的，這裡只是取叫 <code class=\"language-text\">deploy</code> 看不順眼可以自己換。如果還需要有其他工作，可以自己視情況增加。</p>\n<h3>Job</h3>\n<p>終於來到最核心的部分，deploy 任務中的第一行，就定義了這個任務要 Run 在哪個容器內，或是稱作哪個系統內。這邊是用 <code class=\"language-text\">ubuntu</code> 的 20.04，建議不要亂改，因為其他的 Linux 不一定可以完任務。</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span><span class=\"token number\">20.04</span>\n  <span class=\"token comment\">## 以下省略</span></code></pre></div>\n<h3>Steps</h3>\n<p>接下來就是分步驟執行命令，<code class=\"language-text\">uses</code> 是利用 Github 上別人已經寫好的 Actions 腳本來執行命令，像是第一個 <code class=\"language-text\">uses: actions/checkout@v2</code> 就是李用 Github 上別人已經寫好的 <code class=\"language-text\">git checkout</code> 命令來把專案 checkout 到容器中。</p>\n<p>第二個部分也是使用別人已經寫好的腳本，快速的安裝 Hugo 到容器內，用別人寫好的東西來完成工作，避免不必要的重複造輪子。</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n    <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">submodules</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>  <span class=\"token comment\"># Fetch Hugo themes (true OR recursive)</span>\n        <span class=\"token key atrule\">fetch-depth</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span>    <span class=\"token comment\"># Fetch all history for .GitInfo and .Lastmod</span>\n\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Hugo\n    <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>hugo@v2\n    <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">hugo-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'latest'</span>\n        <span class=\"token key atrule\">extended</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build\n    <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> hugo <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>minify\n\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Deploy\n    <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>gh<span class=\"token punctuation\">-</span>pages@v3\n    <span class=\"token key atrule\">if</span><span class=\"token punctuation\">:</span> github.ref == 'refs/heads/master'\n    <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">github_token</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.ACCESS_TOKEN <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n        <span class=\"token key atrule\">publish_dir</span><span class=\"token punctuation\">:</span> ./public</code></pre></div>\n<p>看到這裡也可以發現任務也是分很多步驟，第三部分的 Build 就是像是我們在本機目錄的產生方法一樣，直接輸入 <code class=\"language-text\">hugo</code> 命令產生靜態網頁。</p>\n<p>第四部分的 Deploy 就會比較複雜，這邊也是利用別人寫好用來發布 Github Pages 的任務，他會需要一個 Github Token，這個 Token 是要用來對 Repository 有 Push 的權限，雖然可以直接寫在腳本裡，但是就所有人都看得到你的 Token，那就會產生資安問題。所以 Github 提供 Secrets 的模式，可以把不方便直接寫在專案裡的機敏資料，放在 Github 上。</p>\n<p>所以我們現在會有兩件事要做：</p>\n<ol>\n<li>產生 Token</li>\n<li>把 Token 放到專案的 Secrets 中</li>\n</ol>\n<p>我們先來產生 Token，先到個人的設定頁面找到 Developer settings：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9cec1b4f-5bf6-4e41-9177-3cbe9ccfd400/large\" alt=\"img\"></p>\n<p>再到 Token 的頁面產生新的 Token：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/dfa652f6-b8b1-4df2-5b7f-ccdda2e8df00/large\" alt=\"img\"></p>\n<p>名稱可以自己隨意訂，Repo 的權限就全部打開，除了 Repo 以外的權限則都不需要。都確定後直接拉到最下面產生 Token：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/94de0480-f57a-4bef-b1e1-9ce3f75d2c00/large\" alt=\"img\"></p>\n<p>會得到一組新的 Token，請注意不要像我一樣 Show 出來給別人看，請妥善保存，而且 Github 也只會顯示這一次，以後想要看都看不到，只能產生新的 Token。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/13bcbfe0-5bbc-4292-5679-cd5d1dba9f00/large\" alt=\"img\"></p>\n<p>複製下 Token 後，我們到專案層級的設定，注意是<strong>專案</strong>的設定，不是個人設定：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d5b06f39-8b64-4f76-3f68-84d30fbc9a00/large\" alt=\"img\"></p>\n<p>找到 Secrets 並新增 Secrets：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/409789e1-87f4-4469-fcf4-032a27e05700/large\" alt=\"img\"></p>\n<p>名字取好後，填入剛剛拿到的 Token，注意名稱要和剛剛在腳本中寫的一樣：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8e7912d5-53fc-491a-a638-bee48f87be00/large\" alt=\"img\"></p>\n<p>都填完後就大功告成，基本上只要 Push 到 Github 上，應該就會自動觸發上面寫的工作，以後只要文章有新的變動，Push 上來就會自動更新網頁網頁到專案的 <code class=\"language-text\">gh-pages</code> 分之上。想要進一步看到 Pages 的設定，可以到專案下的 Pages 的設定下看看，也可以在這裡自訂 Domian。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/e1c327a2-2e73-45ff-7305-a8440010d600/large\" alt=\"img\"></p>","rawMarkdownBody":"\nGithub Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到 `gh-pages` 的 git 分支。\n\n<!--more-->\n\nGithub Actions 也是容器化技術的一環，也是類似 Docker 容器的一種，如果對 Docker 還不熟悉，應該會對本文有點吃力，但也可以對完全不了解 Docker 的人，多一點對容器化技術的認識。\n\n## 編寫 Workflows 檔案\n\nWorkflows 工作流檔案，就是在 CI/CD 中最重要的檔案，這個檔案寫下這個專案的工作流程，像是如何 Test、交付成品，都是寫在這的檔案裡，Github 會自動讀取所有工作留檔案和自動執行，所以只要寫好一次，基本上就一勞永逸，每次只需要 Push，Gihtub 就會按照腳本完成指定的工作。\n\nGithub Actions 的 Worksflows 檔案都是放在專案跟目錄的 `/.github/workflows` 這個資料夾中，Github 會讀取這個資料夾中的 `*.yml` 檔案，並且自動執行他們。我們現在在這個目錄下新增一個叫做 `hugo-public.yml` 的檔案，檔名可以自訂沒關係，Github 不會關心檔名長怎樣，如果有多個檔案也每個都會分別執行。\n\n我們在現在 `/.github/workflows/hugo-public.yml` 的檔案中新增如下的腳本：\n\n```yml\nname: github pages\n\non:\n  push:\n    branches:\n      - master # Set a branch to deploy\n  pull_request:\n\njobs:\n  deploy:\n    runs-on: ubuntu-20.04\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          submodules: true # Fetch Hugo themes (true OR recursive)\n          fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod\n\n      - name: Setup Hugo\n        uses: peaceiris/actions-hugo@v2\n        with:\n          hugo-version: \"latest\"\n          extended: true\n\n      - name: Build\n        run: hugo --minify\n\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        if: github.ref == 'refs/heads/master'\n        with:\n          github_token: ${{ secrets.ACCESS_TOKEN }}\n          publish_dir: ./public\n```\n\n下面我們分段來解釋上面腳本每行的意思。\n\n## Name\n\n基本上就是這個腳本的名稱，可以隨意自訂不會影響結果。\n\n## On\n\n```yml\non:\n  push:\n    branches:\n      - master # Set a branch to deploy\n  pull_request:\n```\n\n`on` 區段定義了這個腳本什麼時候會被執行，我們現在這個範例中，定義了這個腳本會在 `master` 這個分支被 push 的時候自動執行。Github 現在預設的分支名稱是 `main`，如果是 `main` 的人千萬要記得改，以免這個腳本永遠不會執行。\n\n## Jobs\n\n```yml\njobs:\n  deploy:\n    # 以下省略\n```\n\njobs 是整個檔案中最核心的部分，可以分成許多不同的 Job，目前我們只有一個叫做 `deploy` 的 Job，這個名稱也是可以自訂的，這裡只是取叫 `deploy` 看不順眼可以自己換。如果還需要有其他工作，可以自己視情況增加。\n\n### Job\n\n終於來到最核心的部分，deploy 任務中的第一行，就定義了這個任務要 Run 在哪個容器內，或是稱作哪個系統內。這邊是用 `ubuntu` 的 20.04，建議不要亂改，因為其他的 Linux 不一定可以完任務。\n\n```yml\ndeploy:\n  runs-on: ubuntu-20.04\n  ## 以下省略\n```\n\n### Steps\n\n接下來就是分步驟執行命令，`uses` 是利用 Github 上別人已經寫好的 Actions 腳本來執行命令，像是第一個 `uses: actions/checkout@v2` 就是李用 Github 上別人已經寫好的 `git checkout` 命令來把專案 checkout 到容器中。\n\n第二個部分也是使用別人已經寫好的腳本，快速的安裝 Hugo 到容器內，用別人寫好的東西來完成工作，避免不必要的重複造輪子。\n\n```yml\nsteps:\n    - uses: actions/checkout@v2\n    with:\n        submodules: true  # Fetch Hugo themes (true OR recursive)\n        fetch-depth: 0    # Fetch all history for .GitInfo and .Lastmod\n\n    - name: Setup Hugo\n    uses: peaceiris/actions-hugo@v2\n    with:\n        hugo-version: 'latest'\n        extended: true\n\n    - name: Build\n    run: hugo --minify\n\n    - name: Deploy\n    uses: peaceiris/actions-gh-pages@v3\n    if: github.ref == 'refs/heads/master'\n    with:\n        github_token: ${{ secrets.ACCESS_TOKEN }}\n        publish_dir: ./public\n```\n\n看到這裡也可以發現任務也是分很多步驟，第三部分的 Build 就是像是我們在本機目錄的產生方法一樣，直接輸入 `hugo` 命令產生靜態網頁。\n\n第四部分的 Deploy 就會比較複雜，這邊也是利用別人寫好用來發布 Github Pages 的任務，他會需要一個 Github Token，這個 Token 是要用來對 Repository 有 Push 的權限，雖然可以直接寫在腳本裡，但是就所有人都看得到你的 Token，那就會產生資安問題。所以 Github 提供 Secrets 的模式，可以把不方便直接寫在專案裡的機敏資料，放在 Github 上。\n\n所以我們現在會有兩件事要做：\n\n1. 產生 Token\n2. 把 Token 放到專案的 Secrets 中\n\n我們先來產生 Token，先到個人的設定頁面找到 Developer settings：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9cec1b4f-5bf6-4e41-9177-3cbe9ccfd400/large)\n\n再到 Token 的頁面產生新的 Token：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/dfa652f6-b8b1-4df2-5b7f-ccdda2e8df00/large)\n\n名稱可以自己隨意訂，Repo 的權限就全部打開，除了 Repo 以外的權限則都不需要。都確定後直接拉到最下面產生 Token：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/94de0480-f57a-4bef-b1e1-9ce3f75d2c00/large)\n\n會得到一組新的 Token，請注意不要像我一樣 Show 出來給別人看，請妥善保存，而且 Github 也只會顯示這一次，以後想要看都看不到，只能產生新的 Token。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/13bcbfe0-5bbc-4292-5679-cd5d1dba9f00/large)\n\n複製下 Token 後，我們到專案層級的設定，注意是**專案**的設定，不是個人設定：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d5b06f39-8b64-4f76-3f68-84d30fbc9a00/large)\n\n找到 Secrets 並新增 Secrets：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/409789e1-87f4-4469-fcf4-032a27e05700/large)\n\n名字取好後，填入剛剛拿到的 Token，注意名稱要和剛剛在腳本中寫的一樣：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8e7912d5-53fc-491a-a638-bee48f87be00/large)\n\n都填完後就大功告成，基本上只要 Push 到 Github 上，應該就會自動觸發上面寫的工作，以後只要文章有新的變動，Push 上來就會自動更新網頁網頁到專案的 `gh-pages` 分之上。想要進一步看到 Pages 的設定，可以到專案下的 Pages 的設定下看看，也可以在這裡自訂 Domian。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/e1c327a2-2e73-45ff-7305-a8440010d600/large)\n","fileAbsolutePath":"/home/runner/work/HugoBlog/HugoBlog/src/posts/Hugo/hugo-github-actions.md","excerpt":"Github Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到  …","frontmatter":{"title":"用 Github Actions 來發布 Hugo 靜態網頁","date":"2021-06-07T14:00:53.000Z","draft":false,"tags":["hugo","github","github-actions","web"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/3820056d-8496-4b29-efa0-716d71a45100/public","description":"Github Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到 gh-pages 的 git 分支。"}}},{"node":{"id":"f3a9e4cd-72db-530a-a765-8befdead2d5b","html":"<p>Hugo 是靜態網頁的產生器，類似 Hexo 和 Jekyll，Hugo 由 go 語言編寫，效率極高，我原本是用 Hexo 在產生文章，後來發現 Hugo 這個好東西，也觀望了一陣子<del>其實是懶</del>，就決定換過來了，目前也用得非常順手。</p>\n<!--more-->\n<h2>安裝 Hugo</h2>\n<p>這是 Hugo 的<a href=\"https://gohugo.io/\">官網</a>，進去後可以看到一些簡單的介紹和安裝方法。</p>\n<p>我蠻推薦在 vscode 的 <code class=\"language-text\">code in container</code> 的方式用 Hugo，因為我自己也是這樣用，這樣就不用擔心會弄髒環境，但就讓有興趣的人自己研究吧，這裡我介紹一般電腦的安裝方式。</p>\n<h3>Windows</h3>\n<p>Windows 我建議是用 Chocolatey 來安裝是最方便的：</p>\n<div class=\"gatsby-highlight\" data-language=\"ps1\"><pre class=\"language-ps1\"><code class=\"language-ps1\">choco install hugo</code></pre></div>\n<p>但是如果不想要用 Chocolatey 安裝，可以去官方的 <a href=\"https://github.com/gohugoio/hugo/releases\">Github Release</a> 下載最新的 Windows 版本，下載完後記得加入 PATH。</p>\n<h3>Mac</h3>\n<p>macOS 安裝最簡單，用 Homebrew 就可以快速的安裝。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">brew <span class=\"token function\">install</span> hugo</code></pre></div>\n<h3>Linux</h3>\n<p>Linux 我一律建議從官方的 <a href=\"https://github.com/gohugoio/hugo/releases\">Github Release</a> 下載最新的版本，並自己加到 PATH。</p>\n<p>雖然 apt 等版本管理器好像有提供，但官方的文件上都說版本幾乎都不是最新版，所以也不建議。用下載的方式還是最方便的，或是用 Docker 也是好辦法。</p>\n<h2>開始使用 Hugo</h2>\n<p>先創建一個新的 Hugo 專案，下面的 <code class=\"language-text\">MyBlog</code> 可以換成自己想要的專案名稱：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">hugo new site MyBlog</code></pre></div>\n<h3>新增主題</h3>\n<p>創建好專案後，就可以來新增主題，目前在 Hugo 上提供非常多的主題，我們可以到官方的這個<a href=\"https://themes.gohugo.io/\">網站</a>找找看，但目前些不要增加難度，用最官房提供的簡單的 ananke 主題就好，反正主題是隨時都可以換的。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> MyBlog\n<span class=\"token function\">git</span> init\n<span class=\"token function\">git</span> submodule <span class=\"token function\">add</span> https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke\n<span class=\"token builtin class-name\">echo</span> theme <span class=\"token operator\">=</span> <span class=\"token punctuation\">\\</span>\"ananke<span class=\"token punctuation\">\\</span>\" <span class=\"token operator\">>></span> config.toml</code></pre></div>\n<p>可以看到，官方是建議使用 <code class=\"language-text\">git submodule</code> 的方式新增主題，這樣之後在更新主題的時候也比較方便。</p>\n<p>最後一行的 <code class=\"language-text\">echo</code> 指令會在專案底下產生一個 <code class=\"language-text\">config.toml</code> 的檔案，基本上之後所有有關 Hugo 網站的設定，都可以在這裡變更。這一行指令應該會幫你在檔案中產生如下的內容：</p>\n<div class=\"gatsby-highlight\" data-language=\"toml\"><pre class=\"language-toml\"><code class=\"language-toml\"><span class=\"token key property\">theme</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"ananke\"</span></code></pre></div>\n<h3>新增文章</h3>\n<p>在 Hugo 中新增文章的指令就是如下，可以自己修改檔名。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">hugo new posts/my-first-post.md</code></pre></div>\n<p>產生完成後可以看到 Hugo 幫你產生了一些 Front Matter。</p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token front-matter-block\"><span class=\"token punctuation\">---</span>\n<span class=\"token front-matter yaml language-yaml\"><span class=\"token key atrule\">title</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"My First Post\"</span>\n<span class=\"token key atrule\">date</span><span class=\"token punctuation\">:</span> <span class=\"token datetime number\">2019-03-26T08:47:11+01:00</span>\n<span class=\"token key atrule\">draft</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span></span>\n<span class=\"token punctuation\">---</span></span></code></pre></div>\n<p>上面的 <code class=\"language-text\">draft</code> 的指令是草稿的意思，如果沒有在上線前改成 <code class=\"language-text\">false</code>，是不會在正式網站中渲染的。</p>\n<p>現在可以自己產生的 Markdown 檔案中加一些內容，等等就可以看看效果怎麼樣。</p>\n<h2>執行 Hugo Server</h2>\n<p>要啟動 Hugo Server 也非常簡單：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">hugo server -D</code></pre></div>\n<p>上面的 <code class=\"language-text\">-D</code> 參數的意思是把 <code class=\"language-text\">draft</code> 的草稿文件也渲染，如果想要看看上線的網頁會長怎樣，可以不要加上這個參數。</p>\n<h2>產生靜態網頁</h2>\n<p>這個最簡單了，連猴子都會，<code class=\"language-text\">-D</code> 的參數一樣是渲染草稿文件，可視需求加上。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">hugo</code></pre></div>\n<p>到這裡就介紹完成所有 Hugo 基本的使用方法了，之後我會介紹如何使用 Github Actio\bn，讓我們每次只需要 Push 專案，Github 就會幫我們重新建置並部署網站。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://gohugo.io/getting-started/quick-start/\">Hugo Quick Start</a></li>\n</ul>","rawMarkdownBody":"\nHugo 是靜態網頁的產生器，類似 Hexo 和 Jekyll，Hugo 由 go 語言編寫，效率極高，我原本是用 Hexo 在產生文章，後來發現 Hugo 這個好東西，也觀望了一陣子~~其實是懶~~，就決定換過來了，目前也用得非常順手。\n\n<!--more-->\n\n## 安裝 Hugo\n\n這是 Hugo 的[官網](https://gohugo.io/)，進去後可以看到一些簡單的介紹和安裝方法。\n\n我蠻推薦在 vscode 的 `code in container` 的方式用 Hugo，因為我自己也是這樣用，這樣就不用擔心會弄髒環境，但就讓有興趣的人自己研究吧，這裡我介紹一般電腦的安裝方式。\n\n### Windows\n\nWindows 我建議是用 Chocolatey 來安裝是最方便的：\n\n```ps1\nchoco install hugo\n```\n\n但是如果不想要用 Chocolatey 安裝，可以去官方的 [Github Release](https://github.com/gohugoio/hugo/releases) 下載最新的 Windows 版本，下載完後記得加入 PATH。\n\n### Mac\n\nmacOS 安裝最簡單，用 Homebrew 就可以快速的安裝。\n\n```bash\nbrew install hugo\n```\n\n### Linux\n\nLinux 我一律建議從官方的 [Github Release](https://github.com/gohugoio/hugo/releases) 下載最新的版本，並自己加到 PATH。\n\n雖然 apt 等版本管理器好像有提供，但官方的文件上都說版本幾乎都不是最新版，所以也不建議。用下載的方式還是最方便的，或是用 Docker 也是好辦法。\n\n## 開始使用 Hugo\n\n先創建一個新的 Hugo 專案，下面的 `MyBlog` 可以換成自己想要的專案名稱：\n\n```bash\nhugo new site MyBlog\n```\n\n### 新增主題\n\n創建好專案後，就可以來新增主題，目前在 Hugo 上提供非常多的主題，我們可以到官方的這個[網站](https://themes.gohugo.io/)找找看，但目前些不要增加難度，用最官房提供的簡單的 ananke 主題就好，反正主題是隨時都可以換的。\n\n```bash\ncd MyBlog\ngit init\ngit submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke\necho theme = \\\"ananke\\\" >> config.toml\n```\n\n可以看到，官方是建議使用 `git submodule` 的方式新增主題，這樣之後在更新主題的時候也比較方便。\n\n最後一行的 `echo` 指令會在專案底下產生一個 `config.toml` 的檔案，基本上之後所有有關 Hugo 網站的設定，都可以在這裡變更。這一行指令應該會幫你在檔案中產生如下的內容：\n\n```toml\ntheme = \"ananke\"\n```\n\n### 新增文章\n\n在 Hugo 中新增文章的指令就是如下，可以自己修改檔名。\n\n```bash\nhugo new posts/my-first-post.md\n```\n\n產生完成後可以看到 Hugo 幫你產生了一些 Front Matter。\n\n```md\n---\ntitle: \"My First Post\"\ndate: 2019-03-26T08:47:11+01:00\ndraft: true\n---\n```\n\n上面的 `draft` 的指令是草稿的意思，如果沒有在上線前改成 `false`，是不會在正式網站中渲染的。\n\n現在可以自己產生的 Markdown 檔案中加一些內容，等等就可以看看效果怎麼樣。\n\n## 執行 Hugo Server\n\n要啟動 Hugo Server 也非常簡單：\n\n```bash\nhugo server -D\n```\n\n上面的 `-D` 參數的意思是把 `draft` 的草稿文件也渲染，如果想要看看上線的網頁會長怎樣，可以不要加上這個參數。\n\n## 產生靜態網頁\n\n這個最簡單了，連猴子都會，`-D` 的參數一樣是渲染草稿文件，可視需求加上。\n\n```bash\nhugo\n```\n\n到這裡就介紹完成所有 Hugo 基本的使用方法了，之後我會介紹如何使用 Github Actio\bn，讓我們每次只需要 Push 專案，Github 就會幫我們重新建置並部署網站。\n\n## Reference\n\n- [Hugo Quick Start](https://gohugo.io/getting-started/quick-start/)\n","fileAbsolutePath":"/home/runner/work/HugoBlog/HugoBlog/src/posts/Hugo/hugo.md","excerpt":"Hugo 是靜態網頁的產生器，類似 Hexo 和 Jekyll，Hugo 由 go 語言編寫，效率極高，我原本是用 Hexo 在產生文章，後來發現 Hugo 這個好東西，也觀望了一陣子其實是懶，就決定換過來了，目前也用得非常順手。 安裝 Hugo 這是 Hugo 的官網，進去後可以看到一些簡單的介紹和安裝方法。 我蠻推薦在 vscode 的  的方式用 Hugo，因為我自己也是這樣用，這樣就不用…","frontmatter":{"title":"用 Hugo 來寫文章吧","date":"2021-06-06T18:10:46.000Z","draft":false,"tags":["hugo","blog","mac","linux","windows"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f50473d3-1acc-431a-402d-3c79f4170b00/public","description":"Hugo 是靜態網頁的產生器，類似 Hexo 和 Jekyll，Hugo 由 go 語言編寫，效率極高。"}}},{"node":{"id":"f7f20ef1-8a35-5fb7-83a1-294315f4f30c","html":"<p>我目前的工作環境都是用 Ubuntu <del>(被 Windows 氣到)</del>，前幾天我重新安裝 Ubuntu 的時候，一直安裝失敗，重新安裝四、五次後都沒有畫面，最後才發現是顯卡驅動問題。</p>\n<blockquote>\n<p>聽說 Ubuntu 開機沒有畫面或是只有 Logo，十次有九次都是顯卡驅動的問題</p>\n</blockquote>\n<!--more-->\n<h2>解決問題</h2>\n<p>在開機引導時會看到這個畫面，立馬按下鍵盤上的 <code class=\"language-text\">c</code> 鍵。</p>\n<p><img src=\"https://i.stack.imgur.com/8RYuZ.png\" alt=\"img\"></p>\n<p>按下 c 後，會以下畫面，找到 <code class=\"language-text\">quite splash</code>。</p>\n<p><img src=\"https://i.stack.imgur.com/0Cfhc.png\" alt=\"img\"></p>\n<p>把 <code class=\"language-text\">quite splash</code> 改成 <code class=\"language-text\">nomodeset</code>，不要懷疑，把兩個字刪掉，改成一個字，改錯也沒關係，下次重開就會復原。</p>\n<p>改完後，按下 <code class=\"language-text\">f10</code> 應該就可以順利進入系統，只是是在沒有顯卡驅動的狀態，畫面可能非常不流暢，所以我們現在來安裝顯卡驅動。</p>\n<h2>顯卡驅動</h2>\n<p>開啟 Terminal，輸入下面的指令，可以自動檢查顯卡的驅動</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ubuntu-drivers devices</code></pre></div>\n<p>應該可以看到其中一項後面有 recommended，基本上安裝那個版本就沒有問題。下面我們直接用自動安裝的方式安裝推薦的驅動。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ubuntu-drivers autoinstall</code></pre></div>\n<p>如果你懶的關心 <code class=\"language-text\">autoinstall</code> 會幫你安裝哪個版本，基本上直接執行上面的指令就可以解決問題了。</p>\n<p>安裝完成後重開機，如果沒有遇到其他問題，這樣應該就可以順利進入系統了。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://askubuntu.com/questions/162075/my-computer-boots-to-a-black-screen-what-options-do-i-have-to-fix-it\">My computer boots to a black screen, what options do I have to fix it?</a></li>\n</ul>","rawMarkdownBody":"\n我目前的工作環境都是用 Ubuntu ~~(被 Windows 氣到)~~，前幾天我重新安裝 Ubuntu 的時候，一直安裝失敗，重新安裝四、五次後都沒有畫面，最後才發現是顯卡驅動問題。\n\n> 聽說 Ubuntu 開機沒有畫面或是只有 Logo，十次有九次都是顯卡驅動的問題\n\n<!--more-->\n\n## 解決問題\n\n在開機引導時會看到這個畫面，立馬按下鍵盤上的 `c` 鍵。\n\n![img](https://i.stack.imgur.com/8RYuZ.png)\n\n按下 c 後，會以下畫面，找到 `quite splash`。\n\n![img](https://i.stack.imgur.com/0Cfhc.png)\n\n把 `quite splash` 改成 `nomodeset`，不要懷疑，把兩個字刪掉，改成一個字，改錯也沒關係，下次重開就會復原。\n\n改完後，按下 `f10` 應該就可以順利進入系統，只是是在沒有顯卡驅動的狀態，畫面可能非常不流暢，所以我們現在來安裝顯卡驅動。\n\n## 顯卡驅動\n\n開啟 Terminal，輸入下面的指令，可以自動檢查顯卡的驅動\n\n```bash\nsudo ubuntu-drivers devices\n```\n\n應該可以看到其中一項後面有 recommended，基本上安裝那個版本就沒有問題。下面我們直接用自動安裝的方式安裝推薦的驅動。\n\n```bash\nsudo ubuntu-drivers autoinstall\n```\n\n如果你懶的關心 `autoinstall` 會幫你安裝哪個版本，基本上直接執行上面的指令就可以解決問題了。\n\n安裝完成後重開機，如果沒有遇到其他問題，這樣應該就可以順利進入系統了。\n\n## Reference\n\n- [My computer boots to a black screen, what options do I have to fix it?](https://askubuntu.com/questions/162075/my-computer-boots-to-a-black-screen-what-options-do-i-have-to-fix-it)\n","fileAbsolutePath":"/home/runner/work/HugoBlog/HugoBlog/src/posts/Linux/ubuntu-black-screen.md","excerpt":"我目前的工作環境都是用 Ubuntu (被 Windows 氣到)，前幾天我重新安裝 Ubuntu 的時候，一直安裝失敗，重新安裝四、五次後都沒有畫面，最後才發現是顯卡驅動問題。 聽說 Ubuntu 開機沒有畫面或是只有 Logo，十次有九次都是顯卡驅動的問題 解決問題 在開機引導時會看到這個畫面，立馬按下鍵盤上的  鍵。 img 按下 c 後，會以下畫面，找到 。 img 把  改成 ，不要懷…","frontmatter":{"title":"Ubuntu 開機黑屏","date":"2021-06-05T17:17:17.000Z","draft":false,"tags":["ubuntu"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/87c17ef3-d429-42ba-30ab-32ac2864c500/public","description":"聽說 Ubuntu 開機沒有畫面或是只有 Logo，十次有九次都是顯卡驅動的問題。"}}}]}},"pageContext":{"limit":8,"skip":16,"numPages":4,"currentPage":3}},"staticQueryHashes":[]}