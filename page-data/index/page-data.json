{"componentChunkName":"component---src-pages-index-tsx","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"59f97761-859b-55ad-aabc-9c01b316ded3","html":"<p>本文翻譯自 Medium。<a href=\"https://medium.flutterdevs.com/multithreading-in-flutter-aa07e2ae2971\">原文網址</a>，請在閱讀前先去幫原作者拍拍手。另外，我也有在原文中加入一些我自己的理解。</p>\n<p>Flutter 是由 Google 開發的跨平台框架，因其出色的用戶界面能力和動畫而引起了廣泛關注。如果我們遇到畫面卡住、動畫未按預期工作以及螢幕跳躍等問題，它的威力就會受到阻礙，進而導致整個用戶體驗變得很糟糕。通常，觸發這種現象的原因可能是同步訪問多個 API 請求、圖像處理、動畫或任何其他耗時操作。</p>\n<p>很多開發人員希望在他們的應用程式中解決此問題，以便讓程式不會出現這種情況。可以通過創建多個隔離線程 <code class=\"language-text\">Isolate</code>，這些線程具有自己的事件循環並與運行 Flutte 的主執行緒 (Main Thread) 不共享記憶體來完成此操作。此過程稱為多執行緒處理。</p>\n<!--more-->\n<p>Dart 是一種單線程語言：所有的 Dart 程式碼都在一個 <code class=\"language-text\">Isolate</code> 中運行，這讓它們非常重要，整個 Dart 應用程序都在一個隔離體中運行。</p>\n<blockquote>\n<p>在 Flutter 中，每一個執行緒 (Thread) 就稱做一個 Isolate。</p>\n</blockquote>\n<h2>Need for Isolate</h2>\n<p>在 Flutter 中，即使是使用 async/await 的情況下，所有程式碼都在 Main Isolate 中執行 (雖然看起來是非同步的執行，但他們只是在 Main Isolate 中輪流執行，所以 async/await 數量一多還是會造成卡頓)，因此多線程是必不可少的。</p>\n<p><code class=\"language-text\">Isolate</code> 非常有用，可以運行需要很長時間才能完成而不會阻塞主線程的程式碼，這對於提供流暢和反應靈敏的用戶體驗非常重要。多線程允許程式的兩部分或更多部分並行執行，利用 CPU 的多核心。同時也可以讓程式同時執行多項任務，以減少對用戶輸入等事件做出反應時間。</p>\n<p>在深入探討 <code class=\"language-text\">Isolate</code> 的類型之前，有幾件事情需要記住：</p>\n<ul>\n<li>線程之間無法相互通訊：創建的隔離體之間沒有通訊，包括在 Flutter Isolate 中的自定的對象。</li>\n<li>通訊是透過 <code class=\"language-text\">port</code> 完成的：線程之間的任何通訊都是通過 port 進行的。</li>\n</ul>\n<h2>Types Of Isolate In Flutter</h2>\n<p>在 Flutter 中有兩種方式可以創建 Isolate：</p>\n<ul>\n<li><code class=\"language-text\">Compute</code> function</li>\n<li><code class=\"language-text\">Spawn</code> function</li>\n</ul>\n<h3>Spawn Function</h3>\n<p>使用 <code class=\"language-text\">spawn</code> 創建 Isolate 很簡單，它需要兩個參數：一個 Function 和 （可選的）Function 傳入值。</p>\n<p>以下是如何使用 Isolate.spawn 創建 Isolate 的範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">import</span> <span class=\"token string-literal\"><span class=\"token string\">'dart:isolate'</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// create the isolate</span>\n    <span class=\"token class-name\">Isolate</span><span class=\"token punctuation\">.</span><span class=\"token function\">spawn</span><span class=\"token punctuation\">(</span>isolateFunction<span class=\"token punctuation\">,</span> <span class=\"token string-literal\"><span class=\"token string\">\"Hello from the main isolate!\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">isolateFunction</span><span class=\"token punctuation\">(</span>dynmic message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這會創建一個 Isolate 並在背景中執行 <code class=\"language-text\">isolateFunction</code> 中的程式碼。Main Isolate 將字串 \"Hello from the main isolate!\"，傳給新的 Isolate，這個字串會被新的 Isolate 接收到並且印出來。</p>\n<p>請注意，Isolate 是被不同的 Thread 執行的，他們並不共享記憶體，這意味著你需要用 Isolate 之間的通訊技術來在不同的 Isolate 中傳遞數據（就像面的範例是在創建 Isolate 時傳入，或是晚點會介紹的 Port）。</p>\n<h3>Compute Function</h3>\n<p>Flutter 中。你可以使用 Compute function 在單獨的 Isolate 中執行 function，Compute function 是一個 <code class=\"language-text\">Isolate.spawn</code> 的包裝器 (wrapper)，讓 Isolate 執行計算密集型的任務更方便一點。</p>\n<p>下面是一個在 Flutter 中使用 Comput function 創建 Isolate 的範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">import</span> <span class=\"token string-literal\"><span class=\"token string\">'dart:async'</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">></span></span> computeFunction <span class=\"token keyword\">async</span> <span class=\"token punctuation\">{</span>\n    int result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span>computeIntensiveFunction<span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nint <span class=\"token function\">computeInstensiveFunction</span><span class=\"token punctuation\">(</span>int value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 執行一些計算密集型任務</span>\n    <span class=\"token keyword\">return</span> value <span class=\"token operator\">*</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在這個例子中，使用 <code class=\"language-text\">compute()</code> 來創建一個獨立的 Isolate 來執行 <code class=\"language-text\">computeInstensiveFunction</code> 中的程式碼。Compute function 會回傳一個 <code class=\"language-text\">Future</code> ，會在 Function 執行完成時，回傳 Function 的回傳值。在這個例子中是會回傳 100 * 100 = 10000，所以 result 的直是 10000。</p>\n<p>請注意，傳遞給 Comput function 的 Function，必須是頂層函數 (top-level function)，或是 static method，並且傳入值和回傳值的型態都是 dynmic。</p>\n<h2>Isolate 們如何相互溝通</h2>\n<p>要在 Isolate 之間通訊，可以使用 <code class=\"language-text\">SendPort</code> 和 <code class=\"language-text\">ReceivePort</code>。</p>\n<p>以下是一個範例，告訴你如何使用這兩個 classes 來將訊息從 Main Isolate 傳送到新的 Isolate：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">import</span> <span class=\"token string-literal\"><span class=\"token string\">'dart:isolate'</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 創建一個 SentPort 來將訊息傳送到新的 Isolate</span>\n    <span class=\"token keyword\">final</span> sendPort <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SendPort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 創建一個新的 Isolate</span>\n    <span class=\"token class-name\">Isolate</span><span class=\"token punctuation\">.</span><span class=\"token function\">spawn</span><span class=\"token punctuation\">(</span>isolateEntryPoint<span class=\"token punctuation\">,</span> sendPort<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">isolateEntryPoint</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SendPort</span> sendPort<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 創建一個 ReceivePort 來接從 Main Isolate 接收訊息</span>\n    <span class=\"token keyword\">final</span> receivePort <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RceivePort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 傳送 receivePort 的 sendPort 給 Main Isolate，來讓 Main Isolate 可以傳送訊息到這個 Isolate</span>\n    sendPort<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>receivePort<span class=\"token punctuation\">.</span>sendPort<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 監聽來自 Main Isolate 的訊息</span>\n    receivePort<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">'Message received: </span><span class=\"token interpolation\"><span class=\"token punctuation\">$</span><span class=\"token expression\">message</span></span><span class=\"token string\">'</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>要從新的 Isolate 傳送訊息回到 Main Isolate，可以用從 Main Isolate 傳入的 SendPort。</p>\n<p>以下是如何使用此 SendPort 將訊息傳回 Main Isolate：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">void</span> <span class=\"token function\">isolateEntryPoint</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SendPort</span> sendPort<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 創建一個 ReceivePort 來接從 Main Isolate 接收訊息</span>\n    <span class=\"token keyword\">final</span> receivePort <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RceivePort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 傳送 receivePort 的 sendPort 給 Main Isolate，來讓 Main Isolate 可以傳送訊息到這個 Isolate</span>\n    sendPort<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>receivePort<span class=\"token punctuation\">.</span>sendPort<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 監聽來自 Main Isolate 的訊息</span>\n    receivePort<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">'Message received: </span><span class=\"token interpolation\"><span class=\"token punctuation\">$</span><span class=\"token expression\">message</span></span><span class=\"token string\">'</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 傳送訊息回 Main Isolate</span>\n        sendPort<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">\"Hello from the isolate!\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在 Main Isolate 中，你可以使用 ReceivePort 來監聽來自新的 Isolate 的訊息：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">import</span> <span class=\"token string-literal\"><span class=\"token string\">'dart:isolate'</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 創建一個 SentPort 來將訊息傳送到新的 Isolate</span>\n    <span class=\"token keyword\">final</span> sendPort <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SendPort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 創建一個新的 Isolate</span>\n    <span class=\"token class-name\">Isolate</span><span class=\"token punctuation\">.</span><span class=\"token function\">spawn</span><span class=\"token punctuation\">(</span>isolateEntryPoint<span class=\"token punctuation\">,</span> sendPort<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 創建一個 RecivePort 來接收來自新 Isolate 的訊息</span>\n    <span class=\"token keyword\">final</span> receivePort <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReceivePort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 傳送 ReceivePort 的 SendPort 給新的 Isolate</span>\n    sendPort<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>receivePort<span class=\"token punctuation\">.</span>sendPort<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 監聽訊息</span>\n    receivePort<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal\"><span class=\"token string\">'Message received: </span><span class=\"token interpolation\"><span class=\"token punctuation\">$</span><span class=\"token expression\">message</span></span><span class=\"token string\">'</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">flutter_isolate</code> 套件提供了一種在單獨 Isolate（單獨的執行 Context）中運行 Dart 程式碼的方法。 Isolate 用於並行執行程式碼，可以用於實現負載平衡，因為它們允許你將工作負載分佈到多個線程中。</p>\n<p>以下是如何在 Flutter 中使用 <code class=\"language-text\">flutter_isolate</code> 來平衡工作量的範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">import</span> <span class=\"token string-literal\"><span class=\"token string\">'package:flutter_isolate/flutter_isolate.dart'</span></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 創建一個要負載平衡的 function</span>\n    <span class=\"token keyword\">final</span> workload <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Do some work here</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 創建一個列表的 Isolate</span>\n    <span class=\"token keyword\">final</span> isolates <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token class-name\">IsolateRunner</span><span class=\"token punctuation\">(</span>workload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token class-name\">IsolateRunner</span><span class=\"token punctuation\">(</span>workload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token class-name\">IsolateRunner</span><span class=\"token punctuation\">(</span>workload<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 執行每一個 Isolate</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> isolate <span class=\"token keyword\">in</span> isolates<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        isolate<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這個範例創建了一個包含三個 Isolate 的列表，每一個 Isolate 都有相同的工作，你可以呼叫每個 Isolate <code class=\"language-text\">run()</code> 來執行他們。</p>\n<p>其他使用方法可以看 <a href=\"https://pub.dev/packages/flutter_isolate\">flutter_isolate 的官方文件</a></p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://medium.flutterdevs.com/multithreading-in-flutter-aa07e2ae2971\">原文網址</a></li>\n<li><a href=\"https://pub.dev/packages/flutter_isolate\">flutter_isolate</a></li>\n</ul>","rawMarkdownBody":"\n本文翻譯自 Medium。[原文網址](https://medium.flutterdevs.com/multithreading-in-flutter-aa07e2ae2971)，請在閱讀前先去幫原作者拍拍手。另外，我也有在原文中加入一些我自己的理解。\n\nFlutter 是由 Google 開發的跨平台框架，因其出色的用戶界面能力和動畫而引起了廣泛關注。如果我們遇到畫面卡住、動畫未按預期工作以及螢幕跳躍等問題，它的威力就會受到阻礙，進而導致整個用戶體驗變得很糟糕。通常，觸發這種現象的原因可能是同步訪問多個 API 請求、圖像處理、動畫或任何其他耗時操作。\n\n很多開發人員希望在他們的應用程式中解決此問題，以便讓程式不會出現這種情況。可以通過創建多個隔離線程 `Isolate`，這些線程具有自己的事件循環並與運行 Flutte 的主執行緒 (Main Thread) 不共享記憶體來完成此操作。此過程稱為多執行緒處理。\n\n<!--more-->\n\nDart 是一種單線程語言：所有的 Dart 程式碼都在一個 `Isolate` 中運行，這讓它們非常重要，整個 Dart 應用程序都在一個隔離體中運行。\n\n> 在 Flutter 中，每一個執行緒 (Thread) 就稱做一個 Isolate。\n\n## Need for Isolate\n\n在 Flutter 中，即使是使用 async/await 的情況下，所有程式碼都在 Main Isolate 中執行 (雖然看起來是非同步的執行，但他們只是在 Main Isolate 中輪流執行，所以 async/await 數量一多還是會造成卡頓)，因此多線程是必不可少的。\n\n`Isolate` 非常有用，可以運行需要很長時間才能完成而不會阻塞主線程的程式碼，這對於提供流暢和反應靈敏的用戶體驗非常重要。多線程允許程式的兩部分或更多部分並行執行，利用 CPU 的多核心。同時也可以讓程式同時執行多項任務，以減少對用戶輸入等事件做出反應時間。\n\n在深入探討 `Isolate` 的類型之前，有幾件事情需要記住：\n\n- 線程之間無法相互通訊：創建的隔離體之間沒有通訊，包括在 Flutter Isolate 中的自定的對象。\n- 通訊是透過 `port` 完成的：線程之間的任何通訊都是通過 port 進行的。\n\n## Types Of Isolate In Flutter\n\n在 Flutter 中有兩種方式可以創建 Isolate：\n\n- `Compute` function\n- `Spawn` function\n\n### Spawn Function\n\n使用 `spawn` 創建 Isolate 很簡單，它需要兩個參數：一個 Function 和 （可選的）Function 傳入值。\n\n以下是如何使用 Isolate.spawn 創建 Isolate 的範例：\n\n```dart\nimport 'dart:isolate';\n\nvoid main() {\n    // create the isolate\n    Isolate.spawn(isolateFunction, \"Hello from the main isolate!\");\n}\n\nvoid isolateFunction(dynmic message) {\n    print(message);\n}\n```\n\n這會創建一個 Isolate 並在背景中執行 `isolateFunction` 中的程式碼。Main Isolate 將字串 \"Hello from the main isolate!\"，傳給新的 Isolate，這個字串會被新的 Isolate 接收到並且印出來。\n\n請注意，Isolate 是被不同的 Thread 執行的，他們並不共享記憶體，這意味著你需要用 Isolate 之間的通訊技術來在不同的 Isolate 中傳遞數據（就像面的範例是在創建 Isolate 時傳入，或是晚點會介紹的 Port）。\n\n### Compute Function\n\nFlutter 中。你可以使用 Compute function 在單獨的 Isolate 中執行 function，Compute function 是一個 `Isolate.spawn` 的包裝器 (wrapper)，讓 Isolate 執行計算密集型的任務更方便一點。\n\n下面是一個在 Flutter 中使用 Comput function 創建 Isolate 的範例：\n\n```dart\nimport 'dart:async';\n\nFuture<void> computeFunction async {\n    int result = await compute(computeIntensiveFunction, 100);\n    print(result);\n}\n\nint computeInstensiveFunction(int value) {\n    // 執行一些計算密集型任務\n    return value * value;\n}\n```\n\n在這個例子中，使用 `compute()` 來創建一個獨立的 Isolate 來執行 `computeInstensiveFunction` 中的程式碼。Compute function 會回傳一個 `Future` ，會在 Function 執行完成時，回傳 Function 的回傳值。在這個例子中是會回傳 100 \\* 100 = 10000，所以 result 的直是 10000。\n\n請注意，傳遞給 Comput function 的 Function，必須是頂層函數 (top-level function)，或是 static method，並且傳入值和回傳值的型態都是 dynmic。\n\n## Isolate 們如何相互溝通\n\n要在 Isolate 之間通訊，可以使用 `SendPort` 和 `ReceivePort`。\n\n以下是一個範例，告訴你如何使用這兩個 classes 來將訊息從 Main Isolate 傳送到新的 Isolate：\n\n```dart\nimport 'dart:isolate';\n\nvoid main() {\n    // 創建一個 SentPort 來將訊息傳送到新的 Isolate\n    final sendPort = new SendPort();\n    // 創建一個新的 Isolate\n    Isolate.spawn(isolateEntryPoint, sendPort);\n}\n\nvoid isolateEntryPoint(SendPort sendPort) {\n    // 創建一個 ReceivePort 來接從 Main Isolate 接收訊息\n    final receivePort = new RceivePort();\n\n    // 傳送 receivePort 的 sendPort 給 Main Isolate，來讓 Main Isolate 可以傳送訊息到這個 Isolate\n    sendPort.send(receivePort.sendPort);\n\n    // 監聽來自 Main Isolate 的訊息\n    receivePort.listen((message) {\n        print('Message received: $message');\n    });\n}\n```\n\n要從新的 Isolate 傳送訊息回到 Main Isolate，可以用從 Main Isolate 傳入的 SendPort。\n\n以下是如何使用此 SendPort 將訊息傳回 Main Isolate：\n\n```dart\nvoid isolateEntryPoint(SendPort sendPort) {\n    // 創建一個 ReceivePort 來接從 Main Isolate 接收訊息\n    final receivePort = new RceivePort();\n\n    // 傳送 receivePort 的 sendPort 給 Main Isolate，來讓 Main Isolate 可以傳送訊息到這個 Isolate\n    sendPort.send(receivePort.sendPort);\n\n    // 監聽來自 Main Isolate 的訊息\n    receivePort.listen((message) {\n        print('Message received: $message');\n\n        // 傳送訊息回 Main Isolate\n        sendPort.send(\"Hello from the isolate!\");\n    });\n}\n```\n\n在 Main Isolate 中，你可以使用 ReceivePort 來監聽來自新的 Isolate 的訊息：\n\n```dart\nimport 'dart:isolate';\n\nvoid main() {\n    // 創建一個 SentPort 來將訊息傳送到新的 Isolate\n    final sendPort = new SendPort();\n\n    // 創建一個新的 Isolate\n    Isolate.spawn(isolateEntryPoint, sendPort);\n\n    // 創建一個 RecivePort 來接收來自新 Isolate 的訊息\n    final receivePort = new ReceivePort();\n\n    // 傳送 ReceivePort 的 SendPort 給新的 Isolate\n    sendPort.send(receivePort.sendPort);\n\n    // 監聽訊息\n    receivePort.listen((message) {\n        print('Message received: $message');\n    });\n}\n```\n\n`flutter_isolate` 套件提供了一種在單獨 Isolate（單獨的執行 Context）中運行 Dart 程式碼的方法。 Isolate 用於並行執行程式碼，可以用於實現負載平衡，因為它們允許你將工作負載分佈到多個線程中。\n\n以下是如何在 Flutter 中使用 `flutter_isolate` 來平衡工作量的範例：\n\n```dart\nimport 'package:flutter_isolate/flutter_isolate.dart';\n\nvoid main() {\n    // 創建一個要負載平衡的 function\n    final workload = () {\n        // Do some work here\n    };\n\n    // 創建一個列表的 Isolate\n    final isolates = [\n        IsolateRunner(workload),\n        IsolateRunner(workload),\n        IsolateRunner(workload),\n    ];\n\n    // 執行每一個 Isolate\n    for (final isolate in isolates) {\n        isolate.run();\n    }\n}\n```\n\n這個範例創建了一個包含三個 Isolate 的列表，每一個 Isolate 都有相同的工作，你可以呼叫每個 Isolate `run()` 來執行他們。\n\n其他使用方法可以看 [flutter_isolate 的官方文件](https://pub.dev/packages/flutter_isolate)\n\n## Reference\n\n- [原文網址](https://medium.flutterdevs.com/multithreading-in-flutter-aa07e2ae2971)\n- [flutter_isolate](https://pub.dev/packages/flutter_isolate)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Flutter/flutter-isolate.md","excerpt":"本文翻譯自 Medium。原文網址，請在閱讀前先去幫原作者拍拍手。另外，我也有在原文中加入一些我自己的理解。 Flutter 是由 Google 開發的跨平台框架，因其出色的用戶界面能力和動畫而引起了廣泛關注。如果我們遇到畫面卡住、動畫未按預期工作以及螢幕跳躍等問題，它的威力就會受到阻礙，進而導致整個用戶體驗變得很糟糕。通常，觸發這種現象的原因可能是同步訪問多個 API 請求、圖像處理、動畫或任…","frontmatter":{"title":"Flutter Isolate 多執行緒","date":"2023-03-15T01:53:01.621Z","draft":false,"tags":["flutter","dart","isolate","multithread"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/2aa71d52-6fd6-4086-80fc-ba6692219700/public","description":null}}},{"node":{"id":"0173acc9-1f30-5386-82d0-45d9174e7f25","html":"<p>使用自己的網域要收發電子郵件是一件麻煩事，自己架設 Email Server，發出去的信件大部分都會被當成垃圾信。簡單的解決方式，就是買下 Google Workspace，但是這真的蠻貴的，所以我發現了完全免費的解決方式，記錄一下。</p>\n<!--more-->\n<h2>思路</h2>\n<ul>\n<li>Cloudflare Email Routing 收電子郵件，並轉到自己的 Gmail</li>\n<li>Google SMTP 發電子郵件</li>\n</ul>\n<h2>Email 轉址</h2>\n<p>Cloudflare 的佛心服務之一，就是可以幫忙把 Email 轉址，只要網域託管給 Cloudflare 就可以免費使用，沒有任何限制，真的是完全免費。</p>\n<p>只要在 Cloudflare 的網域設定中設定一個自己想要接收 Email 的位置和用戶名，並轉發到自己的 Gmail 即可。這樣以後只要寄 Email 到設定的位置，全部都會轉發到自己的 Gmail。</p>\n<p>設定時 Cloudflare 會寄一封信到要被轉發的 Gmail 中確認。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/87cbdb38-c1cc-41b9-759b-1c453e204f00/public\" alt=\"img\"></p>\n<h2>發送 Email</h2>\n<p>解決了收信的問題，現在來解決發信的問題。Gmail 有提供免費的 Email SMTP Server 供免費發送電子郵件，不管任何的網域都可以，只要有 Google 帳號，就可以每天寄送 500 封 Email。</p>\n<p>到 Gamil 的設定中，新增用來寄 Email 的地址，這可以設定很多個。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b02717d8-d39d-4fa7-9151-601ccb7beb00/public\" alt=\"img\"></p>\n<p>輸入剛剛在 Cloudflare 設定的 Email，名稱填自己發信時想要顯示的名字。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8354f94e-c13f-4e72-d717-685dd7af1900/public\" alt=\"img\"></p>\n<p>免費的 Gmail SMTP 設定值如下：</p>\n<ul>\n<li>SMTP Server: <code class=\"language-text\">smtp.gmail.com</code></li>\n<li>使用者名稱：自己的 Gmail 帳號</li>\n<li>密碼：Gmail 密碼 (如果 Google 帳號有設定 2FA，可以到 <a href=\"https://myaccount.google.com/apppasswords\">https://myaccount.google.com/apppasswords</a> 產生專用密碼)</li>\n</ul>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6905c1eb-b1de-4a3d-81fa-e938302b2500/public\" alt=\"img\"></p>\n<p>新增後，Google 也會寄一封確認信到你要被轉發的信箱，確認你真的擁有這個地址的使用權，避免濫用。因為剛剛已經叫 Cloudflare 轉發郵件到你的 Gmail，所以可以直接在你的 Gmail 收認證信。</p>\n<p>這樣就大功告成，用兩個免費的服務給解決自己的網域的收發信問題，而且是由 Gmail 的 SMTP 寄出，也比較不會被擋信。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://developers.cloudflare.com/email-routing/\">Cloudflare Email Routing</a></li>\n<li><a href=\"https://kinsta.com/blog/gmail-smtp-server/\">How to Use the Gmail SMTP Server to Send Emails for Free</a></li>\n</ul>","rawMarkdownBody":"\n使用自己的網域要收發電子郵件是一件麻煩事，自己架設 Email Server，發出去的信件大部分都會被當成垃圾信。簡單的解決方式，就是買下 Google Workspace，但是這真的蠻貴的，所以我發現了完全免費的解決方式，記錄一下。\n\n<!--more-->\n\n## 思路\n\n- Cloudflare Email Routing 收電子郵件，並轉到自己的 Gmail\n- Google SMTP 發電子郵件\n\n## Email 轉址\n\nCloudflare 的佛心服務之一，就是可以幫忙把 Email 轉址，只要網域託管給 Cloudflare 就可以免費使用，沒有任何限制，真的是完全免費。\n\n只要在 Cloudflare 的網域設定中設定一個自己想要接收 Email 的位置和用戶名，並轉發到自己的 Gmail 即可。這樣以後只要寄 Email 到設定的位置，全部都會轉發到自己的 Gmail。\n\n設定時 Cloudflare 會寄一封信到要被轉發的 Gmail 中確認。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/87cbdb38-c1cc-41b9-759b-1c453e204f00/public)\n\n## 發送 Email\n\n解決了收信的問題，現在來解決發信的問題。Gmail 有提供免費的 Email SMTP Server 供免費發送電子郵件，不管任何的網域都可以，只要有 Google 帳號，就可以每天寄送 500 封 Email。\n\n到 Gamil 的設定中，新增用來寄 Email 的地址，這可以設定很多個。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b02717d8-d39d-4fa7-9151-601ccb7beb00/public)\n\n輸入剛剛在 Cloudflare 設定的 Email，名稱填自己發信時想要顯示的名字。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8354f94e-c13f-4e72-d717-685dd7af1900/public)\n\n免費的 Gmail SMTP 設定值如下：\n\n- SMTP Server: `smtp.gmail.com`\n- 使用者名稱：自己的 Gmail 帳號\n- 密碼：Gmail 密碼 (如果 Google 帳號有設定 2FA，可以到 [https://myaccount.google.com/apppasswords](https://myaccount.google.com/apppasswords) 產生專用密碼)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6905c1eb-b1de-4a3d-81fa-e938302b2500/public)\n\n新增後，Google 也會寄一封確認信到你要被轉發的信箱，確認你真的擁有這個地址的使用權，避免濫用。因為剛剛已經叫 Cloudflare 轉發郵件到你的 Gmail，所以可以直接在你的 Gmail 收認證信。\n\n這樣就大功告成，用兩個免費的服務給解決自己的網域的收發信問題，而且是由 Gmail 的 SMTP 寄出，也比較不會被擋信。\n\n## Reference\n\n- [Cloudflare Email Routing](https://developers.cloudflare.com/email-routing/)\n- [How to Use the Gmail SMTP Server to Send Emails for Free](https://kinsta.com/blog/gmail-smtp-server/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Others/cf-email-routing-gmail.md","excerpt":"使用自己的網域要收發電子郵件是一件麻煩事，自己架設 Email Server，發出去的信件大部分都會被當成垃圾信。簡單的解決方式，就是買下 Google Workspace，但是這真的蠻貴的，所以我發現了完全免費的解決方式，記錄一下。 思路 Cloudflare Email Routing 收電子郵件，並轉到自己的 Gmail Google SMTP 發電子郵件 Email 轉址 Cloudfl…","frontmatter":{"title":"自訂網域免費收發信 -- Cloudflare Email Routing 搭配 Gmail SMTP","date":"2022-10-27T13:44:50.631Z","draft":false,"tags":["cloudflare","email","gmail"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9269c238-393f-40f8-9617-2416ff0de100/public","description":null}}},{"node":{"id":"505740d3-a1e0-50b9-881b-985e3deedb79","html":"<p>持續更新</p>\n<!--more-->\n<h2>主要功能</h2>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/fe62dea5-6895-41d6-0d77-aea084d0a400/public\" alt=\"img\"></p>\n<h2>主頁 - 顯示附近的換電站</h2>\n<p>點擊電池圖示，可進入換電站詳細資料</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/501bf8bd-ad8e-4ebf-77b5-9e593effe500/public\" alt=\"img\"></p>\n<h2>Go Station 列表</h2>\n<ul>\n<li>顯示所有換電站</li>\n<li>以使用者目前位置與換電站位置直線距離排序</li>\n<li>可點擊進入換電站詳細資訊</li>\n</ul>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/cc6dc1f6-37e6-4825-b1e0-ca390f7cf200/public\" alt=\"img\"></p>\n<h2>換電站的涵蓋範圍</h2>\n<ul>\n<li>預設涵蓋範圍為 50 公里，可在設定中變更 (1 ~ 100)</li>\n<li>以這個換電站為中心，可以用 <strong>道路</strong> 到達地方</li>\n<li>計算是包含高快速公路等禁行機車路段，使用時需多加注意</li>\n<li>計算不考慮上升或下降海拔</li>\n<li>點一下空白處，即可關閉</li>\n</ul>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/83e32a54-f6fc-49f2-3d36-6fdead20a200/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/934c92d3-257c-4816-ccb5-9ee5d8e16000/public\" alt=\"img\"></p>\n<h2>其他</h2>\n<p>本程式與 「Gogoro 睿能創意股份有限公司」無關</p>","rawMarkdownBody":"\n持續更新\n\n<!--more-->\n\n## 主要功能\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/fe62dea5-6895-41d6-0d77-aea084d0a400/public)\n\n## 主頁 - 顯示附近的換電站\n\n點擊電池圖示，可進入換電站詳細資料\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/501bf8bd-ad8e-4ebf-77b5-9e593effe500/public)\n\n## Go Station 列表\n\n- 顯示所有換電站\n- 以使用者目前位置與換電站位置直線距離排序\n- 可點擊進入換電站詳細資訊\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/cc6dc1f6-37e6-4825-b1e0-ca390f7cf200/public)\n\n## 換電站的涵蓋範圍\n\n- 預設涵蓋範圍為 50 公里，可在設定中變更 (1 ~ 100)\n- 以這個換電站為中心，可以用 **道路** 到達地方\n- 計算是包含高快速公路等禁行機車路段，使用時需多加注意\n- 計算不考慮上升或下降海拔\n- 點一下空白處，即可關閉\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/83e32a54-f6fc-49f2-3d36-6fdead20a200/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/934c92d3-257c-4816-ccb5-9ee5d8e16000/public)\n\n## 其他\n\n本程式與 「Gogoro 睿能創意股份有限公司」無關\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Others/itsgo-doc.md","excerpt":"持續更新 主要功能 img 主頁 - 顯示附近的換電站 點擊電池圖示，可進入換電站詳細資料 img Go Station 列表 顯示所有換電站 以使用者目前位置與換電站位置直線距離排序 可點擊進入換電站詳細資訊 img 換電站的涵蓋範圍 預設涵蓋範圍為 50 公里，可在設定中變更 (1 ~ 100) 以這個換電站為中心，可以用 道路 到達地方 計算是包含高快速公路等禁行機車路段，使用時需多加注意…","frontmatter":{"title":"這就 Go -- 使用說明","date":"2022-10-16T13:44:50.631Z","draft":false,"tags":["gogoro","itsgo"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f69f0eb7-8df6-42c2-7cd5-c8499f2e8f00/public","description":null}}},{"node":{"id":"56c03060-dd39-55f0-84b4-0eec1af77639","html":"<p>我的專案只要有關 js 的，我都會用 prettier 來自動排版，因為 prettier 能確保大家的程式碼風格一致。但是，我常常會有忘記 prettier 一下就直接 push 到 GitHub 上，我就想到說如果 GitHub Actions 可以幫忙檢查 prettier 應該也可以就直接幫忙 prettier 後 push 上來吧。今天我就把我寫好的 GitHub Actions 腳本記錄一下。</p>\n<!--more-->\n<h2>思路</h2>\n<p>我把他分為兩個 job 來做：</p>\n<ol>\n<li>執行 prettier check</li>\n<li>如果步驟 1 失敗，執行 prettier write 並 push</li>\n</ol>\n<p>完整的 yml 檔我放在最後面了，有需要的人可以直接拿去用。</p>\n<h2>Prettier Check</h2>\n<p>執行 prettier check 應該是很簡單的步驟，許多 GitHub 上的開源專案應該都寫的差不多。簡單來說，就是設定好 node 後，直接 run <code class=\"language-text\">npx prettier --check .</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">prettier-check</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Checkout\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Node\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/setup<span class=\"token punctuation\">-</span>node@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">node-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"14\"</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Run Prettier Check\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          npx prettier --check .</span></code></pre></div>\n<h2>Prettier Write</h2>\n<p>這步驟比較會遇到問題的部分就是要如何判斷上一步驟 prettier check 執行失敗，我翻了一下 GitHub Actions 的文件，發現可以用 if 來決定一個 job 要不要執行，所以我們會需要 prettier check 的執行結果，才決定要不要 prettie write。Actions 有一個 <code class=\"language-text\">needs</code> 的邏輯，可以用來等待另一個 job 完成，然後使用他的執行結果。所以目前為止，可以先寫成下面這樣：</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">prettier-write</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\n    <span class=\"token key atrule\">needs</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> prettier<span class=\"token punctuation\">-</span>check\n    <span class=\"token key atrule\">if</span><span class=\"token punctuation\">:</span> always() <span class=\"token important\">&amp;&amp;</span> (needs.prettier<span class=\"token punctuation\">-</span>check.result == 'failure')</code></pre></div>\n<p>接下來來寫 prettier write 和 git push，我在這邊遇到的問題是，如果 git checkout 的時候沒有給 Token，GitHub 預設會讓由 Actions push 的 Commit 不會觸發任的 Actions，這也不難理解，怕 Actions 彼此呼相 Call，然後進到無限回圈停不下來。但我今天還是希望他 prettier 完後可以觸發 Build 的 Actions，所以我們就要在 git checkout 的時候給他自訂的 Token，這樣等等在 push 的時候，也會幫我們用這個 Token Push。</p>\n<p>就不在另外上程式碼，直接去下方看完整邏輯吧。</p>\n<h2>完整的 GitHub Actions 檔</h2>\n<p>結合上面兩個步驟：</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> prettier\n\n<span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">prettier-check</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Checkout\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">token</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.MY_GITHUB_TOKEN <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Node\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/setup<span class=\"token punctuation\">-</span>node@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">node-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"14\"</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Run Prettier Check\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          npx prettier --check .</span>\n  <span class=\"token key atrule\">prettier-write</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\n    <span class=\"token key atrule\">needs</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> prettier<span class=\"token punctuation\">-</span>check\n    <span class=\"token key atrule\">if</span><span class=\"token punctuation\">:</span> always() <span class=\"token important\">&amp;&amp;</span> (needs.prettier<span class=\"token punctuation\">-</span>check.result == 'failure')\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Checkout\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">token</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.MY_GITHUB_TOKEN <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Node\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/setup<span class=\"token punctuation\">-</span>node@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">node-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"14\"</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Write Prettier\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          npx prettier --write .</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Commit and Push\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> EndBug/add<span class=\"token punctuation\">-</span>and<span class=\"token punctuation\">-</span>commit@v9\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">add</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\".\"</span>\n          <span class=\"token key atrule\">message</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"Prettier\"</span>\n          <span class=\"token key atrule\">committer_name</span><span class=\"token punctuation\">:</span> TonyPepeBear\n          <span class=\"token key atrule\">committer_email</span><span class=\"token punctuation\">:</span> tonybear55665566@gmail.com</code></pre></div>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://docs.github.com/en/actions\">GitHub Actions</a></li>\n</ul>","rawMarkdownBody":"\n我的專案只要有關 js 的，我都會用 prettier 來自動排版，因為 prettier 能確保大家的程式碼風格一致。但是，我常常會有忘記 prettier 一下就直接 push 到 GitHub 上，我就想到說如果 GitHub Actions 可以幫忙檢查 prettier 應該也可以就直接幫忙 prettier 後 push 上來吧。今天我就把我寫好的 GitHub Actions 腳本記錄一下。\n\n<!--more-->\n\n## 思路\n\n我把他分為兩個 job 來做：\n\n1. 執行 prettier check\n2. 如果步驟 1 失敗，執行 prettier write 並 push\n\n完整的 yml 檔我放在最後面了，有需要的人可以直接拿去用。\n\n## Prettier Check\n\n執行 prettier check 應該是很簡單的步驟，許多 GitHub 上的開源專案應該都寫的差不多。簡單來說，就是設定好 node 後，直接 run `npx prettier --check .`：\n\n```yml\njobs:\n  prettier-check:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: \"14\"\n\n      - name: Run Prettier Check\n        run: |\n          npx prettier --check .\n```\n\n## Prettier Write\n\n這步驟比較會遇到問題的部分就是要如何判斷上一步驟 prettier check 執行失敗，我翻了一下 GitHub Actions 的文件，發現可以用 if 來決定一個 job 要不要執行，所以我們會需要 prettier check 的執行結果，才決定要不要 prettie write。Actions 有一個 `needs` 的邏輯，可以用來等待另一個 job 完成，然後使用他的執行結果。所以目前為止，可以先寫成下面這樣：\n\n```yml\njobs:\n  prettier-write:\n    runs-on: ubuntu-latest\n    needs:\n      - prettier-check\n    if: always() && (needs.prettier-check.result == 'failure')\n```\n\n接下來來寫 prettier write 和 git push，我在這邊遇到的問題是，如果 git checkout 的時候沒有給 Token，GitHub 預設會讓由 Actions push 的 Commit 不會觸發任的 Actions，這也不難理解，怕 Actions 彼此呼相 Call，然後進到無限回圈停不下來。但我今天還是希望他 prettier 完後可以觸發 Build 的 Actions，所以我們就要在 git checkout 的時候給他自訂的 Token，這樣等等在 push 的時候，也會幫我們用這個 Token Push。\n\n就不在另外上程式碼，直接去下方看完整邏輯吧。\n\n## 完整的 GitHub Actions 檔\n\n結合上面兩個步驟：\n\n```yml\nname: prettier\n\non:\n  push:\n\njobs:\n  prettier-check:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n        with:\n          token: ${{ secrets.MY_GITHUB_TOKEN }}\n\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: \"14\"\n\n      - name: Run Prettier Check\n        run: |\n          npx prettier --check .\n  prettier-write:\n    runs-on: ubuntu-latest\n    needs:\n      - prettier-check\n    if: always() && (needs.prettier-check.result == 'failure')\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n        with:\n          token: ${{ secrets.MY_GITHUB_TOKEN }}\n\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: \"14\"\n\n      - name: Write Prettier\n        run: |\n          npx prettier --write .\n      - name: Commit and Push\n        uses: EndBug/add-and-commit@v9\n        with:\n          add: \".\"\n          message: \"Prettier\"\n          committer_name: TonyPepeBear\n          committer_email: tonybear55665566@gmail.com\n```\n\n## Reference\n\n- [GitHub Actions](https://docs.github.com/en/actions)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/GitHub/github-actions-prettier.md","excerpt":"我的專案只要有關 js 的，我都會用 prettier 來自動排版，因為 prettier 能確保大家的程式碼風格一致。但是，我常常會有忘記 prettier 一下就直接 push 到 GitHub 上，我就想到說如果 GitHub Actions 可以幫忙檢查 prettier 應該也可以就直接幫忙 prettier 後 push 上來吧。今天我就把我寫好的 GitHub Actions 腳本…","frontmatter":{"title":"讓 GitHub Actions 來幫你 Prettier","date":"2022-10-04T13:44:50.631Z","draft":false,"tags":["prettier","github","github-actions"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b33c3519-4782-4519-e113-3aadf3bf8800/public","description":null}}},{"node":{"id":"2797652b-b371-5832-b5ca-7639e58b787e","html":"<p>維基百科是大家的好朋友，但他的網頁排版感覺已經幾十年沒有更新過，閱讀起來有點不方便，而 Wikiwand 就是來幫助維基百科排版成更容易閱讀的形式，在 Google Chrome 上有官方的擴充功能可以將 Wiki 的網址直接重新導向到 Wikiwand，而 Safari 好像是因為 Apple 嚴格的條件所以沒有擴充功能，但我今天發現的一個技巧可以協助將網頁直接重新導向到 Wikiwand。</p>\n<!--more-->\n<h2>Wikiwand 比較</h2>\n<p>原版維基：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0a6c340c-becb-4748-a9d3-949a48241600/public\" alt=\"img\"></p>\n<p>Wikiwand:</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6023546f-67b9-4524-df91-33bc53f34f00/public\" alt=\"img\"></p>\n<h2>利用 AdGuard</h2>\n<p>這個技巧是利用廣告過濾器來協助網頁重新導向，而我是用 AdGuard 來幫助我們完成，我也只在 AdGuard 上用過，其他廣告過濾器我就不知道可不可以利用這個技巧了。如過沒有 AdGuard 的話，也可以去下載試用看看，自己用了很久覺得還不錯。</p>\n<p>整個過程只需要一步</p>\n<p>在 AdGuard 的設定中，在過濾器選項中新增使用者自訂的過濾器：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">@@<span class=\"token operator\">||</span>wikipedia<span class=\"token punctuation\">.</span>org<span class=\"token operator\">^</span>$generichide<span class=\"token punctuation\">,</span>badfilter\nwikipedia<span class=\"token punctuation\">.</span>org#<span class=\"token operator\">%</span>#<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>search <span class=\"token operator\">===</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">var</span> lang <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>hostname<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">var</span> article <span class=\"token operator\">=</span> window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>pathname<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> window<span class=\"token punctuation\">.</span>location<span class=\"token punctuation\">.</span>href <span class=\"token operator\">=</span> <span class=\"token string\">\"http://www.wikiwand.com/\"</span> <span class=\"token operator\">+</span> lang <span class=\"token operator\">+</span> <span class=\"token string\">\"/\"</span> <span class=\"token operator\">+</span> article<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4296f199-0bb2-4c34-922f-b45a5c280100/public\" alt=\"img\"></p>\n<p>大功告成</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"http://sebastiangrans.github.io/Wikiwand-on-Safari-13/\">Wikiwand on Safari</a></li>\n</ul>","rawMarkdownBody":"\n維基百科是大家的好朋友，但他的網頁排版感覺已經幾十年沒有更新過，閱讀起來有點不方便，而 Wikiwand 就是來幫助維基百科排版成更容易閱讀的形式，在 Google Chrome 上有官方的擴充功能可以將 Wiki 的網址直接重新導向到 Wikiwand，而 Safari 好像是因為 Apple 嚴格的條件所以沒有擴充功能，但我今天發現的一個技巧可以協助將網頁直接重新導向到 Wikiwand。\n\n<!--more-->\n\n## Wikiwand 比較\n\n原版維基：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0a6c340c-becb-4748-a9d3-949a48241600/public)\n\nWikiwand:\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6023546f-67b9-4524-df91-33bc53f34f00/public)\n\n## 利用 AdGuard\n\n這個技巧是利用廣告過濾器來協助網頁重新導向，而我是用 AdGuard 來幫助我們完成，我也只在 AdGuard 上用過，其他廣告過濾器我就不知道可不可以利用這個技巧了。如過沒有 AdGuard 的話，也可以去下載試用看看，自己用了很久覺得還不錯。\n\n整個過程只需要一步\n\n在 AdGuard 的設定中，在過濾器選項中新增使用者自訂的過濾器：\n\n```js\n@@||wikipedia.org^$generichide,badfilter\nwikipedia.org#%#if (window.location.search === \"\") { var lang = window.location.hostname.split('.')[0]; var article = window.location.pathname.split('/')[2]; window.location.href = \"http://www.wikiwand.com/\" + lang + \"/\" + article; }\n```\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4296f199-0bb2-4c34-922f-b45a5c280100/public)\n\n大功告成\n\n## Reference\n\n- [Wikiwand on Safari](http://sebastiangrans.github.io/Wikiwand-on-Safari-13/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Others/Wikiwand on Safari.md","excerpt":"維基百科是大家的好朋友，但他的網頁排版感覺已經幾十年沒有更新過，閱讀起來有點不方便，而 Wikiwand 就是來幫助維基百科排版成更容易閱讀的形式，在 Google Chrome 上有官方的擴充功能可以將 Wiki 的網址直接重新導向到 Wikiwand，而 Safari 好像是因為 Apple 嚴格的條件所以沒有擴充功能，但我今天發現的一個技巧可以協助將網頁直接重新導向到 Wikiwand。 …","frontmatter":{"title":"Wikiwand on Safari","date":"2022-08-26T13:44:50.631Z","draft":false,"tags":["wiki","wikiwand","adguard"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/70c00ace-d3b4-4326-cd8c-938fe0cc7200/public","description":null}}},{"node":{"id":"abbc4a5c-22fa-521b-8c76-c393653c057b","html":"<p>Amend Commit 就是用來修改最新 Commit 的指令，如果要修改更之前的 Commit，就要用 Rebase 或是 Reset 了。</p>\n<!--more-->\n<h2>修改 Commit Message</h2>\n<p>如果最新的 Commit Message 亂寫或是寫的什麼不該寫的，就可以用 Amend Commit 來修改。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> commit --amend -m <span class=\"token string\">\"新的 Commit Message\"</span></code></pre></div>\n<h2>壓進前一次 Commit</h2>\n<p>我常常會先將目前的修改給 Commit 一下當作存檔，但如果每次都只有小修改就 Commit 一次也會造成 Commit 非常多，所以我們可以在 Commit 的時候用 Amend Commit 壓進前一次 Commit，或是想像成修改上一次的 Commit 把這次的修改給加進去。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span>\n<span class=\"token function\">git</span> commit --amend</code></pre></div>","rawMarkdownBody":"\nAmend Commit 就是用來修改最新 Commit 的指令，如果要修改更之前的 Commit，就要用 Rebase 或是 Reset 了。\n\n<!--more-->\n\n## 修改 Commit Message\n\n如果最新的 Commit Message 亂寫或是寫的什麼不該寫的，就可以用 Amend Commit 來修改。\n\n```bash\ngit commit --amend -m \"新的 Commit Message\"\n```\n\n## 壓進前一次 Commit\n\n我常常會先將目前的修改給 Commit 一下當作存檔，但如果每次都只有小修改就 Commit 一次也會造成 Commit 非常多，所以我們可以在 Commit 的時候用 Amend Commit 壓進前一次 Commit，或是想像成修改上一次的 Commit 把這次的修改給加進去。\n\n```bash\ngit add .\ngit commit --amend\n```\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Git/amend.md","excerpt":"Amend Commit 就是用來修改最新 Commit 的指令，如果要修改更之前的 Commit，就要用 Rebase 或是 Reset 了。 修改 Commit Message 如果最新的 Commit Message 亂寫或是寫的什麼不該寫的，就可以用 Amend Commit 來修改。 壓進前一次 Commit 我常常會先將目前的修改給 Commit 一下當作存檔，但如果每次都只有小修改…","frontmatter":{"title":"Git Amend Commit","date":"2022-08-11T13:44:12.703Z","draft":false,"tags":["git","amend","commit"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/aa912c60-37ce-4fc5-6187-568499120700/public","description":null}}},{"node":{"id":"4c2b84a4-ff67-5922-b2e9-703e3980c137","html":"<p>今天把一台古老的 Samsung Galaxy S7 從 Android 6M 刷上 Android 11R，使用 Pixle Experience ROM，並安裝 Magisk 和 GPS JoyStick 來玩 Pokemon Go。過程不難，一步步做就不會出錯，從 Andoird 6 升到 11 也沒有早成手機有明顯卡頓，佩服作者。</p>\n<!--more-->\n<p>這次的動機主要是 Pokemon Go 最近開始不支援 Android 6 以下的裝置遊玩，只好升級原本的裝置。</p>\n<h2>步驟概覽</h2>\n<ol>\n<li>刷入 TWRP</li>\n<li>刷入 Pixle Experience</li>\n<li>安裝 Magisk</li>\n<li>安裝 SmaliPatcher</li>\n<li>安裝 SafetyNet Fix</li>\n<li>安裝並設定 GPS JoyStick</li>\n<li>玩</li>\n</ol>\n<p>手機應該不一定要是 S7 也可以照著這些思路完成。</p>\n<h2>手機事前準備</h2>\n<p>開啟 USB 偵錯和 OEM 解鎖。</p>\n<p>看完本文，並可以先把會用到的東西都下載下來。</p>\n<h2>刷入 TWRP</h2>\n<ol>\n<li>進入 Download Mode</li>\n<li>用 Odin 寫入 TWRP Recovery</li>\n<li>進入 TWRP</li>\n</ol>\n<p>下載最新的 Odin 版本 (目前是 3.13.1)，<a href=\"https://odindownload.com/\">Odin 官網</a></p>\n<p>下載 <a href=\"https://twrp.me/samsung/samsunggalaxys7.html\">TWRP for Samsung Galaxy S7</a> (目前是 3.6.2)。</p>\n<p>將手機連上電腦，並關機後進入 Download Mode (POWER + VOL DOWN + HOME)。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4d367c79-5c09-4118-6b49-f09f918b8600/public\" alt=\"img\"></p>\n<p>開啟 Odin 並點 AP 選擇刷入 TWRP 檔案，關閉 Auto Reboot 後 Start，應該只要幾秒就會完成。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/dacd3ce6-e43e-490d-0a1f-4f6b430e7800/public\" alt=\"img\"></p>\n<p>強制關機 (POWER + VOL DOWN + HOME) 螢幕黑掉後馬上把音量鍵下換成音量鍵上 (POWER + VOL UP + HOME) 進入 Recovery Mode，如果到目前為止都成功的話應該就會看到 TWRP 的介面。</p>\n<h2>刷入 Pixle Experience ROM</h2>\n<p>下載 <a href=\"https://download.pixelexperience.org/herolte\">Galaxy S7 Pixle Experience</a>，目前最新版本是 (20210923-1530)。</p>\n<p>進入 TWRP 先 Wipe 四個分區：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/eed93d6e-153c-43d5-eac0-7eceeee50b00/public\" alt=\"img\"></p>\n<p>如果 Wipe 失敗且是因為沒辦法 mount data，可以參考<a href=\"https://forum.xda-developers.com/t/how-to-fix-unable-to-mount-data-internal-storage-0mb-in-twrp-permanently.3830897/\">這篇文章</a>。</p>\n<p>接下來可以選擇先將 ROM 放入 SD 卡，或是直接用 adb 命令刷 (電腦當然要裝好 adb，最快的方法還是用 Chocolatey)，我自己是直接用 adb 的命令刷。在 TWRP 主畫面選 Advanced，然後使用 ADB Sideload。</p>\n<p>開啟電腦 Terminal，cd 到放剛剛下載的 ROM 的目錄，並輸入以下命令 (檔名記得替換自己的)：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">adb sideload .\\PixelExperience_herolte-11.0-20210923-1530-OFFICIAL.zip</code></pre></div>\n<p>這個會是全部耗費最久的步驟，要有耐心地等久一點。</p>\n<p>完成後 Reboot 沒問題的話，等一兩分鐘 (官方好像是說 15 分鐘內，但我沒遇到那麼久) 應該就可以進入到系統。進入到系統後可以先做一些手機的初始化，確定手機使用上沒甚麼大問題後，可以先到 Google Play 下載 Pokemon Go 再繼續。</p>\n<h2>安裝 Magisk</h2>\n<p><a href=\"https://magiskmanager.com/\">Magisk</a> 是所有 Root 玩家應該都會用到的好東西，應該也是下載最新版就可以(目前是 25.1)。下載後要將副檔名改成 zip。可以用手機直接下載，或是用電腦下載後用 adb 命令 push 到手機中，我還是選擇用 adb，指令如下。：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">adb push magisk.zip /sdcard/Download</code></pre></div>\n<p>關機後再次進入 TWRP，這次選擇 Install，並安裝剛剛 push 到手機中的 Magisk.zip。安裝後重開機，再開啟 Magisk App 完成安裝。</p>\n<p>安裝完成 Magisk 後，進入 Magisk 右上角的設定，選擇隱藏 Magisk，取一個自己喜歡的名字，避免被 Pokemon Go 偵測到 Magisk 的存在。</p>\n<p>最後開啟兩個選項：Zygisk、強制黑名單，開啟這兩個選項後，需要再次重開機，並在<strong>設定黑名單選項</strong>中把 Pokemon Go (Pokemon Go App 好像有兩個 Package name 記得都要勾) 選擇起來。</p>\n<h2>安裝 SmaliPatcher 和 SafetyNet Fix</h2>\n<p>SmaliPatcher 是為了讓 Pokemon Go 偵測不到手機是用模擬的位置，SafetyNet 好像是讓 Pokemon Go 偵測不到有 Root (這我不是很確定，我只知道不裝進不了遊戲)</p>\n<p>繼續將手機連機到電腦，用點腦下載 <a href=\"https://forum.xda-developers.com/t/module-smali-patcher-7-4.3680053/\">SamliPatcher</a>(目前最新是 0.0.7.4)，解壓縮後是個執行檔，用系統管理員的身分執行，並勾如圖的選項 (我是勾了這三個，但聽說好像只勾第一個也可以)：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/5678afd4-b35f-4d1b-94ec-f12496862700/public\" alt=\"img\"></p>\n<p>確定手機連接到電腦後按下 ADD PATCH，這會需要跑一陣子，也需要有點內心的等候，完成會在執行檔的目錄拿到一個檔名類似 SmaliPatcherModule 的壓縮檔，一樣可以用剛剛的 adb 命令 push 到手機中，最後用 Magisk 安裝這個模組後重開機即可。</p>\n<blockquote>\n<p>SmaliPatcher 截至目前是不支援 Android 12 的，我因為這個坑卡了整個下午，Pokemon Go 都會偵測到模擬位置</p>\n</blockquote>\n<p>最後一個要安裝的東西，<a href=\"https://github.com/kdrag0n/safetynet-fix/releases\">SafetyNet Fix</a> (目前版本是 2.3.1)，可用剛剛的方式在電腦下載 zip 後 push 到手機，或是直接在手機下載，然後還是用 Magisk 安裝模組重開機即可。</p>\n<h2>設定 GPS JoyStick</h2>\n<p>不要從 Google Play 下載 GPS JoyStick，到他的<a href=\"http://gpsjoystick.theappninjas.com/\">官網</a>下載 Unlock Version (最新版本是 4.3.2)。</p>\n<p>開啟 GPS JoyStick 會看到一個隱私模式，這也是為了避免被 Pokemon Go 偵測到這個 App 的存在，所以也是自己開心取個名字重新安裝。</p>\n<p>到設定中關閉 <code class=\"language-text\">啟用間接模擬</code>，這選項預設是開啟的，一定要把它關閉。然後到開發人員選項中把模擬位置的選項設定成自己的 JoyStick 名字。</p>\n<h2>開啟 Pokemon Go</h2>\n<p>無須設定，大功告成</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://download.pixelexperience.org/herolte\">Galaxy S7 Pixle Experience</a></li>\n<li><a href=\"https://odindownload.com/\">Odin</a></li>\n<li><a href=\"https://twrp.me/samsung/samsunggalaxys7.html\">TWRP for Samsung Galaxy S7</a></li>\n<li><a href=\"https://magiskmanager.com/\">Magisk</a></li>\n<li><a href=\"https://forum.xda-developers.com/t/module-smali-patcher-7-4.3680053/\">SamliPatcher</a></li>\n<li><a href=\"http://gpsjoystick.theappninjas.com/\">GPS JoyStick</a></li>\n</ul>","rawMarkdownBody":"\n今天把一台古老的 Samsung Galaxy S7 從 Android 6M 刷上 Android 11R，使用 Pixle Experience ROM，並安裝 Magisk 和 GPS JoyStick 來玩 Pokemon Go。過程不難，一步步做就不會出錯，從 Andoird 6 升到 11 也沒有早成手機有明顯卡頓，佩服作者。\n\n<!--more-->\n\n這次的動機主要是 Pokemon Go 最近開始不支援 Android 6 以下的裝置遊玩，只好升級原本的裝置。\n\n## 步驟概覽\n\n1. 刷入 TWRP\n2. 刷入 Pixle Experience\n3. 安裝 Magisk\n4. 安裝 SmaliPatcher\n5. 安裝 SafetyNet Fix\n6. 安裝並設定 GPS JoyStick\n7. 玩\n\n手機應該不一定要是 S7 也可以照著這些思路完成。\n\n## 手機事前準備\n\n開啟 USB 偵錯和 OEM 解鎖。\n\n看完本文，並可以先把會用到的東西都下載下來。\n\n## 刷入 TWRP\n\n1. 進入 Download Mode\n2. 用 Odin 寫入 TWRP Recovery\n3. 進入 TWRP\n\n下載最新的 Odin 版本 (目前是 3.13.1)，[Odin 官網](https://odindownload.com/)\n\n下載 [TWRP for Samsung Galaxy S7](https://twrp.me/samsung/samsunggalaxys7.html) (目前是 3.6.2)。\n\n將手機連上電腦，並關機後進入 Download Mode (POWER + VOL DOWN + HOME)。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4d367c79-5c09-4118-6b49-f09f918b8600/public)\n\n開啟 Odin 並點 AP 選擇刷入 TWRP 檔案，關閉 Auto Reboot 後 Start，應該只要幾秒就會完成。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/dacd3ce6-e43e-490d-0a1f-4f6b430e7800/public)\n\n強制關機 (POWER + VOL DOWN + HOME) 螢幕黑掉後馬上把音量鍵下換成音量鍵上 (POWER + VOL UP + HOME) 進入 Recovery Mode，如果到目前為止都成功的話應該就會看到 TWRP 的介面。\n\n## 刷入 Pixle Experience ROM\n\n下載 [Galaxy S7 Pixle Experience](https://download.pixelexperience.org/herolte)，目前最新版本是 (20210923-1530)。\n\n進入 TWRP 先 Wipe 四個分區：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/eed93d6e-153c-43d5-eac0-7eceeee50b00/public)\n\n如果 Wipe 失敗且是因為沒辦法 mount data，可以參考[這篇文章](https://forum.xda-developers.com/t/how-to-fix-unable-to-mount-data-internal-storage-0mb-in-twrp-permanently.3830897/)。\n\n接下來可以選擇先將 ROM 放入 SD 卡，或是直接用 adb 命令刷 (電腦當然要裝好 adb，最快的方法還是用 Chocolatey)，我自己是直接用 adb 的命令刷。在 TWRP 主畫面選 Advanced，然後使用 ADB Sideload。\n\n開啟電腦 Terminal，cd 到放剛剛下載的 ROM 的目錄，並輸入以下命令 (檔名記得替換自己的)：\n\n```sh\nadb sideload .\\PixelExperience_herolte-11.0-20210923-1530-OFFICIAL.zip\n```\n\n這個會是全部耗費最久的步驟，要有耐心地等久一點。\n\n完成後 Reboot 沒問題的話，等一兩分鐘 (官方好像是說 15 分鐘內，但我沒遇到那麼久) 應該就可以進入到系統。進入到系統後可以先做一些手機的初始化，確定手機使用上沒甚麼大問題後，可以先到 Google Play 下載 Pokemon Go 再繼續。\n\n## 安裝 Magisk\n\n[Magisk](https://magiskmanager.com/) 是所有 Root 玩家應該都會用到的好東西，應該也是下載最新版就可以(目前是 25.1)。下載後要將副檔名改成 zip。可以用手機直接下載，或是用電腦下載後用 adb 命令 push 到手機中，我還是選擇用 adb，指令如下。：\n\n```sh\nadb push magisk.zip /sdcard/Download\n```\n\n關機後再次進入 TWRP，這次選擇 Install，並安裝剛剛 push 到手機中的 Magisk.zip。安裝後重開機，再開啟 Magisk App 完成安裝。\n\n安裝完成 Magisk 後，進入 Magisk 右上角的設定，選擇隱藏 Magisk，取一個自己喜歡的名字，避免被 Pokemon Go 偵測到 Magisk 的存在。\n\n最後開啟兩個選項：Zygisk、強制黑名單，開啟這兩個選項後，需要再次重開機，並在**設定黑名單選項**中把 Pokemon Go (Pokemon Go App 好像有兩個 Package name 記得都要勾) 選擇起來。\n\n## 安裝 SmaliPatcher 和 SafetyNet Fix\n\nSmaliPatcher 是為了讓 Pokemon Go 偵測不到手機是用模擬的位置，SafetyNet 好像是讓 Pokemon Go 偵測不到有 Root (這我不是很確定，我只知道不裝進不了遊戲)\n\n繼續將手機連機到電腦，用點腦下載 [SamliPatcher](https://forum.xda-developers.com/t/module-smali-patcher-7-4.3680053/)(目前最新是 0.0.7.4)，解壓縮後是個執行檔，用系統管理員的身分執行，並勾如圖的選項 (我是勾了這三個，但聽說好像只勾第一個也可以)：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/5678afd4-b35f-4d1b-94ec-f12496862700/public)\n\n確定手機連接到電腦後按下 ADD PATCH，這會需要跑一陣子，也需要有點內心的等候，完成會在執行檔的目錄拿到一個檔名類似 SmaliPatcherModule 的壓縮檔，一樣可以用剛剛的 adb 命令 push 到手機中，最後用 Magisk 安裝這個模組後重開機即可。\n\n> SmaliPatcher 截至目前是不支援 Android 12 的，我因為這個坑卡了整個下午，Pokemon Go 都會偵測到模擬位置\n\n最後一個要安裝的東西，[SafetyNet Fix](https://github.com/kdrag0n/safetynet-fix/releases) (目前版本是 2.3.1)，可用剛剛的方式在電腦下載 zip 後 push 到手機，或是直接在手機下載，然後還是用 Magisk 安裝模組重開機即可。\n\n## 設定 GPS JoyStick\n\n不要從 Google Play 下載 GPS JoyStick，到他的[官網](http://gpsjoystick.theappninjas.com/)下載 Unlock Version (最新版本是 4.3.2)。\n\n開啟 GPS JoyStick 會看到一個隱私模式，這也是為了避免被 Pokemon Go 偵測到這個 App 的存在，所以也是自己開心取個名字重新安裝。\n\n到設定中關閉 `啟用間接模擬`，這選項預設是開啟的，一定要把它關閉。然後到開發人員選項中把模擬位置的選項設定成自己的 JoyStick 名字。\n\n## 開啟 Pokemon Go\n\n無須設定，大功告成\n\n## Reference\n\n- [Galaxy S7 Pixle Experience](https://download.pixelexperience.org/herolte)\n- [Odin](https://odindownload.com/)\n- [TWRP for Samsung Galaxy S7](https://twrp.me/samsung/samsunggalaxys7.html)\n- [Magisk](https://magiskmanager.com/)\n- [SamliPatcher](https://forum.xda-developers.com/t/module-smali-patcher-7-4.3680053/)\n- [GPS JoyStick](http://gpsjoystick.theappninjas.com/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Android/S7 Poekmon Root.md","excerpt":"今天把一台古老的 Samsung Galaxy S7 從 Android 6M 刷上 Android 11R，使用 Pixle Experience ROM，並安裝 Magisk 和 GPS JoyStick 來玩 Pokemon Go。過程不難，一步步做就不會出錯，從 Andoird 6 升到 11 也沒有早成手機有明顯卡頓，佩服作者。 這次的動機主要是 Pokemon Go 最近開始不支援 …","frontmatter":{"title":"S7 刷 Android 11 + Pokemon Go 飛人簡單紀錄","date":"2022-07-17T13:39:39.000Z","draft":false,"tags":["android","samsung","s7","twrp","pokemon","joystick","gps","pixle","magisk","odin"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d0d9494e-6a67-4237-77aa-c4d7f059b400/public","description":null}}},{"node":{"id":"497c64d1-c2d9-57b6-bd9f-9c60e6829fa5","html":"<p>紀錄一下網站成效</p>\n<!--more-->\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/7e18d41e-67cc-45cb-92fc-2e1373ba2a00/public\" alt=\"img\"></p>\n<p>兩篇成效意外好的坑</p>\n<blockquote>\n<p>廢文沒錯</p>\n</blockquote>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://search.google.com/\">Google Search Console</a></li>\n</ul>","rawMarkdownBody":"\n紀錄一下網站成效\n\n<!--more-->\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/7e18d41e-67cc-45cb-92fc-2e1373ba2a00/public)\n\n兩篇成效意外好的坑\n\n> 廢文沒錯\n\n## Reference\n\n- [Google Search Console](https://search.google.com/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Blog/20220708 review.md","excerpt":"紀錄一下網站成效 img 兩篇成效意外好的坑 廢文沒錯 Reference Google Search Console","frontmatter":{"title":"本站 2022/7/8 成效紀錄","date":"2022-07-08T05:24:40.177Z","draft":false,"tags":["blog","gatsby","google","search"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/46de886b-02a6-48d1-e5f5-1486881dcc00/public","description":null}}},{"node":{"id":"22235767-e1e6-5ec4-a8c0-8f1428c52404","html":"<p>Cloudflare Workers 也是 Cloudflare 的佛心服務之一，可以把 node 程式部署到 Cloudflare 上的眾多節點，效能也不俗，每天還有 100,000 次的免費呼叫，也沒有冷啟動的問題，對流量不高的網頁來說完全夠用。另外，還有 Workers KV 可以用來儲存資料，這就可以寫出簡單的動態網頁，甚至是一些更複雜的應用。今天就來寫一個 Serverless 的短網址服務，並把資料存在 KV 中，就我目前自己測試下來，Workers 的效率真的沒話說。</p>\n<!--more-->\n<h2>Workers Playground</h2>\n<p>如果想要在網頁中先試試看 Workers，可以到 <a href=\"https://cloudflareworkers.com/\">Cloudflare Workers</a> 這個網站。</p>\n<p>會有一個預設的模板長這樣：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fetch\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">respondWith</span><span class=\"token punctuation\">(</span><span class=\"token function\">handleRequest</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * Fetch and log a given request object\n * @param {Request} request\n */</span>\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">handleRequest</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">request</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Got request\"</span><span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Got response\"</span><span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>讓我們先來理解一下程式碼。</p>\n<p>可以看到程式有兩個 function，其中 <code class=\"language-text\">addEventListener(...)</code> 就是程式的入口，當 Workers 收到 Request 之後，就會傳入你給他的 function，然後再決定要用什麼 Response 回傳到 Client，這裡他寫了一個 <code class=\"language-text\">handleRequest</code> 的 function 來處理。所以這個程式碼實際上做的事，就只有把 Request 和 Response 給 log 出來，回傳原本的網頁的樣子不做任何更動。</p>\n<p>下圖是 Workers 在 Cloudflare 上的運行順序，可以看到 Workers 被放在最後一個，也就是最後一個決定要回傳什麼內容給 User 的地方，也可以理解為可以在這裡對原本的 Response 做最後的更動，再回傳給 Client。</p>\n<p>所以這個 Playground 上可以輸入任意的 URL，來預覽你的 Workers 在任何一個網站上，會對 Response 做的更動。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/32bd1508-ba78-4e94-76a0-adec503fe000/public\" alt=\"img\"></p>\n<p>也就是說如果把程式改成下面這樣，就可以發現任意網站都會變成 Google 的模樣。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fetch\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">respondWith</span><span class=\"token punctuation\">(</span><span class=\"token function\">handleRequest</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">handleRequest</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">request</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"https://google.com\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d7409a8b-8203-4e23-6491-309a4cc5b500/public\" alt=\"img\"></p>\n<p>理解後就會發現，其實 Workers 可以對網頁有即時性的更改，也就是說可以對現有的網頁加上新功能，或是在不更動原本網頁的情況下去修 bug。</p>\n<h2>Wrangler</h2>\n<p>Wrangler 是管理 Workers 會用到的 cli 工具，雖然不安裝也是可以在網頁中撰寫 Workers ，但是功能就會少很多，所以還是建議安裝一下。這裡是官方的 Repo <a href=\"https://github.com/cloudflare/wrangler2\">cloudflare/wrangler2</a>。</p>\n<p>用 npm 安裝到 Global：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> i @cloudflare/wrangler -g</code></pre></div>\n<p>還是建議去官方 Repo 看下有沒有其他注意事項</p>\n<p>安裝完成後要登入 Cloudflare 帳號，<code class=\"language-text\">wrangler login</code>，再用瀏覽器登入即可。</p>\n<h2>Init Project</h2>\n<p><code class=\"language-text\">wrangler init &lt;project-name></code> 創建新的專案，這當中 Wrangler 會問一些問題，可以按照自己的需求決定。</p>\n<p>init 完成後，可以看到自動產生了一些檔案，基本上會用到的只有 <code class=\"language-text\">wrangler.toml</code> 和 <code class=\"language-text\">index.js</code> 兩個檔案。</p>\n<p>現在可以先在 Terminal 中輸入 <code class=\"language-text\">wrangler dev</code>，就可以讓 Workers 跑在本地。</p>\n<h3>Bug</h3>\n<p>因為我的 Cloudflare 一次登入多個 User，所以在使用 wrangler 的 <strong>2.0.14</strong> 時候會出 bug 直接閃退，我解決的方式是直接在 <code class=\"language-text\">wrangler.toml</code> 中輸入 <code class=\"language-text\">account_id</code> 來避免 wrangler 會需要選擇帳號的問題。</p>\n<div class=\"gatsby-highlight\" data-language=\"toml\"><pre class=\"language-toml\"><code class=\"language-toml\"><span class=\"token key property\">account_id</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"xxxxxxxxxxxxxxx\"</span></code></pre></div>\n<h2>Cloudflare Workers KV</h2>\n<p>看到名字取作 KV，直觀的就是表示 <code class=\"language-text\">key-value</code> 鍵值對，缺點是 Key 只能對上一個 Value，不能要巢狀的 Value (像是 Json 那樣)，解決的方式其實也是不難，可以直接在 Value 中存上整的 Json 檔案，但在本文不會多做說明，可以自己研究看看。</p>\n<p>另外 Cloudflare 也有提到，KV 存取在全球可能不是即時性的，好像是只保證 60 秒後會同步到所有 Server，雖然我覺得最慢應該也是 5 內秒啦，我從來沒有感受到延遲過，但如果對即時性有疑慮的專案可能也要注意一下。</p>\n<p>下面就來創建一個 KV namespace，這就是一個 Database 的基本單位，目前 Cloudflare 是允許一個帳號有 100 個 KV namespace，所以正常來說應該也不用擔心會用完。下面用 <code class=\"language-text\">URLS</code> 當作 namespace 的名稱，因為我們是要存短網址的資料。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ wrangler kv:namespace create <span class=\"token string\">\"URLS\"</span>\n\n🌀  Creating namespace with title <span class=\"token string\">\"my-site-MY_KV\"</span>\n✨  Success<span class=\"token operator\">!</span>\nAdd the following to your configuration file:\nkv_namespaces <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span> binding <span class=\"token operator\">=</span> <span class=\"token string\">\"URLS\"</span>, <span class=\"token function\">id</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"xxxxxxxxxxxxxxxxxxxxxxx\"</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>然後 wrangler 會有個給你一個 binding 和 id，就直接複製貼上到 <code class=\"language-text\">wrangler.tmol</code> 中即可：</p>\n<div class=\"gatsby-highlight\" data-language=\"toml\"><pre class=\"language-toml\"><code class=\"language-toml\"><span class=\"token key property\">kv_namespaces</span> <span class=\"token punctuation\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span> <span class=\"token key property\">binding</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"URLS\"</span><span class=\"token punctuation\">,</span> <span class=\"token key property\">id</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"xxxxxxxxxxxxxxxxxxxxxxx\"</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>如果要在 wrangler 的 dev 模式中測試 KV，就多申請一個 Preview KV，來避免對已經上線的服務造成影響：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ wrangler kv:namespace create <span class=\"token string\">\"URLS\"</span> --preview\n\n⛅️ wrangler <span class=\"token number\">2.0</span>.14\n--------------------\n🌀 Creating namespace with title <span class=\"token string\">\"URLS\"</span>\n✨ Success<span class=\"token operator\">!</span>\nAdd the following to your configuration <span class=\"token function\">file</span> <span class=\"token keyword\">in</span> your kv_namespaces array:\n<span class=\"token punctuation\">{</span> binding <span class=\"token operator\">=</span> <span class=\"token string\">\"URLS\"</span>, preview_id <span class=\"token operator\">=</span> <span class=\"token string\">\"xxxxxxxxxxxxxxxxxxxx2\"</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>這次把 <code class=\"language-text\">preview_id</code> 加在原本的 id 後方即可：</p>\n<div class=\"gatsby-highlight\" data-language=\"toml\"><pre class=\"language-toml\"><code class=\"language-toml\"><span class=\"token key property\">kv_namespaces</span> <span class=\"token punctuation\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token key property\">binding</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"URLS\"</span><span class=\"token punctuation\">,</span> <span class=\"token key property\">id</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"xxxxxxxxxxxxxxxxxxxx\"</span><span class=\"token punctuation\">,</span> <span class=\"token key property\">preview_id</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"xxxxxxxxxxxxxxxxxxxx2\"</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>設定好後，wrangler 會直接把你剛剛取的名字直接用環境變數 (ENV) 傳入，具體的使用方式可以繼續往下看。</p>\n<h2>Routing</h2>\n<p>為了方便等等我們處理傳入的 Routing，我們先來安裝一個 npm 套件。對你沒看錯，Workers 也是支援 npm 套件的：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">yarn</span> <span class=\"token function\">add</span> itty-router\n\n<span class=\"token function\">npm</span> i itty-router</code></pre></div>\n<p>這樣等等就可以用 itty-router 來處理傳入的 request。</p>\n<p>我們先將 Handle Request 完全丟給的 itty-router 來處理，將 index.js 改成下方這樣：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Router <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"itty-router\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> router <span class=\"token operator\">=</span> <span class=\"token function\">Router</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">fetch</span><span class=\"token operator\">:</span> router<span class=\"token punctuation\">.</span>handle<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>可以看到直接 export router 的 handle 方法，這樣就完全把 Requse 交給 Router 來處理。我們先將 root 回傳 Hello 測試看看：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Router <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"itty-router\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> router <span class=\"token operator\">=</span> <span class=\"token function\">Router</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nrouter<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> env</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Response</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello Workers\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">status</span><span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">fetch</span><span class=\"token operator\">:</span> router<span class=\"token punctuation\">.</span>handle<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>現在可以 <code class=\"language-text\">wrangler dev</code> 一下，然後到 <code class=\"language-text\">loclahost:8787/</code> 看看會不會回傳 Hello Workers。</p>\n<blockquote>\n<p>之後的程式碼就不再完整的寫出來了，但就是在這個大框架下撰寫</p>\n</blockquote>\n<h3>New 短網址</h3>\n<p>我們寫一個 post 方法來接收新的網址，並回傳他的新短網址給他。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">router<span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/new\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> env</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> body <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> req<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 取得 POST JSON BODY 並轉成 JS 物件</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> <span class=\"token punctuation\">{</span> url<span class=\"token punctuation\">,</span> len <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> body<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>url <span class=\"token operator\">==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">f00</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// JSON 有誤，回傳 400 錯誤</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">isValidHttpUrl</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">f00</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"URL is not valid\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 確認是否為 Http 網址</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>len <span class=\"token operator\">==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> len <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>len <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">f00</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Lenght must be at least 4\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 確認至少大於等於 4</span>\n  <span class=\"token keyword\">var</span> s <span class=\"token operator\">=</span> <span class=\"token function\">getRandomString</span><span class=\"token punctuation\">(</span>len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 產生英文亂碼</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">await</span> env<span class=\"token punctuation\">.</span><span class=\"token constant\">URLS</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 從 kv 確認沒有重複</span>\n    len<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span> 有重複將 len <span class=\"token operator\">+</span><span class=\"token number\">1</span> 後再產生新的\n    s <span class=\"token operator\">=</span> <span class=\"token function\">getRandomString</span><span class=\"token punctuation\">(</span>len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">await</span> env<span class=\"token punctuation\">.</span><span class=\"token constant\">URLS</span><span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 存入 kv</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Response</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">f00</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">msg</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Response</span><span class=\"token punctuation\">(</span>msg <span class=\"token operator\">?</span> msg <span class=\"token operator\">:</span> <span class=\"token string\">\"BAD REQUEST\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">status</span><span class=\"token operator\">:</span> <span class=\"token number\">400</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">isValidHttpUrl</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> url<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    url <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">URL</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> url<span class=\"token punctuation\">.</span>protocol <span class=\"token operator\">===</span> <span class=\"token string\">\"http:\"</span> <span class=\"token operator\">||</span> url<span class=\"token punctuation\">.</span>protocol <span class=\"token operator\">===</span> <span class=\"token string\">\"https:\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getRandomString</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">len</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    s <span class=\"token operator\">+=</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">fromCharCode</span><span class=\"token punctuation\">(</span><span class=\"token function\">getRandomInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">26</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">97</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這個 POST 要吃一個像是下面的 json body，分別有要縮的網址，和要產出的短網址長度：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://tonypepe.com\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"len\"</span><span class=\"token operator\">:</span> <span class=\"token number\">3</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以發現我們是沒有做權限檢查的，所以任何人只要對 POST <code class=\"language-text\">/new</code>，都可以產生新的短網址，但我自己是覺得問題也不大，畢竟 Cloudflare 就是一家 ddos 防護商，所以要被攻擊到一天的使用量都用完應該也很難。或是你想要做權限檢查，也可以試著實作看看。</p>\n<h2>Redirect 重新導向</h2>\n<p>最後一步就是把短網址重新導向到原本的網址，這部份很簡單，就是從 kv 取得原本的網址，然後 Response HTTP 303 來做重新導向，取不到 value 就給 404。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">router<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/:path\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> env</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> params <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> req<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> url <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> env<span class=\"token punctuation\">.</span><span class=\"token constant\">URLS</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>url <span class=\"token operator\">==</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Response</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"NOT FOUND\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">status</span><span class=\"token operator\">:</span> <span class=\"token number\">404</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Response</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">status</span><span class=\"token operator\">:</span> <span class=\"token number\">303</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  response<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Location\"</span><span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> response<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Publish</h2>\n<p><code class=\"language-text\">wrangler publish</code> 就可以把程式碼部署到全球的 Cloudflare 節點，如果沒有自己網域，Cloudflare 也會給你一個 <code class=\"language-text\">xxx.workers.dev</code> 的網域免費使用，可以現在這裡測試看看，再決定要不要把自己的網域綁定上去。</p>\n<h2>後記</h2>\n<p>這篇用不到 100 行程式碼熟練了 Cloudflare 的 Serverless 服務，和寫出了短網址應用，讓我們不用自己架設自己的 Server 就可以有動態網頁的功能。我還看到官方的文件中可以把 Response 加上 Cors 的標頭，讓原本不允許跨站存取的 api 可以跨站存取，雖然很不道德，但是我喜歡。我自己還想到可以對原本的靜態網頁加上限制存取的功能，或是網頁有誤直接把網頁先導向 404，這都是很有趣的應用，大家可以自己發揮看看。</p>\n<p>如果要完整程式碼：<a href=\"https://gist.github.com/TonyPepeBear/f435dae11b83fc2626a49a6b3cc9848b\">Gist</a></p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://developers.cloudflare.com/workers/\">Cloudflare Workers documentation</a></li>\n</ul>","rawMarkdownBody":"\nCloudflare Workers 也是 Cloudflare 的佛心服務之一，可以把 node 程式部署到 Cloudflare 上的眾多節點，效能也不俗，每天還有 100,000 次的免費呼叫，也沒有冷啟動的問題，對流量不高的網頁來說完全夠用。另外，還有 Workers KV 可以用來儲存資料，這就可以寫出簡單的動態網頁，甚至是一些更複雜的應用。今天就來寫一個 Serverless 的短網址服務，並把資料存在 KV 中，就我目前自己測試下來，Workers 的效率真的沒話說。\n\n<!--more-->\n\n## Workers Playground\n\n如果想要在網頁中先試試看 Workers，可以到 [Cloudflare Workers](https://cloudflareworkers.com/) 這個網站。\n\n會有一個預設的模板長這樣：\n\n```js\naddEventListener(\"fetch\", (event) => {\n  event.respondWith(handleRequest(event.request));\n});\n\n/**\n * Fetch and log a given request object\n * @param {Request} request\n */\nasync function handleRequest(request) {\n  console.log(\"Got request\", request);\n  const response = await fetch(request);\n  console.log(\"Got response\", response);\n  return response;\n}\n```\n\n讓我們先來理解一下程式碼。\n\n可以看到程式有兩個 function，其中 `addEventListener(...)` 就是程式的入口，當 Workers 收到 Request 之後，就會傳入你給他的 function，然後再決定要用什麼 Response 回傳到 Client，這裡他寫了一個 `handleRequest` 的 function 來處理。所以這個程式碼實際上做的事，就只有把 Request 和 Response 給 log 出來，回傳原本的網頁的樣子不做任何更動。\n\n下圖是 Workers 在 Cloudflare 上的運行順序，可以看到 Workers 被放在最後一個，也就是最後一個決定要回傳什麼內容給 User 的地方，也可以理解為可以在這裡對原本的 Response 做最後的更動，再回傳給 Client。\n\n所以這個 Playground 上可以輸入任意的 URL，來預覽你的 Workers 在任何一個網站上，會對 Response 做的更動。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/32bd1508-ba78-4e94-76a0-adec503fe000/public)\n\n也就是說如果把程式改成下面這樣，就可以發現任意網站都會變成 Google 的模樣。\n\n```js\naddEventListener(\"fetch\", (event) => {\n  event.respondWith(handleRequest(event.request));\n});\n\nasync function handleRequest(request) {\n  const response = await fetch(\"https://google.com\");\n  return response;\n}\n```\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d7409a8b-8203-4e23-6491-309a4cc5b500/public)\n\n理解後就會發現，其實 Workers 可以對網頁有即時性的更改，也就是說可以對現有的網頁加上新功能，或是在不更動原本網頁的情況下去修 bug。\n\n## Wrangler\n\nWrangler 是管理 Workers 會用到的 cli 工具，雖然不安裝也是可以在網頁中撰寫 Workers ，但是功能就會少很多，所以還是建議安裝一下。這裡是官方的 Repo [cloudflare/wrangler2](https://github.com/cloudflare/wrangler2)。\n\n用 npm 安裝到 Global：\n\n```bash\nnpm i @cloudflare/wrangler -g\n```\n\n還是建議去官方 Repo 看下有沒有其他注意事項\n\n安裝完成後要登入 Cloudflare 帳號，`wrangler login`，再用瀏覽器登入即可。\n\n## Init Project\n\n`wrangler init <project-name>` 創建新的專案，這當中 Wrangler 會問一些問題，可以按照自己的需求決定。\n\ninit 完成後，可以看到自動產生了一些檔案，基本上會用到的只有 `wrangler.toml` 和 `index.js` 兩個檔案。\n\n現在可以先在 Terminal 中輸入 `wrangler dev`，就可以讓 Workers 跑在本地。\n\n### Bug\n\n因為我的 Cloudflare 一次登入多個 User，所以在使用 wrangler 的 **2.0.14** 時候會出 bug 直接閃退，我解決的方式是直接在 `wrangler.toml` 中輸入 `account_id` 來避免 wrangler 會需要選擇帳號的問題。\n\n```toml\naccount_id = \"xxxxxxxxxxxxxxx\"\n```\n\n## Cloudflare Workers KV\n\n看到名字取作 KV，直觀的就是表示 `key-value` 鍵值對，缺點是 Key 只能對上一個 Value，不能要巢狀的 Value (像是 Json 那樣)，解決的方式其實也是不難，可以直接在 Value 中存上整的 Json 檔案，但在本文不會多做說明，可以自己研究看看。\n\n另外 Cloudflare 也有提到，KV 存取在全球可能不是即時性的，好像是只保證 60 秒後會同步到所有 Server，雖然我覺得最慢應該也是 5 內秒啦，我從來沒有感受到延遲過，但如果對即時性有疑慮的專案可能也要注意一下。\n\n下面就來創建一個 KV namespace，這就是一個 Database 的基本單位，目前 Cloudflare 是允許一個帳號有 100 個 KV namespace，所以正常來說應該也不用擔心會用完。下面用 `URLS` 當作 namespace 的名稱，因為我們是要存短網址的資料。\n\n```bash\n$ wrangler kv:namespace create \"URLS\"\n\n🌀  Creating namespace with title \"my-site-MY_KV\"\n✨  Success!\nAdd the following to your configuration file:\nkv_namespaces = [\n  { binding = \"URLS\", id = \"xxxxxxxxxxxxxxxxxxxxxxx\" }\n]\n```\n\n然後 wrangler 會有個給你一個 binding 和 id，就直接複製貼上到 `wrangler.tmol` 中即可：\n\n```toml\nkv_namespaces = [\n  { binding = \"URLS\", id = \"xxxxxxxxxxxxxxxxxxxxxxx\" }\n]\n```\n\n如果要在 wrangler 的 dev 模式中測試 KV，就多申請一個 Preview KV，來避免對已經上線的服務造成影響：\n\n```bash\n$ wrangler kv:namespace create \"URLS\" --preview\n\n⛅️ wrangler 2.0.14\n--------------------\n🌀 Creating namespace with title \"URLS\"\n✨ Success!\nAdd the following to your configuration file in your kv_namespaces array:\n{ binding = \"URLS\", preview_id = \"xxxxxxxxxxxxxxxxxxxx2\" }\n```\n\n這次把 `preview_id` 加在原本的 id 後方即可：\n\n```toml\nkv_namespaces = [\n    { binding = \"URLS\", id = \"xxxxxxxxxxxxxxxxxxxx\", preview_id = \"xxxxxxxxxxxxxxxxxxxx2\" }\n]\n```\n\n設定好後，wrangler 會直接把你剛剛取的名字直接用環境變數 (ENV) 傳入，具體的使用方式可以繼續往下看。\n\n## Routing\n\n為了方便等等我們處理傳入的 Routing，我們先來安裝一個 npm 套件。對你沒看錯，Workers 也是支援 npm 套件的：\n\n```bash\nyarn add itty-router\n\nnpm i itty-router\n```\n\n這樣等等就可以用 itty-router 來處理傳入的 request。\n\n我們先將 Handle Request 完全丟給的 itty-router 來處理，將 index.js 改成下方這樣：\n\n```js\nimport { Router } from \"itty-router\";\n\nconst router = Router();\n\nexport default {\n  fetch: router.handle,\n};\n```\n\n可以看到直接 export router 的 handle 方法，這樣就完全把 Requse 交給 Router 來處理。我們先將 root 回傳 Hello 測試看看：\n\n```js\nimport { Router } from \"itty-router\";\n\nconst router = Router();\n\nrouter.get(\"/\", async (req, env) => {\n  return new Response(\"Hello Workers\", {\n    status: 200,\n  });\n});\n\nexport default {\n  fetch: router.handle,\n};\n```\n\n現在可以 `wrangler dev` 一下，然後到 `loclahost:8787/` 看看會不會回傳 Hello Workers。\n\n> 之後的程式碼就不再完整的寫出來了，但就是在這個大框架下撰寫\n\n### New 短網址\n\n我們寫一個 post 方法來接收新的網址，並回傳他的新短網址給他。\n\n```js\nrouter.post(\"/new\", async (req, env) => {\n  const body = await req.json();        // 取得 POST JSON BODY 並轉成 JS 物件\n  console.log(JSON.stringify(body));\n  var { url, len } = body;\n  if (url == undefined) return f00(\"\"); // JSON 有誤，回傳 400 錯誤\n  if (!isValidHttpUrl(url)) return f00(\"URL is not valid\");  // 確認是否為 Http 網址\n  if (len == undefined) len = 5;\n  if (len < 4) return f00(\"Lenght must be at least 4\"); // 確認至少大於等於 4\n  var s = getRandomString(len); // 產生英文亂碼\n  while ((await env.URLS.get(s)) != undefined) { // 從 kv 確認沒有重複\n    len++; 有重複將 len +1 後再產生新的\n    s = getRandomString(len);\n  }\n  await env.URLS.put(s, url); // 存入 kv\n  return new Response(s);\n});\n\nconst f00 = (msg) => new Response(msg ? msg : \"BAD REQUEST\", { status: 400 });\n\nfunction isValidHttpUrl(string) {\n  let url;\n  try {\n    url = new URL(string);\n  } catch (_) {\n    return false;\n  }\n  return url.protocol === \"http:\" || url.protocol === \"https:\";\n}\n\nfunction getRandomString(len) {\n  var s = \"\";\n  for (let i = 0; i < len; i++) {\n    s += String.fromCharCode(getRandomInt(26) + 97);\n  }\n  return s;\n}\n```\n\n這個 POST 要吃一個像是下面的 json body，分別有要縮的網址，和要產出的短網址長度：\n\n```json\n{\n  \"url\": \"https://tonypepe.com\",\n  \"len\": 3\n}\n```\n\n可以發現我們是沒有做權限檢查的，所以任何人只要對 POST `/new`，都可以產生新的短網址，但我自己是覺得問題也不大，畢竟 Cloudflare 就是一家 ddos 防護商，所以要被攻擊到一天的使用量都用完應該也很難。或是你想要做權限檢查，也可以試著實作看看。\n\n## Redirect 重新導向\n\n最後一步就是把短網址重新導向到原本的網址，這部份很簡單，就是從 kv 取得原本的網址，然後 Response HTTP 303 來做重新導向，取不到 value 就給 404。\n\n```js\nrouter.get(\"/:path\", async (req, env) => {\n  const { params } = req;\n  const url = await env.URLS.get(params.path.toLowerCase());\n  if (url == undefined) return new Response(\"NOT FOUND\", { status: 404 });\n  const response = new Response(\"\", { status: 303 });\n  response.headers.append(\"Location\", url);\n  return response;\n});\n```\n\n## Publish\n\n`wrangler publish` 就可以把程式碼部署到全球的 Cloudflare 節點，如果沒有自己網域，Cloudflare 也會給你一個 `xxx.workers.dev` 的網域免費使用，可以現在這裡測試看看，再決定要不要把自己的網域綁定上去。\n\n## 後記\n\n這篇用不到 100 行程式碼熟練了 Cloudflare 的 Serverless 服務，和寫出了短網址應用，讓我們不用自己架設自己的 Server 就可以有動態網頁的功能。我還看到官方的文件中可以把 Response 加上 Cors 的標頭，讓原本不允許跨站存取的 api 可以跨站存取，雖然很不道德，但是我喜歡。我自己還想到可以對原本的靜態網頁加上限制存取的功能，或是網頁有誤直接把網頁先導向 404，這都是很有趣的應用，大家可以自己發揮看看。\n\n如果要完整程式碼：[Gist](https://gist.github.com/TonyPepeBear/f435dae11b83fc2626a49a6b3cc9848b)\n\n## Reference\n\n- [Cloudflare Workers documentation](https://developers.cloudflare.com/workers/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/cf-workers-short-url.md","excerpt":"Cloudflare Workers 也是 Cloudflare 的佛心服務之一，可以把 node 程式部署到 Cloudflare 上的眾多節點，效能也不俗，每天還有 100,000 次的免費呼叫，也沒有冷啟動的問題，對流量不高的網頁來說完全夠用。另外，還有 Workers KV 可以用來儲存資料，這就可以寫出簡單的動態網頁，甚至是一些更複雜的應用。今天就來寫一個 Serverless 的短網…","frontmatter":{"title":"用 Cloudflare Workers 架設 Serverless 短網址服務","date":"2022-06-21T09:15:49.000Z","draft":false,"tags":["cloudflare","workers","worker","web","short","url"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b6cf9d30-1028-4aa5-c136-0dbc6c098f00/public","description":null}}},{"node":{"id":"1f835006-d336-5140-acce-32c9475d47e1","html":"<p>最近把網站從 Hugo 遷移到 Gatsby，遇到了一些問題，我就來簡單記錄一下解決問題的過程，而且因為我對 Node 也不是很熟，所以主要是在當作我練習 Node 和 React。</p>\n<!--more-->\n<h2>Why？</h2>\n<ol>\n<li>Hugo 實在很難使用 Node 套件</li>\n<li>單純想給自己一個接觸 Node 的機會</li>\n</ol>\n<p>許多網頁的套件庫都是使用 node 開發的，但因為 Hugo 是用 go 開發，雖然有提供對 npm 套件的支援，但是還是沒有原生的方便，在用套件的時候常常會遇到問題。所以我還是下定決心換到 Gatsby，也可以順便熟悉一下 React。另外，我是使用 TypeScript 來開發，這也是有點虐待自己，不過還好還是順利完成，也對 TS 有多點認識。</p>\n<p>目前遇到的一個最大的缺點，大概就是 Hugo 產生網頁的速度真的超級快，Gatsby 因為依賴一大堆 npm 套件，所以我在 Cloudflare Pages 上的平均需要大約 5 分鐘網頁才能建置好。</p>\n<h2>遇到的問題</h2>\n<p>目前遇到的主要問題大概就是下面三點：</p>\n<ol>\n<li>npm build 不成功</li>\n<li>觀看更多的功能</li>\n<li>meilisearch</li>\n</ol>\n<h2>npm to yarn</h2>\n<p>一開始我是使用 npm 作為套件管理，我在本機開發時都沒有遇到什麼問題，直到我幾乎都開發完成後，我就將網頁 push 到 GitHub 上，GitHub Actions 在 Build 時也沒有遇到問題，直到 Cloudflare Pages 在建置時，就是會一直失敗，我也一直確定 node 和 npm 版本跟我本地的一樣，但無論如何就是失敗，直到我上網查後，才發現 Gatsby 官方也是建議使用 yarn，npm 好像會遇到問題。我就試著 <code class=\"language-text\">yarn</code> 一下，讓專案自動遷移到 yarn，就沒又再出現問題了，實在莫名其妙。所以也是建議大家以後若有使用到 Gatsby，還是使用 yarn 比較好一點。</p>\n<h2>觀看更多</h2>\n<p>在 Hugo 時，Hugo 支援在 Markdown 中使用 <code class=\"language-text\">&lt;!--more--></code> 的標籤來提取標籤前的部分當作文章摘要，用來顯示在 ListTemplate，而 Gatsby 只有提供提取前 n 字的功能。而這對我網頁的美觀程度就有一點不方便，因為我 Hugo 已經累計了不少文章，若要現在再去一篇篇修改，也是會有點麻煩，所以只好自己稍微研究一下要怎麼處理。</p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">Hello\n\n摘要\n\n<span class=\"token comment\">&lt;!--more--></span>\n\n正文\n\n正文</code></pre></div>\n<p>我處理的方式簡單暴力，我發現 Gatsby 在 GraphQL 的時候，可以拿到 RawMarkdown，而且這個也會保留註解，所以我靈機一動，我就自己使用 Node 套件，自己解析 Markdown 不就好了？所以我就用 <code class=\"language-text\">marked</code> 套件，幫我把 md 轉成 html。範例大致如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> marked <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"marked\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Summary</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> node <span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> Props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> summary <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>rawMarkdownBody<span class=\"token punctuation\">.</span><span class=\"token function\">spllit</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&lt;!--more-->\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div dangerouslaSetSetInnerHTML<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> __html<span class=\"token operator\">:</span> marked<span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>summary<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>MeiliSearch</h2>\n<p>我原本的 Hugo 網頁，就是使用 MeiliSearch 來當我的搜尋功能，可以參考這個 <a href=\"/search/tag?tag=meilisearch\">tag</a> 。所以一樣是會需要產生一個 <code class=\"language-text\">SearchIndex.json</code>，我直接在 <code class=\"language-text\">gatsby-node.ts</code> 裡的 <code class=\"language-text\">noPostBuild</code> 手動產生 json，再用 <code class=\"language-text\">fs</code> 寫入檔案，直接給大家程式碼參考。</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> onPostBuild<span class=\"token operator\">:</span> GatsbyNode<span class=\"token punctuation\">[</span><span class=\"token string\">\"onPostBuild\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  graphql<span class=\"token punctuation\">,</span>\n  actions<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> errors<span class=\"token punctuation\">,</span> data <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token generic-function\"><span class=\"token function\">graphql</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>ArticleListData<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>articleGraphql<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// SearchIndex.json</span>\n  <span class=\"token keyword\">const</span> searchArr<span class=\"token operator\">:</span> SearchIndex<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  data<span class=\"token operator\">!</span><span class=\"token operator\">!</span><span class=\"token punctuation\">.</span>allMarkdownRemark<span class=\"token punctuation\">.</span>edges<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> node <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> summary <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>rawMarkdownBody<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&lt;!--more-->\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> url <span class=\"token operator\">=</span>\n      <span class=\"token string\">\"/posts/\"</span> <span class=\"token operator\">+</span>\n      node<span class=\"token punctuation\">.</span>fileAbsolutePath\n        <span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/posts/\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".md\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"-\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> miliseconds <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">.</span>frontmatter<span class=\"token punctuation\">.</span>date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    searchArr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      id<span class=\"token operator\">:</span> index<span class=\"token punctuation\">,</span>\n      date<span class=\"token operator\">:</span> miliseconds<span class=\"token punctuation\">,</span>\n      url<span class=\"token operator\">:</span> url<span class=\"token punctuation\">,</span>\n      title<span class=\"token operator\">:</span> node<span class=\"token punctuation\">.</span>frontmatter<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">,</span>\n      summary<span class=\"token operator\">:</span> summary<span class=\"token punctuation\">,</span>\n      content<span class=\"token operator\">:</span> node<span class=\"token punctuation\">.</span>internal<span class=\"token punctuation\">.</span>content<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      tags<span class=\"token operator\">:</span> node<span class=\"token punctuation\">.</span>frontmatter<span class=\"token punctuation\">.</span>tags<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  fs<span class=\"token punctuation\">.</span><span class=\"token function\">writeFileSync</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./public/SearchIndex.json\"</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>searchArr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>產生 Json 後，我一樣是使用 GitHub Actions 來自動把 Index 推到 MeiliSearch Server。</p>\n<h2>Tag Page</h2>\n<p>其實 Gatsby 應該也是有方法可以產生 Tag Page，但是因為我想到要用 Tag Page 時，我已經弄好 MeiliSearch 了，所以我就靈機一動，想想是不是也可以直接簡單的使用 MeiliSearch 來動態的產生 Tag Page 就好，結果還真的被我弄成功了，就來紀錄一下我大概的思路。雖然我知道這八成不是什麼好方法，但是簡單暴力。</p>\n<p>MeiliSearch 可以設定 <code class=\"language-text\">filterableAttributes</code> 的屬性，所以我把我的 Index 中的 Tag 屬性設定成可以 Filterable，然後再取得網址的 Params，最後向 MeiliSearch 搜尋後動態的把結果顯示在網頁上。也可以參考<a href=\"https://docs.meilisearch.com/learn/advanced/filtering_and_faceted_search.html#configuring-filters\">官方文件</a>。</p>\n<p>這時遇到的問題就是 Gatsby 是 Server Side Rendering，所以取的 Params 要使用額外的 plugin，我是使用 <code class=\"language-text\">gatsby-plugin-use-query-params</code>，就可以像是 React 的 useState 的方式來取的網址的 Parm。</p>\n<p>也是提供部分的程式碼給大家參考：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">SearchTags</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span> tag <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> _<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useQueryParams</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> tag<span class=\"token operator\">:</span> StringParam <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 取的 Params</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>result<span class=\"token punctuation\">,</span> setResult<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isLoading<span class=\"token punctuation\">,</span> setIsLoading<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  React<span class=\"token punctuation\">.</span><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 執行搜尋</span>\n    client\n      <span class=\"token punctuation\">.</span><span class=\"token function\">index</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"gatsby-blog\"</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">search</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n        filter<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"tags=\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>tag <span class=\"token operator\">?</span> tag <span class=\"token operator\">:</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n        limit<span class=\"token operator\">:</span> Number<span class=\"token punctuation\">.</span><span class=\"token constant\">MAX_SAFE_INTEGER</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>res<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setResult</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>hits<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setIsLoading</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>MainLayout title<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"tag: \"</span> <span class=\"token operator\">+</span> tag <span class=\"token operator\">+</span> <span class=\"token string\">\" - TonyPepe\"</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>h1 className<span class=\"token operator\">=</span><span class=\"token string\">\"my-4 bg-white rounded-md py-4 px-6 text-2xl\"</span><span class=\"token operator\">></span>\n          <span class=\"token punctuation\">{</span><span class=\"token string\">\"Tag: \"</span> <span class=\"token operator\">+</span> tag<span class=\"token punctuation\">}</span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n        <span class=\"token punctuation\">{</span>isLoading <span class=\"token operator\">?</span> <span class=\"token operator\">&lt;</span>LoadingChild <span class=\"token operator\">/</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span> <span class=\"token operator\">&lt;</span>ResultClild hits<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>result<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>MainLayout<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> client <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MeiliSearch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  host<span class=\"token operator\">:</span> <span class=\"token string\">\"https://search.tonypepe.com\"</span><span class=\"token punctuation\">,</span>\n  apiKey<span class=\"token operator\">:</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>後紀</h2>\n<p>Node 在建置上實在是太慢，真的會有一點受不了，每次光是要 Run 起 Dev Server，就至少需要 30 秒，相比 Hugo 就算是有裝一點點的 npm 套件，還是只要 10 秒左右就可以開始寫網頁了。</p>\n<p>當然，使用 Gatsby 開發的好處也是很多，可以最大化的自訂網頁的長相和功能，不會被 Hugo 的功能限制住，如果缺少了什麼功能，都可以自己用 js 開發出來，而且在使用一些 Web Library 和 React 真的太方便了。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://gatsbyjs.org/\">Gatsby</a></li>\n<li><a href=\"https://docs.meilisearch.com/learn/advanced/filtering_and_faceted_search.html#configuring-filters\">MeiliSearch - Filtering and faceted search</a></li>\n</ul>","rawMarkdownBody":"\n最近把網站從 Hugo 遷移到 Gatsby，遇到了一些問題，我就來簡單記錄一下解決問題的過程，而且因為我對 Node 也不是很熟，所以主要是在當作我練習 Node 和 React。\n\n<!--more-->\n\n## Why？\n\n1. Hugo 實在很難使用 Node 套件\n2. 單純想給自己一個接觸 Node 的機會\n\n許多網頁的套件庫都是使用 node 開發的，但因為 Hugo 是用 go 開發，雖然有提供對 npm 套件的支援，但是還是沒有原生的方便，在用套件的時候常常會遇到問題。所以我還是下定決心換到 Gatsby，也可以順便熟悉一下 React。另外，我是使用 TypeScript 來開發，這也是有點虐待自己，不過還好還是順利完成，也對 TS 有多點認識。\n\n目前遇到的一個最大的缺點，大概就是 Hugo 產生網頁的速度真的超級快，Gatsby 因為依賴一大堆 npm 套件，所以我在 Cloudflare Pages 上的平均需要大約 5 分鐘網頁才能建置好。\n\n## 遇到的問題\n\n目前遇到的主要問題大概就是下面三點：\n\n1. npm build 不成功\n2. 觀看更多的功能\n3. meilisearch\n\n## npm to yarn\n\n一開始我是使用 npm 作為套件管理，我在本機開發時都沒有遇到什麼問題，直到我幾乎都開發完成後，我就將網頁 push 到 GitHub 上，GitHub Actions 在 Build 時也沒有遇到問題，直到 Cloudflare Pages 在建置時，就是會一直失敗，我也一直確定 node 和 npm 版本跟我本地的一樣，但無論如何就是失敗，直到我上網查後，才發現 Gatsby 官方也是建議使用 yarn，npm 好像會遇到問題。我就試著 `yarn` 一下，讓專案自動遷移到 yarn，就沒又再出現問題了，實在莫名其妙。所以也是建議大家以後若有使用到 Gatsby，還是使用 yarn 比較好一點。\n\n## 觀看更多\n\n在 Hugo 時，Hugo 支援在 Markdown 中使用 `<!--more-->` 的標籤來提取標籤前的部分當作文章摘要，用來顯示在 ListTemplate，而 Gatsby 只有提供提取前 n 字的功能。而這對我網頁的美觀程度就有一點不方便，因為我 Hugo 已經累計了不少文章，若要現在再去一篇篇修改，也是會有點麻煩，所以只好自己稍微研究一下要怎麼處理。\n\n```md\nHello\n\n摘要\n\n<!--more-->\n\n正文\n\n正文\n```\n\n我處理的方式簡單暴力，我發現 Gatsby 在 GraphQL 的時候，可以拿到 RawMarkdown，而且這個也會保留註解，所以我靈機一動，我就自己使用 Node 套件，自己解析 Markdown 不就好了？所以我就用 `marked` 套件，幫我把 md 轉成 html。範例大致如下：\n\n```typescript\nimport { marked } from \"marked\";\n\nexport default function Summary({ node }: Props) {\n  const summary = node.rawMarkdownBody.spllit(\"<!--more-->\")[0];\n  return <div dangerouslaSetSetInnerHTML={{ __html: marked.parse(summary) }} />;\n}\n```\n\n## MeiliSearch\n\n我原本的 Hugo 網頁，就是使用 MeiliSearch 來當我的搜尋功能，可以參考這個 [tag](/search/tag?tag=meilisearch) 。所以一樣是會需要產生一個 `SearchIndex.json`，我直接在 `gatsby-node.ts` 裡的 `noPostBuild` 手動產生 json，再用 `fs` 寫入檔案，直接給大家程式碼參考。\n\n```typescript\nexport const onPostBuild: GatsbyNode[\"onPostBuild\"] = async ({\n  graphql,\n  actions,\n}) => {\n  const { errors, data } = await graphql<ArticleListData>(articleGraphql);\n  // SearchIndex.json\n  const searchArr: SearchIndex[] = [];\n  data!!.allMarkdownRemark.edges.forEach(({ node }, index) => {\n    const summary = node.rawMarkdownBody.split(\"<!--more-->\")[0];\n    const url =\n      \"/posts/\" +\n      node.fileAbsolutePath\n        .split(\"/posts/\")[1]\n        .split(\".md\")[0]\n        .replace(\" \", \"-\")\n        .toLowerCase();\n    const miliseconds = new Date(node.frontmatter.date).getTime();\n    searchArr.push({\n      id: index,\n      date: miliseconds,\n      url: url,\n      title: node.frontmatter.title,\n      summary: summary,\n      content: node.internal.content.replace(\"\\n\", \" \"),\n      tags: node.frontmatter.tags,\n    });\n  });\n  fs.writeFileSync(\"./public/SearchIndex.json\", JSON.stringify(searchArr));\n};\n```\n\n產生 Json 後，我一樣是使用 GitHub Actions 來自動把 Index 推到 MeiliSearch Server。\n\n## Tag Page\n\n其實 Gatsby 應該也是有方法可以產生 Tag Page，但是因為我想到要用 Tag Page 時，我已經弄好 MeiliSearch 了，所以我就靈機一動，想想是不是也可以直接簡單的使用 MeiliSearch 來動態的產生 Tag Page 就好，結果還真的被我弄成功了，就來紀錄一下我大概的思路。雖然我知道這八成不是什麼好方法，但是簡單暴力。\n\nMeiliSearch 可以設定 `filterableAttributes` 的屬性，所以我把我的 Index 中的 Tag 屬性設定成可以 Filterable，然後再取得網址的 Params，最後向 MeiliSearch 搜尋後動態的把結果顯示在網頁上。也可以參考[官方文件](https://docs.meilisearch.com/learn/advanced/filtering_and_faceted_search.html#configuring-filters)。\n\n這時遇到的問題就是 Gatsby 是 Server Side Rendering，所以取的 Params 要使用額外的 plugin，我是使用 `gatsby-plugin-use-query-params`，就可以像是 React 的 useState 的方式來取的網址的 Parm。\n\n也是提供部分的程式碼給大家參考：\n\n```typescript\nexport default function SearchTags() {\n  const [{ tag }, _] = useQueryParams({ tag: StringParam }); // 取的 Params\n  const [result, setResult] = React.useState([]);\n  const [isLoading, setIsLoading] = React.useState(true);\n  React.useEffect(() => {\n    // 執行搜尋\n    client\n      .index(\"gatsby-blog\")\n      .search(\"\", {\n        filter: [\"tags=\" + (tag ? tag : \"\")],\n        limit: Number.MAX_SAFE_INTEGER,\n      })\n      .then((res: any) => {\n        setResult(res.hits);\n        setIsLoading(false);\n      });\n  }, []);\n  return (\n    <MainLayout title={\"tag: \" + tag + \" - TonyPepe\"}>\n      <div>\n        <h1 className=\"my-4 bg-white rounded-md py-4 px-6 text-2xl\">\n          {\"Tag: \" + tag}\n        </h1>\n        {isLoading ? <LoadingChild /> : <ResultClild hits={result} />}\n      </div>\n    </MainLayout>\n  );\n}\n\nconst client = new MeiliSearch({\n  host: \"https://search.tonypepe.com\",\n  apiKey: \"\",\n});\n```\n\n## 後紀\n\nNode 在建置上實在是太慢，真的會有一點受不了，每次光是要 Run 起 Dev Server，就至少需要 30 秒，相比 Hugo 就算是有裝一點點的 npm 套件，還是只要 10 秒左右就可以開始寫網頁了。\n\n當然，使用 Gatsby 開發的好處也是很多，可以最大化的自訂網頁的長相和功能，不會被 Hugo 的功能限制住，如果缺少了什麼功能，都可以自己用 js 開發出來，而且在使用一些 Web Library 和 React 真的太方便了。\n\n## Reference\n\n- [Gatsby](https://gatsbyjs.org/)\n- [MeiliSearch - Filtering and faceted search](https://docs.meilisearch.com/learn/advanced/filtering_and_faceted_search.html#configuring-filters)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/hugo-to-gatsby.md","excerpt":"最近把網站從 Hugo 遷移到 Gatsby，遇到了一些問題，我就來簡單記錄一下解決問題的過程，而且因為我對 Node 也不是很熟，所以主要是在當作我練習 Node 和 React。 Why？ Hugo 實在很難使用 Node 套件 單純想給自己一個接觸 Node 的機會 許多網頁的套件庫都是使用 node 開發的，但因為 Hugo 是用 go 開發，雖然有提供對 npm 套件的支援，但是還是沒…","frontmatter":{"title":"從 Hugo 遷到 Gatsby 的紀錄","date":"2022-06-01T15:17:28.142Z","draft":false,"tags":["hugo","gatsby","blog","web","node","npm","meilisearch","search"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/2892b2bf-2c12-4d17-21f7-ba2e57c98100/public","description":null}}},{"node":{"id":"af3c84b0-2162-5466-8b24-f810139828dd","html":"<p>記錄一些我怕忘的 Command Line 技巧，當作字典用。</p>\n<!--more-->\n<h2>清螢幕</h2>\n<p><code class=\"language-text\">clear</code> 或是 <code class=\"language-text\">ctrl + L</code></p>\n<h2>家目錄</h2>\n<p><code class=\"language-text\">~</code> 波浪符就是代表家目錄</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">/etc$ <span class=\"token builtin class-name\">cd</span> ~\n\n~$</code></pre></div>\n<h2>預設文字編輯器</h2>\n<p>有時預設的文字編輯器不是 vim，而是 <code class=\"language-text\">nano</code> 或是 <code class=\"language-text\">emacs</code>，在打 git 指令時，會進錯編輯器。只要在 <code class=\"language-text\">.bashrc</code> 中加入以下兩行：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">EDITOR</span><span class=\"token operator\">=</span>vim\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">VISUAL</span><span class=\"token operator\">=</span>vim</code></pre></div>\n<h2>變更 rc file 後馬上生效</h2>\n<p><code class=\"language-text\">source ~/.bashrc</code></p>\n<h2>返回上一個路徑</h2>\n<p><code class=\"language-text\">cd -</code></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">~$ <span class=\"token builtin class-name\">cd</span> /etc\n\n/etc$ <span class=\"token builtin class-name\">cd</span> /var\n\n/var$ <span class=\"token builtin class-name\">cd</span> -\n\n/etc$ <span class=\"token builtin class-name\">cd</span> ~\n\n~$</code></pre></div>\n<h2>把路徑放進 Stack</h2>\n<p><code class=\"language-text\">pushd</code> 把現在的路徑推進 Stack，並 cd 到後面的參數</p>\n<p><code class=\"language-text\">popd</code> 拿出來</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">/etc$ <span class=\"token function\">pushd</span> /var\n/var /etc\n\n/var$ <span class=\"token function\">pushd</span> /home\n/home /var /etc\n\n/home$ <span class=\"token builtin class-name\">cd</span> ~\n\n~$ <span class=\"token builtin class-name\">cd</span> /var/\n\n~$ <span class=\"token builtin class-name\">cd</span> /var/lib/\n\n/var/lib$ <span class=\"token function\">popd</span>\n/var /etc\n\n/var$ <span class=\"token function\">popd</span>\n/etc\n\n/etc$</code></pre></div>\n<h2>把工作放到背景</h2>\n<p><code class=\"language-text\">ctrl + z</code></p>\n<p>注意，這會暫停整個 process，並不是放到背景執行</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">~$ <span class=\"token function\">vim</span> /proc/cpuinfo\n\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>+  Stopped                 <span class=\"token function\">vim</span> /proc/cpuinfo\n\n~$</code></pre></div>\n<p><code class=\"language-text\">fg</code> (foreground) 把放到背景的 process 取回前景繼續執行</p>\n<p>Shell 結束時，所有被暫停的 process 也會一起被殺掉</p>\n<h2>重複上一個 Command</h2>\n<p><code class=\"language-text\">!!</code> 就是代表上一個 Command</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">~$ <span class=\"token builtin class-name\">echo</span> HI\nHI\n\n~$ <span class=\"token operator\">!</span><span class=\"token operator\">!</span>\n<span class=\"token builtin class-name\">echo</span> HI\nHI\n\n~$</code></pre></div>\n<p>這是可以組合技的：忘記打 sudo 就 <code class=\"language-text\">sudo !!</code></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">~$ <span class=\"token function\">apt</span> update\nReading package lists<span class=\"token punctuation\">..</span>. Done\nE: Could not <span class=\"token function\">open</span> lock <span class=\"token function\">file</span> /var/lib/apt/lists/lock - <span class=\"token function\">open</span> <span class=\"token punctuation\">(</span><span class=\"token number\">13</span>: Permission denied<span class=\"token punctuation\">)</span>\nE: Unable to lock directory /var/lib/apt/lists/\n\n~$ <span class=\"token function\">sudo</span> <span class=\"token operator\">!</span><span class=\"token operator\">!</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update\nHit:1 http://archive.ubuntu.com/ubuntu jammy InRelease\nGet:2 http://security.ubuntu.com/ubuntu jammy-security InRelease <span class=\"token punctuation\">[</span><span class=\"token number\">110</span> kB<span class=\"token punctuation\">]</span>\nGet:3 http://archive.ubuntu.com/ubuntu jammy-updates InRelease <span class=\"token punctuation\">[</span><span class=\"token number\">109</span> kB<span class=\"token punctuation\">]</span>\nGet:4 http://archive.ubuntu.com/ubuntu jammy-backports InRelease <span class=\"token punctuation\">[</span><span class=\"token number\">99.8</span> kB<span class=\"token punctuation\">]</span>\nGet:5 http://archive.ubuntu.com/ubuntu jammy-updates/main amd64 Packages <span class=\"token punctuation\">[</span><span class=\"token number\">230</span> kB<span class=\"token punctuation\">]</span>\nGet:6 http://archive.ubuntu.com/ubuntu jammy-updates/restricted amd64 Packages <span class=\"token punctuation\">[</span><span class=\"token number\">143</span> kB<span class=\"token punctuation\">]</span>\nFetched <span class=\"token number\">693</span> kB <span class=\"token keyword\">in</span> 2s <span class=\"token punctuation\">(</span><span class=\"token number\">328</span> kB/s<span class=\"token punctuation\">)</span>\nReading package lists<span class=\"token punctuation\">..</span>. Done\nBuilding dependency tree<span class=\"token punctuation\">..</span>. Done\nReading state information<span class=\"token punctuation\">..</span>. Done\n<span class=\"token number\">1</span> package can be upgraded. Run <span class=\"token string\">'apt list --upgradable'</span> to see it.\n~$</code></pre></div>\n<h2>sudo 不輸入密碼</h2>\n<p>只要讓下面那一行出現在 <code class=\"language-text\">/etc/sudoers</code> 中就可以：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">%sudo ALL=(ALL) NOPASSWD:ALL</code></pre></div>\n<p>或是直接輸入 (with root)：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span> ~$ <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'%sudo ALL=(ALL) NOPASSWD:ALL'</span> <span class=\"token operator\">>></span> /etc/sudoers</code></pre></div>\n<h2>搜尋打過的指令</h2>\n<p><code class=\"language-text\">ctrl + r</code>，然後打上部分記得的指令，就會自動補完</p>\n<h2>輸出導進 less</h2>\n<p>有時指令輸出很長，需要翻頁顯示時，可以用 <code class=\"language-text\">|</code> 導入 <code class=\"language-text\">less</code></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">~$ <span class=\"token function\">cat</span> /proc/cpuinfo <span class=\"token operator\">|</span> <span class=\"token function\">less</span></code></pre></div>\n<h2>清掉一整行</h2>\n<p><code class=\"language-text\">ctrl + u</code> 把還沒 enter 的指令清掉</p>\n<h2>光標到最前或最後</h2>\n<p><code class=\"language-text\">ctrl + a</code> 移動光標到最前</p>\n<p><code class=\"language-text\">ctrl + e</code> 移動光標到最後</p>\n<h2>連續執行指令</h2>\n<p><code class=\"language-text\">;</code> 不管前面有沒有成功，都執行後面的命令</p>\n<p><code class=\"language-text\">&amp;&amp;</code> 要前面得執行成功，才執行後面的命令</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">~$ <span class=\"token function\">ls</span> / <span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> hi\nbin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\nhi\n\n~$ <span class=\"token function\">ls</span> / <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">echo</span> hi\nbin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\nhi\n\n~$ <span class=\"token function\">ls</span> /no_such_dir <span class=\"token punctuation\">;</span> <span class=\"token builtin class-name\">echo</span> hi\nls: cannot access <span class=\"token string\">'/no_such_dir'</span><span class=\"token builtin class-name\">:</span> No such <span class=\"token function\">file</span> or directory\nhi\n\n~$ <span class=\"token function\">ls</span> /no_such_dir <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">echo</span> hi\nls: cannot access <span class=\"token string\">'/no_such_dir'</span><span class=\"token builtin class-name\">:</span> No such <span class=\"token function\">file</span> or directory</code></pre></div>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://youtube.com/watch?v=AVXYq8aL47Q\">18 Commands That Will Change The Way You Use Linux Forever</a></li>\n</ul>","rawMarkdownBody":"\n記錄一些我怕忘的 Command Line 技巧，當作字典用。\n\n<!--more-->\n\n## 清螢幕\n\n`clear` 或是 `ctrl + L`\n\n## 家目錄\n\n`~` 波浪符就是代表家目錄\n\n```bash\n/etc$ cd ~\n\n~$\n```\n\n## 預設文字編輯器\n\n有時預設的文字編輯器不是 vim，而是 `nano` 或是 `emacs`，在打 git 指令時，會進錯編輯器。只要在 `.bashrc` 中加入以下兩行：\n\n```bash\nexport EDITOR=vim\nexport VISUAL=vim\n```\n\n## 變更 rc file 後馬上生效\n\n`source ~/.bashrc`\n\n## 返回上一個路徑\n\n`cd -`\n\n```bash\n~$ cd /etc\n\n/etc$ cd /var\n\n/var$ cd -\n\n/etc$ cd ~\n\n~$\n```\n\n## 把路徑放進 Stack\n\n`pushd` 把現在的路徑推進 Stack，並 cd 到後面的參數\n\n`popd` 拿出來\n\n```bash\n/etc$ pushd /var\n/var /etc\n\n/var$ pushd /home\n/home /var /etc\n\n/home$ cd ~\n\n~$ cd /var/\n\n~$ cd /var/lib/\n\n/var/lib$ popd\n/var /etc\n\n/var$ popd\n/etc\n\n/etc$\n```\n\n## 把工作放到背景\n\n`ctrl + z`\n\n注意，這會暫停整個 process，並不是放到背景執行\n\n```bash\n~$ vim /proc/cpuinfo\n\n[1]+  Stopped                 vim /proc/cpuinfo\n\n~$\n```\n\n`fg` (foreground) 把放到背景的 process 取回前景繼續執行\n\nShell 結束時，所有被暫停的 process 也會一起被殺掉\n\n## 重複上一個 Command\n\n`!!` 就是代表上一個 Command\n\n```bash\n~$ echo HI\nHI\n\n~$ !!\necho HI\nHI\n\n~$\n```\n\n這是可以組合技的：忘記打 sudo 就 `sudo !!`\n\n```bash\n~$ apt update\nReading package lists... Done\nE: Could not open lock file /var/lib/apt/lists/lock - open (13: Permission denied)\nE: Unable to lock directory /var/lib/apt/lists/\n\n~$ sudo !!\nsudo apt update\nHit:1 http://archive.ubuntu.com/ubuntu jammy InRelease\nGet:2 http://security.ubuntu.com/ubuntu jammy-security InRelease [110 kB]\nGet:3 http://archive.ubuntu.com/ubuntu jammy-updates InRelease [109 kB]\nGet:4 http://archive.ubuntu.com/ubuntu jammy-backports InRelease [99.8 kB]\nGet:5 http://archive.ubuntu.com/ubuntu jammy-updates/main amd64 Packages [230 kB]\nGet:6 http://archive.ubuntu.com/ubuntu jammy-updates/restricted amd64 Packages [143 kB]\nFetched 693 kB in 2s (328 kB/s)\nReading package lists... Done\nBuilding dependency tree... Done\nReading state information... Done\n1 package can be upgraded. Run 'apt list --upgradable' to see it.\n~$\n```\n\n## sudo 不輸入密碼\n\n只要讓下面那一行出現在 `/etc/sudoers` 中就可以：\n\n```text\n%sudo ALL=(ALL) NOPASSWD:ALL\n```\n\n或是直接輸入 (with root)：\n\n```bash\n(root) ~$ echo '%sudo ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers\n```\n\n## 搜尋打過的指令\n\n`ctrl + r`，然後打上部分記得的指令，就會自動補完\n\n## 輸出導進 less\n\n有時指令輸出很長，需要翻頁顯示時，可以用 `|` 導入 `less`\n\n```bash\n~$ cat /proc/cpuinfo | less\n```\n\n## 清掉一整行\n\n`ctrl + u` 把還沒 enter 的指令清掉\n\n## 光標到最前或最後\n\n`ctrl + a` 移動光標到最前\n\n`ctrl + e` 移動光標到最後\n\n## 連續執行指令\n\n`;` 不管前面有沒有成功，都執行後面的命令\n\n`&&` 要前面得執行成功，才執行後面的命令\n\n```bash\n~$ ls / ; echo hi\nbin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\nhi\n\n~$ ls / && echo hi\nbin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\nhi\n\n~$ ls /no_such_dir ; echo hi\nls: cannot access '/no_such_dir': No such file or directory\nhi\n\n~$ ls /no_such_dir && echo hi\nls: cannot access '/no_such_dir': No such file or directory\n```\n\n## Reference\n\n- [18 Commands That Will Change The Way You Use Linux Forever](https://youtube.com/watch?v=AVXYq8aL47Q)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Linux/command tips.md","excerpt":"記錄一些我怕忘的 Command Line 技巧，當作字典用。 清螢幕  或是  家目錄  波浪符就是代表家目錄 預設文字編輯器 有時預設的文字編輯器不是 vim，而是  或是 ，在打 git 指令時，會進錯編輯器。只要在  中加入以下兩行： 變更 rc file 後馬上生效  返回上一個路徑  把路徑放進 Stack  把現在的路徑推進 Stack，並 cd 到後面的參數  拿出來 把工作放到…","frontmatter":{"title":"一些 Command Line 技巧","date":"2022-05-25T15:27:30.000Z","draft":false,"tags":["linux","ubuntu","mac","command","max"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9dfac9e4-1de1-43dc-eead-381301a1b500/public","description":null}}},{"node":{"id":"22c3b17c-4301-5fb4-9145-fa9a71fdb584","html":"<p>為什麼要在 Container 中 Coding？因爲開發中最大的難題總是在環境建置，好不容易建置好環境，要寫下個專案時，因為電腦已經髒兮兮，安裝環境時就會容易衝到版本，而造成惡性循環，環境建置一次比一次困難，最後發現重灌電腦最快。在 Container 中 Coding 就可以簡單用完即丟，每次都可以在乾淨的電腦安裝環境，裝任何東西也不怕把本機弄髒，在 Windows 上更可以簡單的在 Linux 中開發。</p>\n<!--more-->\n<p>在 Container 裡 Coding 已經不是什麼新鮮事，VSCode 的官方就有提供 <a href=\"https://code.visualstudio.com/docs/remote/containers\">Developing inside a Container</a> 的官方文件，可以用本機的 Docker 快速的產生 Container 並且在裡面開發。壞處就是只能在本機連線，如果有多台電腦想要共同開發的需求，就只好用今天要介紹的方式，用 SSH 連入 Container，只要連得上 SSH 就可以開發，開發時也不用被侷限在一台電腦的 Docker 上。當然，最大的缺點就是要有一台一直運作著 Docker 的 Server 可以讓你隨時連線。GitHub 有一個 <a href=\"https://github.com/features/codespaces\">Codespace</a> 的功能，就是很類似的想法，Code in Cloud，但畢竟是企業的收費服務，我之前有抽到預覽版，到現在都可以免費使用，是真的很方便的功能，也就是他的方便，讓我想研究如何自己架類似的服務。</p>\n<h2>Dockerfile</h2>\n<p>簡單來說就是創建一個已經被預裝 SSH Server 的 Linux，我們今天就用 Ubuntu，然後順便預裝一些開發中常會用到套件，像是 <code class=\"language-text\">git</code>, <code class=\"language-text\">vim</code> 等等。</p>\n<blockquote>\n<p>如果想跳過這步驟，用我創建好的 Image 可以拉到下一個章節去看</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">ARG</span> UBUNTU_VERSION=latest</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">FROM</span> ubuntu:<span class=\"token variable\">${UBUNTU_VERSION}</span></span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">ENV</span> DEBIAN_FRONTEND noninteractive</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> apt update <span class=\"token operator\">\\</span>\n    &amp;&amp; apt install -y openssh-server ssh sudo git vim <span class=\"token operator\">\\</span>\n    &amp;&amp; useradd -rm -d /home/ubuntu -s /bin/bash -g root -G sudo -u 1000 ubuntu <span class=\"token operator\">\\</span>\n    &amp;&amp; echo <span class=\"token string\">\"ubuntu:ubuntu\"</span> | chpasswd <span class=\"token operator\">\\</span>\n    &amp;&amp; echo <span class=\"token string\">'%sudo ALL=(ALL) NOPASSWD:ALL'</span> >> /etc/sudoers <span class=\"token operator\">\\</span>\n    &amp;&amp; service ssh start</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">EXPOSE</span> 22</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"/usr/sbin/sshd\"</span>, <span class=\"token string\">\"-D\"</span>]</span></code></pre></div>\n<p>可以看到我把帳號密碼都設置為 <code class=\"language-text\">ubuntu</code>，然後讓 <code class=\"language-text\">sudo</code> 時可以不用密碼。然後安裝啟動 ssh service，最後開啟 22 port。用下面的 Docker 指令就可以創建自己的 Image：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> build -t ssh-ubuntu <span class=\"token builtin class-name\">.</span></code></pre></div>\n<h3>我構建好的 Image</h3>\n<p>我有創一個 GitHub Repo 放我的 Dockerfile，並用 GitHub Actions + Packages 來發布 Image，Image 名稱為 <code class=\"language-text\">ghcr.io/tonypepebear/ssh-dev-ubuntu</code>。</p>\n<p><a href=\"https://github.com/TonyPepeBear/ssh-dev-container/pkgs/container/ssh-dev-ubuntu\">Package 網址</a></p>\n<h2>啟動 Container 並 SSH 連入</h2>\n<p>啟動 Container 並把 22 Port 弄出來，我是映射到 8222：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> run -dp <span class=\"token number\">8222</span>:22 ssh-ubuntu\n\n如果要用我的 Image：\n<span class=\"token function\">docker</span> run -dp <span class=\"token number\">8222</span>:22 ghcr.io/tonypepebear/ssh-dev-ubuntu</code></pre></div>\n<p>SSH 連入，詢問密碼就是 <code class=\"language-text\">ubuntu</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">ssh</span> -p <span class=\"token number\">8222</span> ubuntu@localhost</code></pre></div>\n<p>如果沒發生問題，到現在應該就可以順利的連到 Container 中。</p>\n<h2>VSCode SSH 連線</h2>\n<p>需要先在 VSCode 中安裝 Remote - SSH 套件，如圖：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/be8ec8dc-8900-4cbe-1587-45fa6f3f6500/public\" alt=\"img\"></p>\n<p>安裝完成後，點擊最左下角的 Remote 功能，再選擇 Connect to SSH Host，輸入 SSH 指令 <code class=\"language-text\">ssh -p 8222 ubuntu@localhost</code>，就可以順利連到 Container 中。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/960ea18c-82c7-4ce1-73d3-8ff092f2b000/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/814b9dac-f39d-4d07-1095-2d280cd5e300/public\" alt=\"img\"></p>\n<h2>後記</h2>\n<p>其實我也不會每個專案都新增一個新的 Container，而是用到我受不了或衝突到後，才創建一個新的，畢竟每次創新的 Container 也是有點麻煩，但是能讓我在安裝一些亂七八糟的環境 (就是在說你們 npm, pip) 時，可以大膽地按下去，不用擔心把電腦搞到受不了才是重點。希望大家在開發的路上可以更加順利。</p>\n<p>另外，VSCode 的 SSH 連線功能真的做的不錯，甚至可以 Port Forwarding，在開發網頁的時候不用在 Docker 中多 Forwarding 一個 Port，可以隨時用 VSCode Forwarding 到本機上。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://code.visualstudio.com/docs/remote/ssh\">Remote Development using SSH</a></li>\n</ul>","rawMarkdownBody":"\n為什麼要在 Container 中 Coding？因爲開發中最大的難題總是在環境建置，好不容易建置好環境，要寫下個專案時，因為電腦已經髒兮兮，安裝環境時就會容易衝到版本，而造成惡性循環，環境建置一次比一次困難，最後發現重灌電腦最快。在 Container 中 Coding 就可以簡單用完即丟，每次都可以在乾淨的電腦安裝環境，裝任何東西也不怕把本機弄髒，在 Windows 上更可以簡單的在 Linux 中開發。\n\n<!--more-->\n\n在 Container 裡 Coding 已經不是什麼新鮮事，VSCode 的官方就有提供 [Developing inside a Container](https://code.visualstudio.com/docs/remote/containers) 的官方文件，可以用本機的 Docker 快速的產生 Container 並且在裡面開發。壞處就是只能在本機連線，如果有多台電腦想要共同開發的需求，就只好用今天要介紹的方式，用 SSH 連入 Container，只要連得上 SSH 就可以開發，開發時也不用被侷限在一台電腦的 Docker 上。當然，最大的缺點就是要有一台一直運作著 Docker 的 Server 可以讓你隨時連線。GitHub 有一個 [Codespace](https://github.com/features/codespaces) 的功能，就是很類似的想法，Code in Cloud，但畢竟是企業的收費服務，我之前有抽到預覽版，到現在都可以免費使用，是真的很方便的功能，也就是他的方便，讓我想研究如何自己架類似的服務。\n\n## Dockerfile\n\n簡單來說就是創建一個已經被預裝 SSH Server 的 Linux，我們今天就用 Ubuntu，然後順便預裝一些開發中常會用到套件，像是 `git`, `vim` 等等。\n\n> 如果想跳過這步驟，用我創建好的 Image 可以拉到下一個章節去看\n\n```Dockerfile\nARG UBUNTU_VERSION=latest\n\nFROM ubuntu:${UBUNTU_VERSION}\n\nENV DEBIAN_FRONTEND noninteractive\n\nRUN apt update \\\n    && apt install -y openssh-server ssh sudo git vim \\\n    && useradd -rm -d /home/ubuntu -s /bin/bash -g root -G sudo -u 1000 ubuntu \\\n    && echo \"ubuntu:ubuntu\" | chpasswd \\\n    && echo '%sudo ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers \\\n    && service ssh start\n\nEXPOSE 22\n\nCMD [\"/usr/sbin/sshd\", \"-D\"]\n```\n\n可以看到我把帳號密碼都設置為 `ubuntu`，然後讓 `sudo` 時可以不用密碼。然後安裝啟動 ssh service，最後開啟 22 port。用下面的 Docker 指令就可以創建自己的 Image：\n\n```shell\ndocker build -t ssh-ubuntu .\n```\n\n### 我構建好的 Image\n\n我有創一個 GitHub Repo 放我的 Dockerfile，並用 GitHub Actions + Packages 來發布 Image，Image 名稱為 `ghcr.io/tonypepebear/ssh-dev-ubuntu`。\n\n[Package 網址](https://github.com/TonyPepeBear/ssh-dev-container/pkgs/container/ssh-dev-ubuntu)\n\n## 啟動 Container 並 SSH 連入\n\n啟動 Container 並把 22 Port 弄出來，我是映射到 8222：\n\n```shell\ndocker run -dp 8222:22 ssh-ubuntu\n\n如果要用我的 Image：\ndocker run -dp 8222:22 ghcr.io/tonypepebear/ssh-dev-ubuntu\n```\n\nSSH 連入，詢問密碼就是 `ubuntu`：\n\n```shell\nssh -p 8222 ubuntu@localhost\n```\n\n如果沒發生問題，到現在應該就可以順利的連到 Container 中。\n\n## VSCode SSH 連線\n\n需要先在 VSCode 中安裝 Remote - SSH 套件，如圖：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/be8ec8dc-8900-4cbe-1587-45fa6f3f6500/public)\n\n安裝完成後，點擊最左下角的 Remote 功能，再選擇 Connect to SSH Host，輸入 SSH 指令 `ssh -p 8222 ubuntu@localhost`，就可以順利連到 Container 中。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/960ea18c-82c7-4ce1-73d3-8ff092f2b000/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/814b9dac-f39d-4d07-1095-2d280cd5e300/public)\n\n## 後記\n\n其實我也不會每個專案都新增一個新的 Container，而是用到我受不了或衝突到後，才創建一個新的，畢竟每次創新的 Container 也是有點麻煩，但是能讓我在安裝一些亂七八糟的環境 (就是在說你們 npm, pip) 時，可以大膽地按下去，不用擔心把電腦搞到受不了才是重點。希望大家在開發的路上可以更加順利。\n\n另外，VSCode 的 SSH 連線功能真的做的不錯，甚至可以 Port Forwarding，在開發網頁的時候不用在 Docker 中多 Forwarding 一個 Port，可以隨時用 VSCode Forwarding 到本機上。\n\n## Reference\n\n- [Remote Development using SSH](https://code.visualstudio.com/docs/remote/ssh)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/VSCode/SSH Dev Container.md","excerpt":"為什麼要在 Container 中 Coding？因爲開發中最大的難題總是在環境建置，好不容易建置好環境，要寫下個專案時，因為電腦已經髒兮兮，安裝環境時就會容易衝到版本，而造成惡性循環，環境建置一次比一次困難，最後發現重灌電腦最快。在 Container 中 Coding 就可以簡單用完即丟，每次都可以在乾淨的電腦安裝環境，裝任何東西也不怕把本機弄髒，在 Windows 上更可以簡單的在 Lin…","frontmatter":{"title":"VSCode SSH 連入 Docker Container","date":"2022-05-21T14:07:16.000Z","draft":false,"tags":["vscode","ssh","docker"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0f3867f8-dd79-482c-1f27-a7a166f7dc00/public","description":null}}},{"node":{"id":"9b4fd17c-47e0-5706-ae0f-62acdd29fab4","html":"<p>Kotlin 在多工處理上提供非常好用的 Coroutine。當不同 Job 之間需要傳遞資料時，總會遇到許多問題，以前最簡單的方式就是 Callback，但 Callback 模式已經在各個程式語言中產生許多問題，這邊就不多討論。Kotlin Coroutine 如果只是要回傳一個值，可以直接用 Suspend 的 Return 值，但如果是要回傳很多資料呢？簡單的方式是直接回傳 List，可是如果資料非常大，也會產生出問題。所以 Kotlin 提供 Flow 來幫助解決大量資料傳遞的問題。</p>\n<!--more-->\n<h2>Kotline Coroutine</h2>\n<p>如果還不知道什麼是 Coroutine 的，我以前也有寫過<a href=\"/posts/kotlin/kotlin-coroutine/\">Kotlin Coroutine</a>。</p>\n<h2>List OF Numbers</h2>\n<p>讓我們先來看一個簡單的範例，產生一個會回傳 1 到 100 的 Int Function：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> ans <span class=\"token operator\">=</span> mutableListOf<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ans<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> ans\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span> <span class=\"token punctuation\">{</span> value <span class=\"token operator\">-></span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>乍看之下沒什麼問題，但是如果這是一個需要大量 CPU 或 IO 處理的工作而且回傳值非常大，就會對記憶體產生負擔。下面假設我們需要 1 到 100,000，並用 <code class=\"language-text\">delay()</code> 模擬 CPU 工作，然後改成 Suspend Function。下面也把 main 改成 <code class=\"language-text\">runBlocking</code>，方便執行 Suspend Function：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> ans <span class=\"token operator\">=</span> mutableListOf<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">100_000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n        ans<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> ans\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span> <span class=\"token punctuation\">{</span> value <span class=\"token operator\">-></span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的範例就會對記憶體產生一定的負擔，這時就是改成 Flow 的好時機：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">100_000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以看到上面的範例沒有一次產生一個很大的 List，再一次把資料回傳，寫的也可以更簡潔。</p>\n<h2>Flow is Cold</h2>\n<p>這句話的意思是，如果 Flow 沒有被 Collect，那麼 Flow 就永遠不會被執行。</p>\n<p>下面的例子我們在 Emit 前加上一個 <code class=\"language-text\">println</code> ，並用一個變數接住一個 Flow，但不去呼叫 Collect，所以會先輸出 <code class=\"language-text\">Hello World</code> 才會輸出 <code class=\"language-text\">Start Flow</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Start Flow\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> n<span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello World\"</span></span><span class=\"token punctuation\">)</span>\n    n<span class=\"token punctuation\">.</span><span class=\"token function\">collect</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>輸出：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Hello World\nStart Flow\n1\n2\n3\n4\n5</code></pre></div>\n<h2>Emit 時 才會呼叫 Collect</h2>\n<p>把上面的例子再 emit 前加上一個 <code class=\"language-text\">println()</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Start Flow\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"emit </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">i</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> n<span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello World\"</span></span><span class=\"token punctuation\">)</span>\n    n<span class=\"token punctuation\">.</span><span class=\"token function\">collect</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>it<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>看到輸出可以發現，會先看到 emit() 上面的 print 被執行，才會執行到呼叫 collect 時傳進去的 function。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Hello World\nStart Flow\nemit 1\n1\nemit 2\n2\nemit 3\n3\nemit 4\n4\nemit 5\n5</code></pre></div>\n<h2>Flow 的資料量是固定的</h2>\n<p>這句話的意思並不是說 flow 只能定義好數量再回傳，而是說如果 flow 裡的所有 emit 沒有被 collect，就會出錯。</p>\n<p>下面的 flow 就一定要被 collect 五次，如果因為呼叫他的 function 被意外中斷，這個 flow 也會拋出錯誤。</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">nums</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>那麼如果我只要一定數量的資料怎麼辦？下面範例取自官方文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">numbers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"This line will not execute\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Finally in numbers\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">numbers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// take only the first two</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">collect</span> <span class=\"token punctuation\">{</span> value <span class=\"token operator\">-></span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/* output:\n1\n2\nFinally in numbers\n*/</span></code></pre></div>\n<h2>Flow mapping</h2>\n<p>Flow 可以用 map 的方式，轉換成另一個 Flow。</p>\n<p>這個例子產生平方數：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">allNumbers</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">square</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">allNumbers</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span> <span class=\"token punctuation\">{</span> it <span class=\"token operator\">*</span> it <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">square</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">it</span></span><span class=\"token string\"> \"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// output: 1 4 9 16 25 36 49 64 81 100</span></code></pre></div>\n<h2>Flow Filter</h2>\n<p>這個例子輸出 1 到 100 之間的所有質數(勿模仿，效率堪憂)：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">allNumbers</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> flow <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">1</span><span class=\"token operator\">..</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">suspend</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">primeNumbers</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Flow<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">allNumbers</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span> <span class=\"token punctuation\">{</span> it<span class=\"token punctuation\">.</span><span class=\"token function\">isPrime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> Int<span class=\"token punctuation\">.</span><span class=\"token function\">isPrime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Boolean <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token keyword\">in</span> <span class=\"token number\">2</span><span class=\"token operator\">..</span>this <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token operator\">%</span> i <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">primeNumbers</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">it</span></span><span class=\"token string\"> \"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// output: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97</span></code></pre></div>\n<blockquote>\n<p>碎念：這段程式真的充分展現 Kotlin 的威力..</p>\n</blockquote>\n<h2>後記</h2>\n<p>Flow 還有很多複雜的用法，像是合併兩個 flow 之類的，建議有興趣的人可以自己去看官方文件。</p>\n<p>另外，Kotlin 其實還有一個叫做 Sequence 的 Interface，跟 Flow 非常像，在不是需要多線程的時候就已經很夠用，Flow 主要在多線程中使用，Sequence 單線程中使用。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://kotlinlang.org/docs/flow.html\">Asynchronous Flow</a></li>\n</ul>","rawMarkdownBody":"\nKotlin 在多工處理上提供非常好用的 Coroutine。當不同 Job 之間需要傳遞資料時，總會遇到許多問題，以前最簡單的方式就是 Callback，但 Callback 模式已經在各個程式語言中產生許多問題，這邊就不多討論。Kotlin Coroutine 如果只是要回傳一個值，可以直接用 Suspend 的 Return 值，但如果是要回傳很多資料呢？簡單的方式是直接回傳 List，可是如果資料非常大，也會產生出問題。所以 Kotlin 提供 Flow 來幫助解決大量資料傳遞的問題。\n\n<!--more-->\n\n## Kotline Coroutine\n\n如果還不知道什麼是 Coroutine 的，我以前也有寫過[Kotlin Coroutine](/posts/kotlin/kotlin-coroutine/)。\n\n## List OF Numbers\n\n讓我們先來看一個簡單的範例，產生一個會回傳 1 到 100 的 Int Function：\n\n```kotlin\nfun nums(): List<Int> {\n    val ans = mutableListOf<Int>()\n    for (i in 1..100) {\n        ans.add(i)\n    }\n    return ans\n}\n\nfun main() {\n    nums().forEach { value ->\n        println(value)\n    }\n}\n```\n\n乍看之下沒什麼問題，但是如果這是一個需要大量 CPU 或 IO 處理的工作而且回傳值非常大，就會對記憶體產生負擔。下面假設我們需要 1 到 100,000，並用 `delay()` 模擬 CPU 工作，然後改成 Suspend Function。下面也把 main 改成 `runBlocking`，方便執行 Suspend Function：\n\n```kotlin\nsuspend fun nums(): List<Int> {\n    val ans = mutableListOf<Int>()\n    for (i in 1..100_000) {\n        delay(100)\n        ans.add(i)\n    }\n    return ans\n}\n\nfun main() = runBlocking {\n    nums().forEach { value ->\n        println(value)\n    }\n}\n```\n\n上面的範例就會對記憶體產生一定的負擔，這時就是改成 Flow 的好時機：\n\n```kotlin\nsuspend fun nums(): Flow<Int> = flow {\n    for (i in 1..100_000) {\n        delay(100)\n        emit(i)\n    }\n}\n\nfun main() = runBlocking {\n    nums().collect {\n        println(it)\n    }\n}\n```\n\n可以看到上面的範例沒有一次產生一個很大的 List，再一次把資料回傳，寫的也可以更簡潔。\n\n## Flow is Cold\n\n這句話的意思是，如果 Flow 沒有被 Collect，那麼 Flow 就永遠不會被執行。\n\n下面的例子我們在 Emit 前加上一個 `println` ，並用一個變數接住一個 Flow，但不去呼叫 Collect，所以會先輸出 `Hello World` 才會輸出 `Start Flow`。\n\n```kotlin\nsuspend fun nums(): Flow<Int> = flow {\n    println(\"Start Flow\")\n    for (i in 1..5) {\n        delay(100)\n        emit(i)\n    }\n}\n\nfun main() = runBlocking {\n    var n: Flow<Int> = nums()\n    println(\"Hello World\")\n    n.collect {\n        println(it)\n    }\n}\n```\n\n輸出：\n\n```text\nHello World\nStart Flow\n1\n2\n3\n4\n5\n```\n\n## Emit 時 才會呼叫 Collect\n\n把上面的例子再 emit 前加上一個 `println()`：\n\n```kotlin\nsuspend fun nums(): Flow<Int> = flow {\n    println(\"Start Flow\")\n    for (i in 1..5) {\n        delay(100)\n        println(\"emit $i\")\n        emit(i)\n    }\n}\n\nfun main() = runBlocking {\n    var n: Flow<Int> = nums()\n    println(\"Hello World\")\n    n.collect {\n        println(it)\n    }\n}\n```\n\n看到輸出可以發現，會先看到 emit() 上面的 print 被執行，才會執行到呼叫 collect 時傳進去的 function。\n\n```text\nHello World\nStart Flow\nemit 1\n1\nemit 2\n2\nemit 3\n3\nemit 4\n4\nemit 5\n5\n```\n\n## Flow 的資料量是固定的\n\n這句話的意思並不是說 flow 只能定義好數量再回傳，而是說如果 flow 裡的所有 emit 沒有被 collect，就會出錯。\n\n下面的 flow 就一定要被 collect 五次，如果因為呼叫他的 function 被意外中斷，這個 flow 也會拋出錯誤。\n\n```kotlin\nsuspend fun nums(): Flow<Int> = flow {\n    for (i in 1..5) {\n        emit(i)\n    }\n}\n```\n\n那麼如果我只要一定數量的資料怎麼辦？下面範例取自官方文件：\n\n```kotlin\nfun numbers(): Flow<Int> = flow {\n    try {\n        emit(1)\n        emit(2)\n        println(\"This line will not execute\")\n        emit(3)\n    } finally {\n        println(\"Finally in numbers\")\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    numbers()\n        .take(2) // take only the first two\n        .collect { value -> println(value) }\n}\n\n/* output:\n1\n2\nFinally in numbers\n*/\n```\n\n## Flow mapping\n\nFlow 可以用 map 的方式，轉換成另一個 Flow。\n\n這個例子產生平方數：\n\n```kotlin\nsuspend fun allNumbers(n: Int): Flow<Int> = flow {\n    for (i in 1..n) {\n        emit(i)\n    }\n}\n\nsuspend fun square(n: Int): Flow<Int> = allNumbers(n).map { it * it }\n\nfun main() = runBlocking {\n    square(10).collect {\n        print(\"$it \")\n    }\n}\n\n// output: 1 4 9 16 25 36 49 64 81 100\n```\n\n## Flow Filter\n\n這個例子輸出 1 到 100 之間的所有質數(勿模仿，效率堪憂)：\n\n```kotlin\nsuspend fun allNumbers(n: Int): Flow<Int> = flow {\n    for (i in 1..n) {\n        emit(i)\n    }\n}\n\nsuspend fun primeNumbers(n: Int): Flow<Int> = allNumbers(n).filter { it.isPrime() }\n\nfun Int.isPrime(): Boolean {\n    if (this <= 1) return false\n    for (i in 2..this / 2) {\n        if (this % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun main() = runBlocking {\n    primeNumbers(100).collect {\n        print(\"$it \")\n    }\n}\n\n// output: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97\n```\n\n> 碎念：這段程式真的充分展現 Kotlin 的威力..\n\n## 後記\n\nFlow 還有很多複雜的用法，像是合併兩個 flow 之類的，建議有興趣的人可以自己去看官方文件。\n\n另外，Kotlin 其實還有一個叫做 Sequence 的 Interface，跟 Flow 非常像，在不是需要多線程的時候就已經很夠用，Flow 主要在多線程中使用，Sequence 單線程中使用。\n\n## Reference\n\n- [Asynchronous Flow](https://kotlinlang.org/docs/flow.html)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Kotlin/Kotlin Flow.md","excerpt":"Kotlin 在多工處理上提供非常好用的 Coroutine。當不同 Job 之間需要傳遞資料時，總會遇到許多問題，以前最簡單的方式就是 Callback，但 Callback 模式已經在各個程式語言中產生許多問題，這邊就不多討論。Kotlin Coroutine 如果只是要回傳一個值，可以直接用 Suspend 的 Return 值，但如果是要回傳很多資料呢？簡單的方式是直接回傳 List，可…","frontmatter":{"title":"Kotlin Flow","date":"2022-04-17T14:00:13.000Z","draft":false,"tags":["kotlin","coroutines","flow","android"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/973beda6-caa9-4559-1f92-8ab5bd7d2700/public","description":null}}},{"node":{"id":"90e0fd93-6420-5e55-aef4-b691b3fcf6e2","html":"<p>最近常常會看到別入 GitHub 上的 Commit 會有 Verified 的字樣，查了才知道這是為了防止有人盜用你的 email 簽 commit，畢竟 git 的 user.email 是可以自己隨便設的，所以 GitHub 就提供一個可以用公私鑰的方式來確認身份。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6e429f76-94c1-46ff-77da-7d50a886d100/public\" alt=\"img\"></p>\n<!--more-->\n<h2>GnuPG</h2>\n<p>我們要利用 GnuPG 來產生金鑰和簽署 Commit，當然要先安裝他，可以自己查一下自己的 OS 要怎麼裝：</p>\n<p><a href=\"https://www.gnupg.org/download\">Download GnuPG</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">brew install gnupg     # macOS\nchoco install gnupg    # Windows\napt install gnupg      # Ubuntu</code></pre></div>\n<h2>產生 GPG Key</h2>\n<p>用下面的一行指令就會進到互動式的畫面，接下來需要輸入一些資料：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">gpg --full-generate-key</code></pre></div>\n<ol>\n<li>產生 Rsa and Rsa</li>\n<li>GitHub 建議使用 4096，最複雜的就對了</li>\n<li>金鑰要不要過期可以自己評估，我是選不過期</li>\n<li>確認資料輸入正確</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d6411985-0b33-4ab2-e883-f95ce0da3c00/public\" alt=\"img\"></p>\n<ol>\n<li>輸入要簽署的名字</li>\n<li>輸入要簽署的 email，注意必須與 GitHub Email 和 <code class=\"language-text\">git config user.email</code> 的一樣。</li>\n<li>註釋隨便輸入即可</li>\n<li>確認資料輸入正確</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/594a269c-ab4f-4484-fa9a-c74307454600/public\" alt=\"img\"></p>\n<p>接下來會跳出一個要輸入密碼的畫面，一樣依自己需求設定即可</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6b11a19b-c7fa-4697-0861-5fb4c66ff800/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/56a8fc50-5a1e-4a0e-e9ef-30b9fe74fc00/public\" alt=\"img\"></p>\n<p>這樣就產生成功了，可以記一下這個畫面出現的資料</p>\n<p>如果要顯示所有的 Key：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">gpg --list-secret-keys</code></pre></div>\n<h2>複製 GPG Key 到 GitHub</h2>\n<p>用各個指令來顯示公鑰，並且複製到 GitHub 上，包含 Begin 和 End 兩行：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">gpg --armor --export <span class=\"token operator\">&lt;</span>Your Key<span class=\"token operator\">></span></code></pre></div>\n<p>進到設定裡，新增 GPG Key，貼上剛剛複製下的金鑰</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8a75edb9-4a08-4060-608a-d63353a77c00/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9c5ad211-0bcc-4058-a304-6903e69c8700/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0ef8e55b-7f1b-43ab-cd40-43303b98bc00/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/32e1e3a5-2fdc-4e6d-aef3-08122d448d00/public\" alt=\"img\"></p>\n<h2>簽署 Commit</h2>\n<p>要簽署 Commit 我們需要先告訴 git 我們要用哪支鑰匙，也是用 git config 設定，如果要每個倉庫都用這支鑰匙，可以直接設定 global：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> config user.signingkey <span class=\"token operator\">&lt;</span>Your Key<span class=\"token operator\">></span>\n<span class=\"token function\">git</span> config --global user.signingkey <span class=\"token operator\">&lt;</span>Your Key<span class=\"token operator\">></span></code></pre></div>\n<p>設定好後，我們就可以開始簽 Commit，基本上就是在 Commit 時加上 <code class=\"language-text\">-S</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> commit -S -m <span class=\"token string\">\"Commit Message\"</span></code></pre></div>\n<p>如果覺得每次都要加上參數很麻煩，也可以直接加到 config 中，讓每次 Commit 都預設簽署：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> config commit.gpgsign <span class=\"token boolean\">true</span>\n<span class=\"token function\">git</span> config --global commit.gpgsign <span class=\"token boolean\">true</span></code></pre></div>\n<p>接下來，只要 push 到 GitHub 上，就會看到有 Verified 的標籤：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6e429f76-94c1-46ff-77da-7d50a886d100/public\" alt=\"img\"></p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://docs.github.com/en/authentication/managing-commit-signature-verification/generating-a-new-gpg-key\">Generating a new GPG key</a></li>\n<li><a href=\"https://docs.github.com/en/authentication/managing-commit-signature-verification/adding-a-new-gpg-key-to-your-github-account\">Adding a new GPG key to your GitHub account</a></li>\n<li><a href=\"https://www.gnupg.org/\">GnuPG</a></li>\n</ul>","rawMarkdownBody":"\n最近常常會看到別入 GitHub 上的 Commit 會有 Verified 的字樣，查了才知道這是為了防止有人盜用你的 email 簽 commit，畢竟 git 的 user.email 是可以自己隨便設的，所以 GitHub 就提供一個可以用公私鑰的方式來確認身份。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6e429f76-94c1-46ff-77da-7d50a886d100/public)\n\n<!--more-->\n\n## GnuPG\n\n我們要利用 GnuPG 來產生金鑰和簽署 Commit，當然要先安裝他，可以自己查一下自己的 OS 要怎麼裝：\n\n[Download GnuPG](https://www.gnupg.org/download)\n\n```text\nbrew install gnupg     # macOS\nchoco install gnupg    # Windows\napt install gnupg      # Ubuntu\n```\n\n## 產生 GPG Key\n\n用下面的一行指令就會進到互動式的畫面，接下來需要輸入一些資料：\n\n```shell\ngpg --full-generate-key\n```\n\n1. 產生 Rsa and Rsa\n2. GitHub 建議使用 4096，最複雜的就對了\n3. 金鑰要不要過期可以自己評估，我是選不過期\n4. 確認資料輸入正確\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d6411985-0b33-4ab2-e883-f95ce0da3c00/public)\n\n1. 輸入要簽署的名字\n2. 輸入要簽署的 email，注意必須與 GitHub Email 和 `git config user.email` 的一樣。\n3. 註釋隨便輸入即可\n4. 確認資料輸入正確\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/594a269c-ab4f-4484-fa9a-c74307454600/public)\n\n接下來會跳出一個要輸入密碼的畫面，一樣依自己需求設定即可\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6b11a19b-c7fa-4697-0861-5fb4c66ff800/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/56a8fc50-5a1e-4a0e-e9ef-30b9fe74fc00/public)\n\n這樣就產生成功了，可以記一下這個畫面出現的資料\n\n如果要顯示所有的 Key：\n\n```shell\ngpg --list-secret-keys\n```\n\n## 複製 GPG Key 到 GitHub\n\n用各個指令來顯示公鑰，並且複製到 GitHub 上，包含 Begin 和 End 兩行：\n\n```shell\ngpg --armor --export <Your Key>\n```\n\n進到設定裡，新增 GPG Key，貼上剛剛複製下的金鑰\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8a75edb9-4a08-4060-608a-d63353a77c00/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9c5ad211-0bcc-4058-a304-6903e69c8700/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0ef8e55b-7f1b-43ab-cd40-43303b98bc00/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/32e1e3a5-2fdc-4e6d-aef3-08122d448d00/public)\n\n## 簽署 Commit\n\n要簽署 Commit 我們需要先告訴 git 我們要用哪支鑰匙，也是用 git config 設定，如果要每個倉庫都用這支鑰匙，可以直接設定 global：\n\n```shell\ngit config user.signingkey <Your Key>\ngit config --global user.signingkey <Your Key>\n```\n\n設定好後，我們就可以開始簽 Commit，基本上就是在 Commit 時加上 `-S`：\n\n```shell\ngit commit -S -m \"Commit Message\"\n```\n\n如果覺得每次都要加上參數很麻煩，也可以直接加到 config 中，讓每次 Commit 都預設簽署：\n\n```shell\ngit config commit.gpgsign true\ngit config --global commit.gpgsign true\n```\n\n接下來，只要 push 到 GitHub 上，就會看到有 Verified 的標籤：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6e429f76-94c1-46ff-77da-7d50a886d100/public)\n\n## Reference\n\n- [Generating a new GPG key](https://docs.github.com/en/authentication/managing-commit-signature-verification/generating-a-new-gpg-key)\n- [Adding a new GPG key to your GitHub account](https://docs.github.com/en/authentication/managing-commit-signature-verification/adding-a-new-gpg-key-to-your-github-account)\n- [GnuPG](https://www.gnupg.org/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Git/github gpg.md","excerpt":"最近常常會看到別入 GitHub 上的 Commit 會有 Verified 的字樣，查了才知道這是為了防止有人盜用你的 email 簽 commit，畢竟 git 的 user.email 是可以自己隨便設的，所以 GitHub 就提供一個可以用公私鑰的方式來確認身份。 img GnuPG 我們要利用 GnuPG 來產生金鑰和簽署 Commit，當然要先安裝他，可以自己查一下自己的 OS 要怎…","frontmatter":{"title":"GitHub GPG - Verified Commit","date":"2022-03-24T14:32:19.000Z","draft":false,"tags":["git","github","gpg","verified","commit"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/eb2adedc-6625-46d1-73ea-07c01fc92000/public","description":"最近常常會看到別入 GitHub 上的 Commit 會有 Verified 的字樣，查了才知道這是為了防止有人盜用你的 email 簽 commit，畢竟 git 的 user.email 是可以自己隨便設的，所以 GitHub 就提供一個可以用公私鑰的方式來確認身份。"}}},{"node":{"id":"8e495473-8d57-530c-bb3f-4262fce2dde7","html":"<p>說到搜尋的解決方案，最有名的大概就是 <a href=\"https://www.algolia.com/\">Algolia</a>，可以方便的創建索引，也有很多寫好的前端網頁元件可以使用，唯一的缺點就是收費。雖然 Algolia 要收費，但其實對於我這個小網頁都索引量是完全不用錢的，但是就還是覺得自己架一個索引系統比較有感覺，然後我就在 GitHub 上發現了開源的 <a href=\"https://meilisearch.com\">MeiliSearch</a>，功能基本上跟 Algolia 很像，也支援中文，甚至有些前端元件可以直接使用 Algolia 的，缺點就是要自己架設 Server。</p>\n<!--more-->\n<p>本文以搜尋本站為目的撰寫，所以後面的範例大多與 Hugo 相關，如果想要看完整的程式碼，可以直接到本站的 GitHub。</p>\n<h2>簡介 MeiliSearch Server</h2>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f93885e8-f670-44ec-ea24-264a97c9a500/public\" alt=\"img\"></p>\n<p>基本上 MeiliSearch 就是一個 RESTful API，目標是要提供現成的搜尋解決方案，完全開源，提供即時搜尋、拼寫錯誤、同義詞、模糊搜尋、自訂排名、排序和多語言搜尋的支援，連中文也不例外。根據官方文件的介紹，MeiliSearch 以易用性為首要目標，對於開發者，只需要少少幾行 code 就可以使用；對於使用者，提供直觀的即時輸入即時反應的搜尋結果。</p>\n<p>官方也有很多的 SDK，.NET, Dart, Go, Java, JS, Python, Swift，而且上面這些還不是全部，所以在開發各語言的應用程式時，都可以考慮用 MeiliSearch 做為後端搜尋引擎。</p>\n<p>MeiliSearch 也不是完全沒有缺點，缺點就是要自己有伺服器，像是本文今天的案例就是要幫 Static Site 做搜尋的功能，通常 Static Site 大家應該都是用 GitHub Pages 等 Statice Site Hosting 服務，所以網頁本身是沒有自己架 Server 的，為了加個搜尋功能會要多一個 Server 就是很大的缺點。</p>\n<h2>SearchIndex.json</h2>\n<p>在開始使用 MeiliSearch 之前，我們先來把要索引的資料準備好，MeiliSearch 會需要使用 json 當作索引，所以我們要產生一個 json 的範本。創建 <code class=\"language-text\">/layouts/list.searchindex.json</code>，內容如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[ {{- $i := 0 -}}\n    {{- range where .Site.RegularPages \"Section\" \"ne\" \"\" -}}\n       {{- if not .Params.noSearch -}}\n          {{- if gt $i 0 }},{{ end -}}\n          {\"id\":{{ $i }}, \"date\":\"{{ .Date.Unix }}\", \"url\":\"{{ .Permalink }}\", \"title\":{{ .Title | jsonify  }}, \"summary\":{{ with .Description}}{{ . | plainify | jsonify }}{{ else }}{{ .Summary | plainify | jsonify }}{{ end }}, \"content\":{{ .Content | plainify | jsonify }},\"tags\":[ {{- $t := 0 }}{{- range .Param \"tags\" -}}{{ if gt $t 0 }},{{ end }}{{ . | jsonify }}{{ $t = add $t 1 }}{{ end -}} ], \"section\": {{ .Section | jsonify -}} }\n        {{- $i = add $i 1 -}}\n    {{- end -}}\n{{- end -}} ]</code></pre></div>\n<p>然後在 <code class=\"language-text\">config.yaml</code> 中加入下面的設定值：</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">outputFormats</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">SearchIndex</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">mediaType</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"application/json\"</span>\n    <span class=\"token key atrule\">baseName</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"searchindex\"</span>\n    <span class=\"token key atrule\">isPlainText</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n    <span class=\"token key atrule\">notAlternative</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n<span class=\"token key atrule\">outputs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">home</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"HTML\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"RSS\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"SearchIndex\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>完成上面兩樣設定後，可以 <code class=\"language-text\">hugo</code> 一下試試看，有沒有在 <code class=\"language-text\">/public/searchindex.json</code> 中看到索引檔案，應該會類似如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"date\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1622891718\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://tonypepe.com/posts/others/hello-world/\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"summary\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Hello World. This is a test post.\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"content\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"This is my first post in hugo\\ncontent\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"tags\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"hugo\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"test\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"section\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"posts\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<h2>架設 MeiliSearch Server</h2>\n<p>準備好索引檔案後，我們就來架設 MeiliSearch 的 Server，MeiliSearch 是用 Rust 編寫，所以也是跨平台通用。官方提供很多種安裝方式，還有一鍵啟動腳本，當然，為了避免弄髒環境，最推薦的當然還是 Docker，下面就先以 Docker 為範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -it --rm <span class=\"token punctuation\">\\</span>\n    -p <span class=\"token number\">7700</span>:7700 <span class=\"token punctuation\">\\</span>\n    -v <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>/data.ms:/data.ms <span class=\"token punctuation\">\\</span>\n    getmeili/meilisearch:latest</code></pre></div>\n<p>注意一下，上面掛載了一個 <code class=\"language-text\">data.ms</code> 的資料夾，所以在執行上面的指令前，記得先創建好。<code class=\"language-text\">data.ms</code> 這個資料夾是為了存放索引資料，避免因為 Docker 容器重啟就損失資料，所以很重要。</p>\n<p>現在可以到 <a href=\"http://localhost:7700\">http://localhost:7700</a>，會看到有一個簡易的 WEB UI。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/5664dc51-5d55-415a-3633-ac45e17d7a00/public\" alt=\"img\"></p>\n<p>如果不想用 Docker，還是可以參考官方文件的其他安裝方式安裝。</p>\n<h2>提交索引資料</h2>\n<p>前面有提到 MeiliSearch 是 RESTful API，所以要向他搜尋或是提供資料，都是用 HTTP Method。官方文件寫的都是 curl，我們還是使用 GUI 的方式介紹。HTTP 的 GUI 大家應該都會想到 Postman，但今天我們要使用他的開源替代 <a href=\"https://hoppspot.io\">Hoppsotch</a>，他是一個網頁工具，所以不需要安裝。</p>\n<p>可以先對 <code class=\"language-text\">/health</code> 做 <code class=\"language-text\">GET</code> 試試看有沒有連上，如果沒有連上，可能要檢查一下有沒有成功啟動 MeiliSearch Server。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/cf86e106-a1f6-472e-d2c1-a6b186944f00/public\" alt=\"img\"></p>\n<p>確定連上後，我們就來提交索引資料，如果還沒有 Hugo 產生的索引資料，可以先到本站的 GitHub，拿本站的 <a href=\"https://github.com/TonyPepeBear/HugoBlog/blob/1bfae9859a44338d24a9f6676be37f72cc983505/searchindex.json\">searchindex.json</a> 做測試。</p>\n<p>因為 MeiliSearch 也可以同時有多個 Indexes 做搜尋，我們下面的範例以 <code class=\"language-text\">hugo_blog</code> 作為範例名稱，大家可以根據需求自己決定使用的名稱。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/71797a57-6f97-44cd-f4dc-675ec42ffd00/public\" alt=\"img\"></p>\n<p>可以看到上圖對 <code class=\"language-text\">/indexes/&lt;&lt;IndexName>>/documents</code> 做 <code class=\"language-text\">POST</code> 方法，就可以把索引資料提交到 MeiliSearch Server。記得內容類型是 <code class=\"language-text\">application/json</code>，然後把索引資料放到 body。</p>\n<p>現在回到 <a href=\"http://localhost:7700\">localhost:7700</a>，應該就可以看到原本空空如也的 WEB UI 現在可以做搜尋了，可以先在這裡做一些簡單的搜尋，試試看自己的索引資料有沒有被成功的使用。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c58970b0-53b5-4a16-50bb-ff40fa6fde00/public\" alt=\"img\"></p>\n<h2>MeiliSearch in Production</h2>\n<p>MeiliSearch 預設的啟動方式其實是 <code class=\"language-text\">development</code>，這模式只是方便本地做測試使用的，如果要使用在生產環境，應該要以 <code class=\"language-text\">production</code> 模式啟動。在 Production 模式下，會有兩個不一樣的地方，第一項是 Web UI 會被停用，第二項是會必須要設定 <code class=\"language-text\">Master Key</code>，下面還是用 Docker 作為範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -it --rm <span class=\"token punctuation\">\\</span>\n    -p <span class=\"token number\">7700</span>:7700 <span class=\"token punctuation\">\\</span>\n    -v <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>/data.ms:/data.ms <span class=\"token punctuation\">\\</span>\n    -e <span class=\"token assign-left variable\">MEILI_ENV</span><span class=\"token operator\">=</span>production <span class=\"token punctuation\">\\</span>\n    -e <span class=\"token assign-left variable\">MEILI_MASTER_KEY</span><span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>Your Master Key<span class=\"token operator\">></span> <span class=\"token punctuation\">\\</span>\n    getmeili/meilisearch:latest</code></pre></div>\n<p>上面設定的 Master Key，就是管理權限最大的 API Key，所以要記得妥善保存。</p>\n<p>下面用剛剛的 Master Key 去對 <code class=\"language-text\">/keys</code> 做 <code class=\"language-text\">GET</code>，然後在 Headers 中，加上剛剛的 Master Key，就可以拿到預設的搜尋 KEY，和預設的 ADMIN KEY。如果要再另外新增 API KEY，可以參考官方的文件，這裡就不多著墨。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/91af11f7-29fc-446b-7ae1-dcb47f82b900/public\" alt=\"img\"></p>\n<h2>為網頁加上搜尋功能</h2>\n<p>我們會用到 MeiliSearch 提供的 <a href=\"https://github.com/meilisearch/instant-meilisearch\">Instant MeiliSearch</a>，這個 JS 庫就是使用 Algolia 的 Instant Search 改的，所以有些文件可以直接去看 Algolia 的官方文件。Instant MeiliSearch 最簡單的使用方式也是直接用 CDN 的方式，下面是一個最簡單的模板，看懂後用類似的邏輯加到自己的網頁中就好。</p>\n<p>html:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">DOCTYPE</span> <span class=\"token name\">html</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span> <span class=\"token attr-name\">charset</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>utf-8<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span>\n\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>searchbox<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>hits<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://cdn.jsdelivr.net/npm/@meilisearch/instant-meilisearch/dist/instant-meilisearch.umd.min.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://cdn.jsdelivr.net/npm/instantsearch.js@4<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>./app.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>下面是剛剛的 html 會用到的 <code class=\"language-text\">app.js</code>，用來作為 Search 的設定值，只要把下面的網址設定成自己的網址，和自己在前幾步驟拿到的搜尋 API KEY 就可以使用了：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> search <span class=\"token operator\">=</span> <span class=\"token function\">instantsearch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">indexName</span><span class=\"token operator\">:</span> <span class=\"token string\">\"steam-video-games\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">searchClient</span><span class=\"token operator\">:</span> <span class=\"token function\">instantMeiliSearch</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"https://integration-demos.meilisearch.com\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"q7QHwGiX841a509c8b05ef29e55f2d94c02c00635f729ccf097a734cbdf7961530f47c47\"</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsearch<span class=\"token punctuation\">.</span><span class=\"token function\">addWidgets</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  instantsearch<span class=\"token punctuation\">.</span>widgets<span class=\"token punctuation\">.</span><span class=\"token function\">searchBox</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">container</span><span class=\"token operator\">:</span> <span class=\"token string\">\"#searchbox\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  instantsearch<span class=\"token punctuation\">.</span>widgets<span class=\"token punctuation\">.</span><span class=\"token function\">hits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">container</span><span class=\"token operator\">:</span> <span class=\"token string\">\"#hits\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">templates</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">item</span><span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n        &lt;div>\n          &lt;div class=\"hit-name\">\n            {{#helpers.highlight}}{ \"attribute\": \"name\" }{{/helpers.highlight}}\n          &lt;/div>\n        &lt;/div>\n      </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nsearch<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>如果覺得他預設提供的 UI 很醜，可以用 CSS 的方式去改他。</p>\n<h2>GitHub Actions 自動提交索引</h2>\n<p>不廢話，直接上本站的 yml:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> MeiliSearch Index\n\n<span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> master <span class=\"token comment\"># Set a branch to deploy</span>\n\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span><span class=\"token number\">20.04</span>\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">submodules</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span> <span class=\"token comment\"># Fetch Hugo themes (true OR recursive)</span>\n          <span class=\"token key atrule\">fetch-depth</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token comment\"># Fetch all history for .GitInfo and .Lastmod</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Node\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/setup<span class=\"token punctuation\">-</span>node@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">node-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"14\"</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Hugo\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>hugo@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">hugo-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"latest\"</span>\n          <span class=\"token key atrule\">extended</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          npm i\n          hugo --minify</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Post Index\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          curl \\\n            -X POST \"https://search.tonypepe.com/indexes/hugo_blog/documents\" \\\n            -H 'Authorization: Bearer ${{ secrets.MEILISEARCH_KEY }}' \\\n            -H 'Content-Type: application/json' \\\n            --data-binary \"@public/searchindex.json\"</span></code></pre></div>\n<p>其實重點就是在最後一步，把索引檔案 POST 到 MeiliSearch 就可以了。</p>\n<h2>Referenc</h2>\n<ul>\n<li><a href=\"https://meilisearch.com\">MeiliSearch</a></li>\n<li><a href=\"https://discourse.gohugo.io/t/a-simple-javascript-based-full-text-search-function/29119\">A simple javascript based full text search function</a></li>\n<li><a href=\"https://hoppspot.io\">Hoppsotch</a></li>\n<li><a href=\"https://github.com/meilisearch/instant-meilisearch\">Instant MeiliSearch</a></li>\n</ul>","rawMarkdownBody":"\n說到搜尋的解決方案，最有名的大概就是 [Algolia](https://www.algolia.com/)，可以方便的創建索引，也有很多寫好的前端網頁元件可以使用，唯一的缺點就是收費。雖然 Algolia 要收費，但其實對於我這個小網頁都索引量是完全不用錢的，但是就還是覺得自己架一個索引系統比較有感覺，然後我就在 GitHub 上發現了開源的 [MeiliSearch](https://meilisearch.com)，功能基本上跟 Algolia 很像，也支援中文，甚至有些前端元件可以直接使用 Algolia 的，缺點就是要自己架設 Server。\n\n<!--more-->\n\n本文以搜尋本站為目的撰寫，所以後面的範例大多與 Hugo 相關，如果想要看完整的程式碼，可以直接到本站的 GitHub。\n\n## 簡介 MeiliSearch Server\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f93885e8-f670-44ec-ea24-264a97c9a500/public)\n\n基本上 MeiliSearch 就是一個 RESTful API，目標是要提供現成的搜尋解決方案，完全開源，提供即時搜尋、拼寫錯誤、同義詞、模糊搜尋、自訂排名、排序和多語言搜尋的支援，連中文也不例外。根據官方文件的介紹，MeiliSearch 以易用性為首要目標，對於開發者，只需要少少幾行 code 就可以使用；對於使用者，提供直觀的即時輸入即時反應的搜尋結果。\n\n官方也有很多的 SDK，.NET, Dart, Go, Java, JS, Python, Swift，而且上面這些還不是全部，所以在開發各語言的應用程式時，都可以考慮用 MeiliSearch 做為後端搜尋引擎。\n\nMeiliSearch 也不是完全沒有缺點，缺點就是要自己有伺服器，像是本文今天的案例就是要幫 Static Site 做搜尋的功能，通常 Static Site 大家應該都是用 GitHub Pages 等 Statice Site Hosting 服務，所以網頁本身是沒有自己架 Server 的，為了加個搜尋功能會要多一個 Server 就是很大的缺點。\n\n## SearchIndex.json\n\n在開始使用 MeiliSearch 之前，我們先來把要索引的資料準備好，MeiliSearch 會需要使用 json 當作索引，所以我們要產生一個 json 的範本。創建 `/layouts/list.searchindex.json`，內容如下：\n\n```text\n[ {{- $i := 0 -}}\n    {{- range where .Site.RegularPages \"Section\" \"ne\" \"\" -}}\n       {{- if not .Params.noSearch -}}\n          {{- if gt $i 0 }},{{ end -}}\n          {\"id\":{{ $i }}, \"date\":\"{{ .Date.Unix }}\", \"url\":\"{{ .Permalink }}\", \"title\":{{ .Title | jsonify  }}, \"summary\":{{ with .Description}}{{ . | plainify | jsonify }}{{ else }}{{ .Summary | plainify | jsonify }}{{ end }}, \"content\":{{ .Content | plainify | jsonify }},\"tags\":[ {{- $t := 0 }}{{- range .Param \"tags\" -}}{{ if gt $t 0 }},{{ end }}{{ . | jsonify }}{{ $t = add $t 1 }}{{ end -}} ], \"section\": {{ .Section | jsonify -}} }\n        {{- $i = add $i 1 -}}\n    {{- end -}}\n{{- end -}} ]\n```\n\n然後在 `config.yaml` 中加入下面的設定值：\n\n```yaml\noutputFormats:\n  SearchIndex:\n    mediaType: \"application/json\"\n    baseName: \"searchindex\"\n    isPlainText: true\n    notAlternative: true\noutputs:\n  home: [\"HTML\", \"RSS\", \"SearchIndex\"]\n```\n\n完成上面兩樣設定後，可以 `hugo` 一下試試看，有沒有在 `/public/searchindex.json` 中看到索引檔案，應該會類似如下：\n\n```json\n[\n  {\n    \"id\": 0,\n    \"date\": \"1622891718\",\n    \"url\": \"https://tonypepe.com/posts/others/hello-world/\",\n    \"title\": \"Hello World\",\n    \"summary\": \"Hello World. This is a test post.\",\n    \"content\": \"This is my first post in hugo\\ncontent\",\n    \"tags\": [\"hugo\", \"test\"],\n    \"section\": \"posts\"\n  }\n]\n```\n\n## 架設 MeiliSearch Server\n\n準備好索引檔案後，我們就來架設 MeiliSearch 的 Server，MeiliSearch 是用 Rust 編寫，所以也是跨平台通用。官方提供很多種安裝方式，還有一鍵啟動腳本，當然，為了避免弄髒環境，最推薦的當然還是 Docker，下面就先以 Docker 為範例：\n\n```bash\ndocker run -it --rm \\\n    -p 7700:7700 \\\n    -v $(pwd)/data.ms:/data.ms \\\n    getmeili/meilisearch:latest\n```\n\n注意一下，上面掛載了一個 `data.ms` 的資料夾，所以在執行上面的指令前，記得先創建好。`data.ms` 這個資料夾是為了存放索引資料，避免因為 Docker 容器重啟就損失資料，所以很重要。\n\n現在可以到 [http://localhost:7700](http://localhost:7700)，會看到有一個簡易的 WEB UI。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/5664dc51-5d55-415a-3633-ac45e17d7a00/public)\n\n如果不想用 Docker，還是可以參考官方文件的其他安裝方式安裝。\n\n## 提交索引資料\n\n前面有提到 MeiliSearch 是 RESTful API，所以要向他搜尋或是提供資料，都是用 HTTP Method。官方文件寫的都是 curl，我們還是使用 GUI 的方式介紹。HTTP 的 GUI 大家應該都會想到 Postman，但今天我們要使用他的開源替代 [Hoppsotch](https://hoppspot.io)，他是一個網頁工具，所以不需要安裝。\n\n可以先對 `/health` 做 `GET` 試試看有沒有連上，如果沒有連上，可能要檢查一下有沒有成功啟動 MeiliSearch Server。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/cf86e106-a1f6-472e-d2c1-a6b186944f00/public)\n\n確定連上後，我們就來提交索引資料，如果還沒有 Hugo 產生的索引資料，可以先到本站的 GitHub，拿本站的 [searchindex.json](https://github.com/TonyPepeBear/HugoBlog/blob/1bfae9859a44338d24a9f6676be37f72cc983505/searchindex.json) 做測試。\n\n因為 MeiliSearch 也可以同時有多個 Indexes 做搜尋，我們下面的範例以 `hugo_blog` 作為範例名稱，大家可以根據需求自己決定使用的名稱。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/71797a57-6f97-44cd-f4dc-675ec42ffd00/public)\n\n可以看到上圖對 `/indexes/<<IndexName>>/documents` 做 `POST` 方法，就可以把索引資料提交到 MeiliSearch Server。記得內容類型是 `application/json`，然後把索引資料放到 body。\n\n現在回到 [localhost:7700](http://localhost:7700)，應該就可以看到原本空空如也的 WEB UI 現在可以做搜尋了，可以先在這裡做一些簡單的搜尋，試試看自己的索引資料有沒有被成功的使用。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c58970b0-53b5-4a16-50bb-ff40fa6fde00/public)\n\n## MeiliSearch in Production\n\nMeiliSearch 預設的啟動方式其實是 `development`，這模式只是方便本地做測試使用的，如果要使用在生產環境，應該要以 `production` 模式啟動。在 Production 模式下，會有兩個不一樣的地方，第一項是 Web UI 會被停用，第二項是會必須要設定 `Master Key`，下面還是用 Docker 作為範例：\n\n```bash\ndocker run -it --rm \\\n    -p 7700:7700 \\\n    -v $(pwd)/data.ms:/data.ms \\\n    -e MEILI_ENV=production \\\n    -e MEILI_MASTER_KEY=<Your Master Key> \\\n    getmeili/meilisearch:latest\n```\n\n上面設定的 Master Key，就是管理權限最大的 API Key，所以要記得妥善保存。\n\n下面用剛剛的 Master Key 去對 `/keys` 做 `GET`，然後在 Headers 中，加上剛剛的 Master Key，就可以拿到預設的搜尋 KEY，和預設的 ADMIN KEY。如果要再另外新增 API KEY，可以參考官方的文件，這裡就不多著墨。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/91af11f7-29fc-446b-7ae1-dcb47f82b900/public)\n\n## 為網頁加上搜尋功能\n\n我們會用到 MeiliSearch 提供的 [Instant MeiliSearch](https://github.com/meilisearch/instant-meilisearch)，這個 JS 庫就是使用 Algolia 的 Instant Search 改的，所以有些文件可以直接去看 Algolia 的官方文件。Instant MeiliSearch 最簡單的使用方式也是直接用 CDN 的方式，下面是一個最簡單的模板，看懂後用類似的邏輯加到自己的網頁中就好。\n\nhtml:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n  </head>\n\n  <body>\n    <div>\n      <div id=\"searchbox\"></div>\n      <div id=\"hits\"></div>\n    </div>\n\n    <script src=\"https://cdn.jsdelivr.net/npm/@meilisearch/instant-meilisearch/dist/instant-meilisearch.umd.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/instantsearch.js@4\"></script>\n    <script src=\"./app.js\"></script>\n  </body>\n</html>\n```\n\n下面是剛剛的 html 會用到的 `app.js`，用來作為 Search 的設定值，只要把下面的網址設定成自己的網址，和自己在前幾步驟拿到的搜尋 API KEY 就可以使用了：\n\n```js\nconst search = instantsearch({\n  indexName: \"steam-video-games\",\n  searchClient: instantMeiliSearch(\n    \"https://integration-demos.meilisearch.com\",\n    \"q7QHwGiX841a509c8b05ef29e55f2d94c02c00635f729ccf097a734cbdf7961530f47c47\"\n  ),\n});\n\nsearch.addWidgets([\n  instantsearch.widgets.searchBox({\n    container: \"#searchbox\",\n  }),\n  instantsearch.widgets.hits({\n    container: \"#hits\",\n    templates: {\n      item: `\n        <div>\n          <div class=\"hit-name\">\n            {{#helpers.highlight}}{ \"attribute\": \"name\" }{{/helpers.highlight}}\n          </div>\n        </div>\n      `,\n    },\n  }),\n]);\n\nsearch.start();\n```\n\n如果覺得他預設提供的 UI 很醜，可以用 CSS 的方式去改他。\n\n## GitHub Actions 自動提交索引\n\n不廢話，直接上本站的 yml:\n\n```yml\nname: MeiliSearch Index\n\non:\n  push:\n    branches:\n      - master # Set a branch to deploy\n\njobs:\n  deploy:\n    runs-on: ubuntu-20.04\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          submodules: true # Fetch Hugo themes (true OR recursive)\n          fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod\n\n      - name: Setup Node\n        uses: actions/setup-node@v2\n        with:\n          node-version: \"14\"\n\n      - name: Setup Hugo\n        uses: peaceiris/actions-hugo@v2\n        with:\n          hugo-version: \"latest\"\n          extended: true\n\n      - name: Build\n        run: |\n          npm i\n          hugo --minify\n\n      - name: Post Index\n        run: |\n          curl \\\n            -X POST \"https://search.tonypepe.com/indexes/hugo_blog/documents\" \\\n            -H 'Authorization: Bearer ${{ secrets.MEILISEARCH_KEY }}' \\\n            -H 'Content-Type: application/json' \\\n            --data-binary \"@public/searchindex.json\"\n```\n\n其實重點就是在最後一步，把索引檔案 POST 到 MeiliSearch 就可以了。\n\n## Referenc\n\n- [MeiliSearch](https://meilisearch.com)\n- [A simple javascript based full text search function](https://discourse.gohugo.io/t/a-simple-javascript-based-full-text-search-function/29119)\n- [Hoppsotch](https://hoppspot.io)\n- [Instant MeiliSearch](https://github.com/meilisearch/instant-meilisearch)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/MeiliSearch-hugo.md","excerpt":"說到搜尋的解決方案，最有名的大概就是 Algolia，可以方便的創建索引，也有很多寫好的前端網頁元件可以使用，唯一的缺點就是收費。雖然 Algolia 要收費，但其實對於我這個小網頁都索引量是完全不用錢的，但是就還是覺得自己架一個索引系統比較有感覺，然後我就在 GitHub 上發現了開源的 MeiliSearch，功能基本上跟 Algolia 很像，也支援中文，甚至有些前端元件可以直接使用 Al…","frontmatter":{"title":"MeiliSearch with Hugo","date":"2022-01-17T17:40:09.000Z","draft":false,"tags":["meilisearch","search","web","hugo","github","actions"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f9f8be53-5393-4190-b6da-baf27d8a7500/public","description":null}}},{"node":{"id":"7344f3d5-18b8-56c7-8a29-887c8c755a3a","html":"<p>GitHub 上有許許多多開源的 icon，但是每個用法不盡相同，甚至大部分的使用方式，都是直接下載 SVG 使用。雖然使用 SVG 也不是不好，但是就會需要自己多一步驟的使用。Iconify 把許多 icon 整合在一起，並且提供非常簡單的辦法，就可以讓網頁有很精美的 icon。</p>\n<!--more-->\n<h2>使用 Iconify</h2>\n<p>使用 Iconify 只需要先在 HTML 中引入 Iconify 的 Script：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://code.iconify.design/2/2.1.0/iconify.min.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>接下來只需要在要使用 icon 的地方，新增一個 span，其中要有包含 <code class=\"language-text\">class=\"iconify\"</code> 和 <code class=\"language-text\">data-icon</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>span</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>iconify<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">data-icon</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>fa:home<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>span</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>正確使用後，應該就可以在網頁中正確的顯示下面的 icon：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f0141e02-3e26-415d-1ee2-438dc4d43600/public\" alt=\"img\"></p>\n<h2>搜尋 Icon</h2>\n<p>就像前面說的，Iconify 提供非常多的 icon，所以作者也有寫一個可以搜尋圖標的地方，而且搜尋到圖標後，還提供許多可以協助客製化圖標的方法：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/44c38b28-baa8-4faa-6d06-8e2615f19500/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c330c161-f8b4-41d2-db15-b02079185b00/public\" alt=\"\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f0141e02-3e26-415d-1ee2-438dc4d43600/public\" alt=\"img\"></p>\n<p>如果真的不想使用 Iconify 的方式顯示圖標，也可以單純的當作圖標蒐尋器，搜尋到之後直接下載 SVG 使用即可。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://iconify.design/\">Iconify</a></li>\n</ul>","rawMarkdownBody":"\nGitHub 上有許許多多開源的 icon，但是每個用法不盡相同，甚至大部分的使用方式，都是直接下載 SVG 使用。雖然使用 SVG 也不是不好，但是就會需要自己多一步驟的使用。Iconify 把許多 icon 整合在一起，並且提供非常簡單的辦法，就可以讓網頁有很精美的 icon。\n\n<!--more-->\n\n## 使用 Iconify\n\n使用 Iconify 只需要先在 HTML 中引入 Iconify 的 Script：\n\n```html\n<script src=\"https://code.iconify.design/2/2.1.0/iconify.min.js\"></script>\n```\n\n接下來只需要在要使用 icon 的地方，新增一個 span，其中要有包含 `class=\"iconify\"` 和 `data-icon`：\n\n```html\n<span class=\"iconify\" data-icon=\"fa:home\"></span>\n```\n\n正確使用後，應該就可以在網頁中正確的顯示下面的 icon：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f0141e02-3e26-415d-1ee2-438dc4d43600/public)\n\n## 搜尋 Icon\n\n就像前面說的，Iconify 提供非常多的 icon，所以作者也有寫一個可以搜尋圖標的地方，而且搜尋到圖標後，還提供許多可以協助客製化圖標的方法：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/44c38b28-baa8-4faa-6d06-8e2615f19500/public)\n\n![](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c330c161-f8b4-41d2-db15-b02079185b00/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f0141e02-3e26-415d-1ee2-438dc4d43600/public)\n\n如果真的不想使用 Iconify 的方式顯示圖標，也可以單純的當作圖標蒐尋器，搜尋到之後直接下載 SVG 使用即可。\n\n## Reference\n\n- [Iconify](https://iconify.design/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/iconify.md","excerpt":"GitHub 上有許許多多開源的 icon，但是每個用法不盡相同，甚至大部分的使用方式，都是直接下載 SVG 使用。雖然使用 SVG 也不是不好，但是就會需要自己多一步驟的使用。Iconify 把許多 icon 整合在一起，並且提供非常簡單的辦法，就可以讓網頁有很精美的 icon。 使用 Iconify 使用 Iconify 只需要先在 HTML 中引入 Iconify 的 Script： 接下…","frontmatter":{"title":"Iconify -- icon 大禮包","date":"2022-01-14T13:48:25.000Z","draft":false,"tags":["icon","web","ios","android","design"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/ca9b8ae2-b684-421a-a662-2dd4356ce600/public","description":null}}},{"node":{"id":"9c3da1a2-833a-52a8-9d4e-e9194f199199","html":"<p>Telegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。</p>\n<!--more-->\n<h2>新增自己的 Bot</h2>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/fbf36cb0-84f4-4f7a-2553-04ecccf44800/public\" alt=\"image\"></p>\n<p>Telegram 非常有趣，要新增自己的 Bot，只要跟 Telegram 上的 <a href=\"https://telegram.me/BotFather\">BotFather</a> <code class=\"language-text\">說一下</code>，他就會給你一個 Bot。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9200bc38-828c-4ad4-a022-d34c3a692d00/public\" alt=\"image\"></p>\n<p>按 BotFather 給你的步驟做，最後可以看到他會提供一個 API Token 給你，只要有這個 Token 就可以跟 Bot 溝通，要保存好，等等會用到，也不要給別人看到，以免自己的 Bot 變成別人的玩具。</p>\n<h2>go-telegram-bot-api</h2>\n<p>Go 已經有社區開發的函式庫可以用 <a href=\"https://github.com/go-telegram-bot-api/telegram-bot-api\">telegram-bot-api</a>。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">go get -u github.com/go-telegram-bot-api/telegram-bot-api/v5\n</code></pre></div>\n<p>之後只要 import 就可以使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    tgbotapi <span class=\"token string\">\"github.com/go-telegram-bot-api/telegram-bot-api/v5\"</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<h2>連線到 Telegram Bot</h2>\n<p>利用剛剛 import 的函式庫，只需要剛剛創建好的 Bot 的 API Token 就可以連線到 Telegram。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">bot<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewBotAPI</span><span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span><span class=\"token function\">Getenv</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TELEGRAM_API_TOKEN\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面用環境變數的方式來取得 TOKEN，避免需要直接寫在程式碼裡，如果覺得在測試時設定環境變數很麻煩，可以用 JetBrains 的 <a href=\"https://www.jetbrains.com/go/\">GoLand</a>，設定 Runtime 的環境變數：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9af5d8a5-3504-479d-ab04-f8b0adf93500/public\" alt=\"image\"></p>\n<h2>處理 Update</h2>\n<p>要接收使用者傳過來的訊息，Telegram API 稱為 Update，我們使用的函示庫基本上都自動處理好了，只需要接收一個 Channel 就好。使用 <code class=\"language-text\">bot.GetUpdatesChan(config)</code> 會需要給一個 Config，這可以用 <code class=\"language-text\">tgbotapi.NewUpdate(0)</code> 來生，然後這邊設定 Timeout 為 60，如果對這個設定值有興趣，可以去看 Telegram 的文件。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">updateConfig <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewUpdate</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\nupdateConfig<span class=\"token punctuation\">.</span>Timeout <span class=\"token operator\">=</span> <span class=\"token number\">60</span>\nupdates <span class=\"token operator\">:=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">GetUpdatesChan</span><span class=\"token punctuation\">(</span>updateConfig<span class=\"token punctuation\">)</span></code></pre></div>\n<h2>回復</h2>\n<p>我們先簡單寫一隻鸚鵡，把用戶傳過來的 Text，直接傳回去。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/19bbc73e-3090-4a0d-0eec-d65671c01900/public\" alt=\"image\"></p>\n<p>用 for 把 Channel 中的 Update 一個一個拿出來，然後用 <code class=\"language-text\">tgbotapi</code> 產生一個 Message 物件，裡面放在聊天室的 ID 和要回傳的 Text，最後用 bot 把 Message 傳回去。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> update <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> updates <span class=\"token punctuation\">{</span>\n    text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n    chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n    replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n    <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>簡單鸚鵡的完整程式碼</h2>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n    tgbotapi <span class=\"token string\">\"github.com/go-telegram-bot-api/telegram-bot-api/v5\"</span>\n    <span class=\"token string\">\"os\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    bot<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewBotAPI</span><span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span><span class=\"token function\">Getenv</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TELEGRAM_API_TOKEN\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    bot<span class=\"token punctuation\">.</span>Debug <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    updateConfig <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewUpdate</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    updateConfig<span class=\"token punctuation\">.</span>Timeout <span class=\"token operator\">=</span> <span class=\"token number\">60</span>\n    updates <span class=\"token operator\">:=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">GetUpdatesChan</span><span class=\"token punctuation\">(</span>updateConfig<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> update <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> updates <span class=\"token punctuation\">{</span>\n        text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n        chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n        replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n        <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>改寫成非阻塞的 Goroutine</h2>\n<p>因為每次處理和回復都會需要一點時間，甚至是要去 DB 找資料，如果用上面的寫法，在處理多人或高速傳訊息的時候會被卡住，一次只能處理的一個訊息。還好 Go 的併發寫法非常簡單，只要放一個 go 在前面，就可以非阻塞的執行 function 中的內容。</p>\n<p>我們先把 <code class=\"language-text\">handleUpdate</code> 提取成一個 function，然後再用 go 去執行他：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    bot<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewBotAPI</span><span class=\"token punctuation\">(</span>os<span class=\"token punctuation\">.</span><span class=\"token function\">Getenv</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"TELEGRAM_API_TOKEN\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">panic</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    bot<span class=\"token punctuation\">.</span>Debug <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    updateConfig <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewUpdate</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    updateConfig<span class=\"token punctuation\">.</span>Timeout <span class=\"token operator\">=</span> <span class=\"token number\">60</span>\n    updates <span class=\"token operator\">:=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">GetUpdatesChan</span><span class=\"token punctuation\">(</span>updateConfig<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> update <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> updates <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">go</span> <span class=\"token function\">handleUpdate</span><span class=\"token punctuation\">(</span>bot<span class=\"token punctuation\">,</span> update<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">handleUpdate</span><span class=\"token punctuation\">(</span>bot <span class=\"token operator\">*</span>tgbotapi<span class=\"token punctuation\">.</span>BotAPI<span class=\"token punctuation\">,</span> update tgbotapi<span class=\"token punctuation\">.</span>Update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n    chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n    replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n    <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>回復特定訊息</h2>\n<p>要回復 <code class=\"language-text\">回復訊息</code> ，像是下面的效果也很簡單：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/22010000-e325-45e6-52f9-64eec6b28500/public\" alt=\"image\"></p>\n<p>只需要設定 <code class=\"language-text\">replyMsg.ReplyToMessageID</code> 就可以回復特定的訊息，下面就是直接回覆接收到的訊息：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">handleUpdate</span><span class=\"token punctuation\">(</span>bot <span class=\"token operator\">*</span>tgbotapi<span class=\"token punctuation\">.</span>BotAPI<span class=\"token punctuation\">,</span> update tgbotapi<span class=\"token punctuation\">.</span>Update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n    chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n    replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n    replyMsg<span class=\"token punctuation\">.</span>ReplyToMessageID <span class=\"token operator\">=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>MessageID\n    <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>處理 Command</h2>\n<p>Telegram 中，用 <code class=\"language-text\">/</code> 開頭的文字就是 Command，這個函示庫也有寫好處理 Command 的方法，只需要用 <code class=\"language-text\">isCommand()</code>，確認一下是不是 Command 就可以：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">handleUpdate</span><span class=\"token punctuation\">(</span>bot <span class=\"token operator\">*</span>tgbotapi<span class=\"token punctuation\">.</span>BotAPI<span class=\"token punctuation\">,</span> update tgbotapi<span class=\"token punctuation\">.</span>Update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    text <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Text\n    chatID <span class=\"token operator\">:=</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>Chat<span class=\"token punctuation\">.</span>ID\n    replyMsg <span class=\"token operator\">:=</span> tgbotapi<span class=\"token punctuation\">.</span><span class=\"token function\">NewMessage</span><span class=\"token punctuation\">(</span>chatID<span class=\"token punctuation\">,</span> text<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span><span class=\"token function\">IsCommand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">switch</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span><span class=\"token function\">Command</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> <span class=\"token string\">\"start\"</span><span class=\"token punctuation\">:</span>\n            replyMsg<span class=\"token punctuation\">.</span>Text <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello \"</span> <span class=\"token operator\">+</span> update<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">.</span>From<span class=\"token punctuation\">.</span>FirstName\n        <span class=\"token keyword\">case</span> <span class=\"token string\">\"help\"</span><span class=\"token punctuation\">:</span>\n            replyMsg<span class=\"token punctuation\">.</span>Text <span class=\"token operator\">=</span> <span class=\"token string\">\"What can I help you?\"</span>\n        <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n            replyMsg<span class=\"token punctuation\">.</span>Text <span class=\"token operator\">=</span> <span class=\"token string\">\"No such command!!!\"</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> bot<span class=\"token punctuation\">.</span><span class=\"token function\">Send</span><span class=\"token punctuation\">(</span>replyMsg<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的程式碼其實也可以看到如何拿到傳送者的一些基本資料。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0fd54240-5c18-4b75-c7be-981cdb144e00/public\" alt=\"image\"></p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://core.telegram.org/\">Telegram APIs</a></li>\n<li><a href=\"https://github.com/go-telegram-bot-api/telegram-bot-api\">Golang bindings for the Telegram Bot API - GitHub</a></li>\n</ul>","rawMarkdownBody":"\nTelegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。\n\n<!--more-->\n\n## 新增自己的 Bot\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/fbf36cb0-84f4-4f7a-2553-04ecccf44800/public)\n\nTelegram 非常有趣，要新增自己的 Bot，只要跟 Telegram 上的 [BotFather](https://telegram.me/BotFather) `說一下`，他就會給你一個 Bot。\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9200bc38-828c-4ad4-a022-d34c3a692d00/public)\n\n按 BotFather 給你的步驟做，最後可以看到他會提供一個 API Token 給你，只要有這個 Token 就可以跟 Bot 溝通，要保存好，等等會用到，也不要給別人看到，以免自己的 Bot 變成別人的玩具。\n\n## go-telegram-bot-api\n\nGo 已經有社區開發的函式庫可以用 [telegram-bot-api](https://github.com/go-telegram-bot-api/telegram-bot-api)。\n\n```shell\ngo get -u github.com/go-telegram-bot-api/telegram-bot-api/v5\n\n```\n\n之後只要 import 就可以使用：\n\n```go\nimport (\n    tgbotapi \"github.com/go-telegram-bot-api/telegram-bot-api/v5\"\n)\n```\n\n## 連線到 Telegram Bot\n\n利用剛剛 import 的函式庫，只需要剛剛創建好的 Bot 的 API Token 就可以連線到 Telegram。\n\n```go\nbot, err := tgbotapi.NewBotAPI(os.Getenv(\"TELEGRAM_API_TOKEN\"))\nif err != nil {\n    panic(err)\n}\n```\n\n上面用環境變數的方式來取得 TOKEN，避免需要直接寫在程式碼裡，如果覺得在測試時設定環境變數很麻煩，可以用 JetBrains 的 [GoLand](https://www.jetbrains.com/go/)，設定 Runtime 的環境變數：\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9af5d8a5-3504-479d-ab04-f8b0adf93500/public)\n\n## 處理 Update\n\n要接收使用者傳過來的訊息，Telegram API 稱為 Update，我們使用的函示庫基本上都自動處理好了，只需要接收一個 Channel 就好。使用 `bot.GetUpdatesChan(config)` 會需要給一個 Config，這可以用 `tgbotapi.NewUpdate(0)` 來生，然後這邊設定 Timeout 為 60，如果對這個設定值有興趣，可以去看 Telegram 的文件。\n\n```go\nupdateConfig := tgbotapi.NewUpdate(0)\nupdateConfig.Timeout = 60\nupdates := bot.GetUpdatesChan(updateConfig)\n```\n\n## 回復\n\n我們先簡單寫一隻鸚鵡，把用戶傳過來的 Text，直接傳回去。\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/19bbc73e-3090-4a0d-0eec-d65671c01900/public)\n\n用 for 把 Channel 中的 Update 一個一個拿出來，然後用 `tgbotapi` 產生一個 Message 物件，裡面放在聊天室的 ID 和要回傳的 Text，最後用 bot 把 Message 傳回去。\n\n```go\nfor update := range updates {\n    text := update.Message.Text\n    chatID := update.Message.Chat.ID\n    replyMsg := tgbotapi.NewMessage(chatID, text)\n    _, _ = bot.Send(replyMsg)\n}\n```\n\n## 簡單鸚鵡的完整程式碼\n\n```go\npackage main\n\nimport (\n    tgbotapi \"github.com/go-telegram-bot-api/telegram-bot-api/v5\"\n    \"os\"\n)\n\nfunc main() {\n    bot, err := tgbotapi.NewBotAPI(os.Getenv(\"TELEGRAM_API_TOKEN\"))\n    if err != nil {\n        panic(err)\n    }\n    bot.Debug = true\n    updateConfig := tgbotapi.NewUpdate(0)\n    updateConfig.Timeout = 60\n    updates := bot.GetUpdatesChan(updateConfig)\n    for update := range updates {\n        text := update.Message.Text\n        chatID := update.Message.Chat.ID\n        replyMsg := tgbotapi.NewMessage(chatID, text)\n        _, _ = bot.Send(replyMsg)\n    }\n}\n```\n\n## 改寫成非阻塞的 Goroutine\n\n因為每次處理和回復都會需要一點時間，甚至是要去 DB 找資料，如果用上面的寫法，在處理多人或高速傳訊息的時候會被卡住，一次只能處理的一個訊息。還好 Go 的併發寫法非常簡單，只要放一個 go 在前面，就可以非阻塞的執行 function 中的內容。\n\n我們先把 `handleUpdate` 提取成一個 function，然後再用 go 去執行他：\n\n```go\nfunc main() {\n    bot, err := tgbotapi.NewBotAPI(os.Getenv(\"TELEGRAM_API_TOKEN\"))\n    if err != nil {\n        panic(err)\n    }\n    bot.Debug = true\n    updateConfig := tgbotapi.NewUpdate(0)\n    updateConfig.Timeout = 60\n    updates := bot.GetUpdatesChan(updateConfig)\n    for update := range updates {\n        go handleUpdate(bot, update)\n    }\n}\n\nfunc handleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n    text := update.Message.Text\n    chatID := update.Message.Chat.ID\n    replyMsg := tgbotapi.NewMessage(chatID, text)\n    _, _ = bot.Send(replyMsg)\n}\n```\n\n## 回復特定訊息\n\n要回復 `回復訊息` ，像是下面的效果也很簡單：\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/22010000-e325-45e6-52f9-64eec6b28500/public)\n\n只需要設定 `replyMsg.ReplyToMessageID` 就可以回復特定的訊息，下面就是直接回覆接收到的訊息：\n\n```go\nfunc handleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n    text := update.Message.Text\n    chatID := update.Message.Chat.ID\n    replyMsg := tgbotapi.NewMessage(chatID, text)\n    replyMsg.ReplyToMessageID = update.Message.MessageID\n    _, _ = bot.Send(replyMsg)\n}\n```\n\n## 處理 Command\n\nTelegram 中，用 `/` 開頭的文字就是 Command，這個函示庫也有寫好處理 Command 的方法，只需要用 `isCommand()`，確認一下是不是 Command 就可以：\n\n```go\nfunc handleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) {\n    text := update.Message.Text\n    chatID := update.Message.Chat.ID\n    replyMsg := tgbotapi.NewMessage(chatID, text)\n    if update.Message.IsCommand() {\n        switch update.Message.Command() {\n        case \"start\":\n            replyMsg.Text = \"Hello \" + update.Message.From.FirstName\n        case \"help\":\n            replyMsg.Text = \"What can I help you?\"\n        default:\n            replyMsg.Text = \"No such command!!!\"\n        }\n    }\n    _, _ = bot.Send(replyMsg)\n}\n```\n\n上面的程式碼其實也可以看到如何拿到傳送者的一些基本資料。\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0fd54240-5c18-4b75-c7be-981cdb144e00/public)\n\n## Reference\n\n- [Telegram APIs](https://core.telegram.org/)\n- [Golang bindings for the Telegram Bot API - GitHub](https://github.com/go-telegram-bot-api/telegram-bot-api)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Telegram/go-tg-bot.md","excerpt":"Telegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。 新增自己的 Bot image Telegram 非常有趣，要新增自己的 Bot，只要跟 Telegram 上的 BotFather ，他就會給你一個 Bot。 image 按 BotFather 給你的步驟做，最後可以看到他會提供一個 API Token …","frontmatter":{"title":"用 Go 寫 Telegram Bot","date":"2021-12-11T14:30:15.000Z","draft":false,"tags":["go","golang","telegram","bot","telegram-bot"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f8c04956-a2ef-4cba-b9fe-2a5ceff40b00/public","description":"Telegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。"}}},{"node":{"id":"d8fb3977-7c7f-57ad-83c2-8dc1d7ba1927","html":"<p>Flutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是 <code class=\"language-text\">() {}</code> 寫法，另一個是 <code class=\"language-text\">() =></code> 寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。</p>\n<!--more-->\n<h2>不同在哪</h2>\n<p>下面我用在寫 Flutter 中常見的創建一個有 10 個 Text 的 List 舉例。</p>\n<p>創建一個有 10 項元素的 List：</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Text</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">.</span><span class=\"token function\">generate</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>上面就是輸出一個帶有 0-9 的 List，那現在假設我會需要再創建 Text 前，根據 index 來做一些改變，下面就做最簡單的平方。</p>\n<div class=\"gatsby-highlight\" data-language=\"dart\"><pre class=\"language-dart\"><code class=\"language-dart\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Text</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">.</span><span class=\"token function\">generate</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do some work</span>\n    <span class=\"token keyword\">var</span> text <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>index <span class=\"token operator\">*</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">Text</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>觀察上面兩個例子，不難發現兩個的差別，第一個寫法 <code class=\"language-text\">() =></code> 後面直接接上一個表達式(Expression)，當作回傳值。而 <code class=\"language-text\">() {}</code> 則是在大括號中寫一個完整的 Function，所以要寫一個 return。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/51868395/flutter-dart-difference-between-and\">Flutter/Dart - Difference between () {} and () => {}</a></li>\n</ul>","rawMarkdownBody":"\nFlutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是 `() {}` 寫法，另一個是 `() =>` 寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。\n\n<!--more-->\n\n## 不同在哪\n\n下面我用在寫 Flutter 中常見的創建一個有 10 個 Text 的 List 舉例。\n\n創建一個有 10 項元素的 List：\n\n```dart\nList<Text> list = List.generate(10, (index) => Text(index.toString()));\n```\n\n上面就是輸出一個帶有 0-9 的 List，那現在假設我會需要再創建 Text 前，根據 index 來做一些改變，下面就做最簡單的平方。\n\n```dart\nList<Text> list = List.generate(10, (index) {\n    // do some work\n    var text = (index * index).toString();\n    return Text(text);\n});\n```\n\n觀察上面兩個例子，不難發現兩個的差別，第一個寫法 `() =>` 後面直接接上一個表達式(Expression)，當作回傳值。而 `() {}` 則是在大括號中寫一個完整的 Function，所以要寫一個 return。\n\n## Reference\n\n- [Flutter/Dart - Difference between () {} and () => {}](https://stackoverflow.com/questions/51868395/flutter-dart-difference-between-and)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Flutter/Dart Function Lambda diff.md","excerpt":"Flutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是  寫法，另一個是  寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。 不同在哪 下面我用在寫 Flutter 中常見的創建一個有 10 個 Text 的 List 舉例。 創建一個有 10 項元素的 List： 上面就是輸出一個帶有 0-9…","frontmatter":{"title":"Flutter/Dart (){} 和 () => 的差別","date":"2021-11-04T05:52:44.000Z","draft":false,"tags":["dart","flutter","function"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f8a3eaa5-e9c2-455f-d301-43fc77fee200/large","description":"Flutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是 () {} 寫法，另一個是 () => 寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。"}}},{"node":{"id":"5a287e0a-4039-585c-b56d-03d41cb6b549","html":"<p>上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。</p>\n<!--more-->\n<blockquote>\n<p>No one likes to wait. Internet impatience is something we all suffer from.</p>\n</blockquote>\n<p>文章一開頭就用一句點出大家在上網時會遇到的狀況，沒有人喜歡等待，可是所有人都在上網時身受其害，相信大家都遇過下面的情況：</p>\n<ol>\n<li>等待 App 完成內容更新</li>\n<li>等待網頁出現</li>\n<li>等待電影開始播放</li>\n</ol>\n<p>但有寫過程式或服務的都知道，人一多，就一定慢，非常的難避免，<del>所以這時候就要用 Cloudflare</del>，這時又宣傳了一下 Cloudflare。</p>\n<p>許多使用者家裡都會覺得網路很慢，然後買了很快很快的網速，像是 100Mbpa, 1Gbps 甚至 2Gbps，但其實就算家裡的網路再怎麼快，你連線的 Server 就是很慢，你的上網體驗還是大打折扣。</p>\n<p>如果要讓自己的服務不卡，只需要完成下面三樣要求：</p>\n<ol>\n<li>Server 有充足的帶寬</li>\n<li>讓 Server 盡量接近 User</li>\n<li>讓你的 Web 或 App 盡量得快</li>\n</ol>\n<p>看起來很簡單，但如果要完成這三個要求，都會耗費極大的成本。</p>\n<h2>DNS</h2>\n<p>現今的網路世界主要是由 ipv4 組成，也就是說，如果沒有 ipv4 地址，所有的網路連線都不會發生，如果我只知道 <a href=\"www.fcu.edu.tw\">www.fcu.edu.tw</a>，是完全沒有辦法上網的，因為我並不知道這個網址對應的 ip 是多少 (像是 140.134.xxx.xxx)，就完全沒有辦法和伺服器產生連線。DNS 出現前，大家都是直接用 ip 溝通，快速方便，最大的缺點就是非常難記。所以 DNS 就出現了，DNS 就像你打電話會需要電話簿一樣，我只我需要一個簡單好記的名字，再去電話簿搜尋真正的電話號碼就好。</p>\n<p>在知道電話號碼前，所有網路連線都不會發生，所以用最快速的方式查找電話簿絕對是上網速度最重要的一環，如果光是要知道 ip 位置就花掉 50ms(甚至更多)，上網效率就會大大降低。如今網路上有許多的 DNS 提供商，為大家記下這龐大的 DNS 電話簿，最著名的就是 Google 的 <a href=\"8.8.8.8\">8.8.8.8</a>，和 Cloudflare 的 <a href=\"1.1.1.1\">1.1.1.1</a>，Cloudflare 宣稱他是全世界最快的 DNS 提供商，(雖然在台灣好像未必)，但 Cloudflare 承諾他不會<strong>紀錄</strong>使用者查過的 DNS 紀錄，或上過什麼網頁 (好像是在暗示競爭對手會這麼做)。</p>\n<p>另外，就算 DNS 伺服器完全不假思索 (沒有反應時間) 就回傳 DNS 的查詢結果，這也付出了至少一個<a href=\"#%E5%85%89%E9%80%9F%E6%90%8D%E8%80%97\"><strong>光速的代價</strong></a>，聽起來好像沒什麼影響，但可以看看下面簡單的計算。</p>\n<h3>光速損耗</h3>\n<p>假設我家和 DNS 伺服器之間的直線距離是 100 公里，而且中華電信筆直的連接了一條筆直光纖到 DNS 伺服器，而光在光纖中的速度是 200,000,000 公尺/秒，往返需要 200,000 公尺。經過這樣簡單的計算，光是光速就已經耗費整整 1 毫秒(ms)，可以試著想想看更糟的情況，光速已經開始在嚴重拖累網速。</p>\n<h2>Hello Hello OK</h2>\n<p>知道了 ip 後，瀏覽器終於可以連上目標伺服器取得網頁，不久後就可以看到網頁出現在眼前。</p>\n<p>上面的步驟，幾乎都是由 TCP 協定完成，協定的第一步就是你的電腦和伺服器互相同意連線，這個過程稱作三向交握 (Three-Way Handshake)，步驟如下：</p>\n<ol>\n<li>Client 對 Server 說：Hello</li>\n<li>Server 對 Client 說：我聽到你說 Hello</li>\n<li>Client 對 Server 說：我聽到 -- 你說你聽到我說 Hello，我們現在可以溝通了。</li>\n</ol>\n<p>從上面的步驟就可以發現，已經至少耗費了<a href=\"#%E5%85%89%E9%80%9F%E6%90%8D%E8%80%97\">一個光速的時間</a>，所以也是一樣，伺服器愈靠近用戶，網速就愈快。這也是為什麼 Cloudflare 在世界各地廣設伺服器。</p>\n<h3>TLS/SSL</h3>\n<p>有了 TCP 我們就可以安全的連線了嗎？當然不是，TCP 一點也不安全，現在的網路連線幾乎都是透過 TLS (或稱作 SSL) 加密連線，所以 TCP 連線後，下一步是建立安全的加密連線。</p>\n<p>TLS 是一個非常複雜的加密協定，會牽涉到下面的設備：網路瀏覽器、建立鑰匙的伺服器，而且還要有一個可以證明他的身分的伺服器，因為不會想要和銀行建立安全連線，但你根本不確定他是不是你的銀行。</p>\n<p>上面的步驟也會需要好幾次<a href=\"#%E5%85%89%E9%80%9F%E6%90%8D%E8%80%97\">光速損耗</a>，所以讓伺服器愈靠近用戶端愈好。另外，也要盡量使用最新的 TLS 標準 (現在是 TLS 1.3)。</p>\n<h2>後記</h2>\n<p>我覺得這篇文章最有趣的的部分就是一直在討論光速對網路連線的影響，以往我都覺得光速很快，但光就算很快，光也是要跑很長一段距離，這樣耗損來回個幾次就已經對網路連線產生極大的影響了，而且更何況一個連線就一定會需要來回溝通好幾次。這篇文章後面還有蠻多內容，但我覺得沒有那麼重要就懶得寫了，有興趣的話可以自己繼續往下看。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://blog.cloudflare.com/fastest-internet/\">Welcome to Speed Week and a Waitless Internet</a></li>\n</ul>","rawMarkdownBody":"\n上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。\n\n<!--more-->\n\n> No one likes to wait. Internet impatience is something we all suffer from.\n\n文章一開頭就用一句點出大家在上網時會遇到的狀況，沒有人喜歡等待，可是所有人都在上網時身受其害，相信大家都遇過下面的情況：\n\n1. 等待 App 完成內容更新\n2. 等待網頁出現\n3. 等待電影開始播放\n\n但有寫過程式或服務的都知道，人一多，就一定慢，非常的難避免，~~所以這時候就要用 Cloudflare~~，這時又宣傳了一下 Cloudflare。\n\n許多使用者家裡都會覺得網路很慢，然後買了很快很快的網速，像是 100Mbpa, 1Gbps 甚至 2Gbps，但其實就算家裡的網路再怎麼快，你連線的 Server 就是很慢，你的上網體驗還是大打折扣。\n\n如果要讓自己的服務不卡，只需要完成下面三樣要求：\n\n1. Server 有充足的帶寬\n2. 讓 Server 盡量接近 User\n3. 讓你的 Web 或 App 盡量得快\n\n看起來很簡單，但如果要完成這三個要求，都會耗費極大的成本。\n\n## DNS\n\n現今的網路世界主要是由 ipv4 組成，也就是說，如果沒有 ipv4 地址，所有的網路連線都不會發生，如果我只知道 [www.fcu.edu.tw](www.fcu.edu.tw)，是完全沒有辦法上網的，因為我並不知道這個網址對應的 ip 是多少 (像是 140.134.xxx.xxx)，就完全沒有辦法和伺服器產生連線。DNS 出現前，大家都是直接用 ip 溝通，快速方便，最大的缺點就是非常難記。所以 DNS 就出現了，DNS 就像你打電話會需要電話簿一樣，我只我需要一個簡單好記的名字，再去電話簿搜尋真正的電話號碼就好。\n\n在知道電話號碼前，所有網路連線都不會發生，所以用最快速的方式查找電話簿絕對是上網速度最重要的一環，如果光是要知道 ip 位置就花掉 50ms(甚至更多)，上網效率就會大大降低。如今網路上有許多的 DNS 提供商，為大家記下這龐大的 DNS 電話簿，最著名的就是 Google 的 [8.8.8.8](8.8.8.8)，和 Cloudflare 的 [1.1.1.1](1.1.1.1)，Cloudflare 宣稱他是全世界最快的 DNS 提供商，(雖然在台灣好像未必)，但 Cloudflare 承諾他不會**紀錄**使用者查過的 DNS 紀錄，或上過什麼網頁 (好像是在暗示競爭對手會這麼做)。\n\n另外，就算 DNS 伺服器完全不假思索 (沒有反應時間) 就回傳 DNS 的查詢結果，這也付出了至少一個[**光速的代價**](#光速損耗)，聽起來好像沒什麼影響，但可以看看下面簡單的計算。\n\n### 光速損耗\n\n假設我家和 DNS 伺服器之間的直線距離是 100 公里，而且中華電信筆直的連接了一條筆直光纖到 DNS 伺服器，而光在光纖中的速度是 200,000,000 公尺/秒，往返需要 200,000 公尺。經過這樣簡單的計算，光是光速就已經耗費整整 1 毫秒(ms)，可以試著想想看更糟的情況，光速已經開始在嚴重拖累網速。\n\n## Hello Hello OK\n\n知道了 ip 後，瀏覽器終於可以連上目標伺服器取得網頁，不久後就可以看到網頁出現在眼前。\n\n上面的步驟，幾乎都是由 TCP 協定完成，協定的第一步就是你的電腦和伺服器互相同意連線，這個過程稱作三向交握 (Three-Way Handshake)，步驟如下：\n\n1. Client 對 Server 說：Hello\n2. Server 對 Client 說：我聽到你說 Hello\n3. Client 對 Server 說：我聽到 -- 你說你聽到我說 Hello，我們現在可以溝通了。\n\n從上面的步驟就可以發現，已經至少耗費了[一個光速的時間](#光速損耗)，所以也是一樣，伺服器愈靠近用戶，網速就愈快。這也是為什麼 Cloudflare 在世界各地廣設伺服器。\n\n### TLS/SSL\n\n有了 TCP 我們就可以安全的連線了嗎？當然不是，TCP 一點也不安全，現在的網路連線幾乎都是透過 TLS (或稱作 SSL) 加密連線，所以 TCP 連線後，下一步是建立安全的加密連線。\n\nTLS 是一個非常複雜的加密協定，會牽涉到下面的設備：網路瀏覽器、建立鑰匙的伺服器，而且還要有一個可以證明他的身分的伺服器，因為不會想要和銀行建立安全連線，但你根本不確定他是不是你的銀行。\n\n上面的步驟也會需要好幾次[光速損耗](#光速損耗)，所以讓伺服器愈靠近用戶端愈好。另外，也要盡量使用最新的 TLS 標準 (現在是 TLS 1.3)。\n\n## 後記\n\n我覺得這篇文章最有趣的的部分就是一直在討論光速對網路連線的影響，以往我都覺得光速很快，但光就算很快，光也是要跑很長一段距離，這樣耗損來回個幾次就已經對網路連線產生極大的影響了，而且更何況一個連線就一定會需要來回溝通好幾次。這篇文章後面還有蠻多內容，但我覺得沒有那麼重要就懶得寫了，有興趣的話可以自己繼續往下看。\n\n## Reference\n\n- [Welcome to Speed Week and a Waitless Internet](https://blog.cloudflare.com/fastest-internet/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/Cloudflare Speed Week.md","excerpt":"上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。 No one likes to wait. Internet impatienc…","frontmatter":{"title":"Cloudflare Speed Week","date":"2021-10-05T16:10:58.000Z","draft":false,"tags":["cloudflare","web","internet","tcp"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/be2106f3-0557-4e94-803a-9dda63550300/public","description":"上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。"}}},{"node":{"id":"829e849f-13bc-5b82-8699-88b701b8f0e3","html":"<p>Kotlin 在非同步處理上有新的方法，協程 <code class=\"language-text\">Coroutine</code>。<code class=\"language-text\">Coroutine</code> 不會像 <code class=\"language-text\">Thread</code> 會耗費大量的資源，能在原本的<code class=\"language-text\">線程</code>上創建極為輕量的<code class=\"language-text\">協程</code>，且較不會發生記憶體洩漏的情況。</p>\n<!--more-->\n<h2>導入 Coroutine</h2>\n<p>在 <code class=\"language-text\">build.gradle</code> 中添加依賴項</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">dependencies <span class=\"token punctuation\">{</span>\n    implementation <span class=\"token string\">'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2'</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>若要在 <code class=\"language-text\">Android</code> 中使用需要再添加 <code class=\"language-text\">Android</code> 依賴</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">implementation <span class=\"token string\">'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2'</span></code></pre></div>\n<h2>第一個 Coroutine</h2>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">//在後台啟動一個新的縣協程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//非阻塞式的等待 1 秒鐘</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 阻塞主線程兩秒確保主線程存活</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的程式碼輸出結果：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">Hellow<span class=\"token punctuation\">,</span>\nWorld</code></pre></div>\n<p>基本上 <code class=\"language-text\">Coroutine</code> 就是輕量的協程</p>\n<p>也可以分別將 <code class=\"language-text\">GlobalScope.launch{...}</code> 和 <code class=\"language-text\">delay(...)</code> 替換成<code class=\"language-text\">thread { ... }</code> 和 <code class=\"language-text\">Thread.Sleap(...)</code>，也可以得到相同的結果，可以嘗試一下。</p>\n<p>如果只將 <code class=\"language-text\">GlobalScope.launch{...}</code> 替換成 <code class=\"language-text\">thread{...}</code> 你會得到以下錯誤：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another <span class=\"token function\">suspend</span> <span class=\"token keyword\">function</span></code></pre></div>\n<p>因為 <code class=\"language-text\">delay()</code> 是一個特殊的 <code class=\"language-text\">suspend function</code> (有人譯作 <code class=\"language-text\">掛起函數</code>)，他不會阻塞線程，但是會 <code class=\"language-text\">suspend</code> 協程，而且只能在協程中使用。</p>\n<h2>橋接阻塞和非阻塞的世界</h2>\n<p>上面的範例中同時使用了非阻塞式的 <code class=\"language-text\">delay()</code> 和阻塞式的 <code class=\"language-text\">Thread.sleap()</code>，這樣很容易讓我們混淆哪個會阻塞線程。下面我們使用 <code class=\"language-text\">runblocking{...}</code> 來阻塞線程</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 在後台啟動一個新的協程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    runBlocking <span class=\"token punctuation\">{</span>     <span class=\"token comment\">// 這個表達式會阻塞主線程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 延遲兩秒來確保主線程存活</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>結果基本上是相似的，只是都是使用了非組塞式的 <code class=\"language-text\">delay()</code>。調用了 <code class=\"language-text\">runblocking{...}</code> 的主線程會被阻塞直到 <code class=\"language-text\">runblocking{...}</code> 內的協程執行完畢。</p>\n<p>下面用一個更合乎慣用法的方法在寫一次，用 <code class=\"language-text\">runblocking{...}</code> 來包裝 <code class=\"language-text\">main</code> 方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 開始執行主協程</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 在後台啓動一個協程並繼續執行</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 延遲 2 秒來確保主線程存活</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這裡的 <code class=\"language-text\">runBlocking {...}</code> 用來啟動主線程。我們顯式指定了其返回類型 <code class=\"language-text\">Unit</code>，因為在 Kotlin 中 <code class=\"language-text\">main</code> 方法必須回傳 <code class=\"language-text\">Unit</code>。</p>\n<h2>等待一個作業完成</h2>\n<p>延遲一段時間來確保協程的運行並不是一個好辦法利用 <code class=\"language-text\">job.join()</code> 來確保工作執行結束。</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job<span class=\"token operator\">:</span> Job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">launch</code> 會回傳一個 <code class=\"language-text\">Job</code> 物件，而 <code class=\"language-text\">job.join()</code> 其實就是會等待 <code class=\"language-text\">job</code> 的工作完成再繼續持行。</p>\n<p>我們也可以利用 <code class=\"language-text\">job.cancel()</code> 取消協程：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job<span class=\"token operator\">:</span> Job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>但是如果 <code class=\"language-text\">job</code> 已經完成工作，<code class=\"language-text\">cancel</code> 是不會發生任何事。</p>\n<h2>參考資料</h2>\n<ul>\n<li><a href=\"https://kotlinlang.org/docs/reference/coroutines/basics.html\">Coroutine Basics</a></li>\n</ul>","rawMarkdownBody":"\nKotlin 在非同步處理上有新的方法，協程 `Coroutine`。`Coroutine` 不會像 `Thread` 會耗費大量的資源，能在原本的`線程`上創建極為輕量的`協程`，且較不會發生記憶體洩漏的情況。\n\n<!--more-->\n\n## 導入 Coroutine\n\n在 `build.gradle` 中添加依賴項\n\n```groovy\ndependencies {\n    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2'\n}\n```\n\n若要在 `Android` 中使用需要再添加 `Android` 依賴\n\n```groovy\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2'\n```\n\n## 第一個 Coroutine\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { //在後台啟動一個新的縣協程\n        delay(1000L) //非阻塞式的等待 1 秒鐘\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    Thread.sleep(2000L) // 阻塞主線程兩秒確保主線程存活\n}\n```\n\n上面的程式碼輸出結果：\n\n```kotlin\nHellow,\nWorld\n```\n\n基本上 `Coroutine` 就是輕量的協程\n\n也可以分別將 `GlobalScope.launch{...}` 和 `delay(...)` 替換成`thread { ... }` 和 `Thread.Sleap(...)`，也可以得到相同的結果，可以嘗試一下。\n\n如果只將 `GlobalScope.launch{...}` 替換成 `thread{...}` 你會得到以下錯誤：\n\n```shell\nError: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function\n```\n\n因為 `delay()` 是一個特殊的 `suspend function` (有人譯作 `掛起函數`)，他不會阻塞線程，但是會 `suspend` 協程，而且只能在協程中使用。\n\n## 橋接阻塞和非阻塞的世界\n\n上面的範例中同時使用了非阻塞式的 `delay()` 和阻塞式的 `Thread.sleap()`，這樣很容易讓我們混淆哪個會阻塞線程。下面我們使用 `runblocking{...}` 來阻塞線程\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { // 在後台啟動一個新的協程\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    runBlocking {     // 這個表達式會阻塞主線程\n        delay(2000L)  // 延遲兩秒來確保主線程存活\n    }\n}\n```\n\n結果基本上是相似的，只是都是使用了非組塞式的 `delay()`。調用了 `runblocking{...}` 的主線程會被阻塞直到 `runblocking{...}` 內的協程執行完畢。\n\n下面用一個更合乎慣用法的方法在寫一次，用 `runblocking{...}` 來包裝 `main` 方法：\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> { // 開始執行主協程\n    GlobalScope.launch { // 在後台啓動一個協程並繼續執行\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    delay(2000L)  // 延遲 2 秒來確保主線程存活\n}\n```\n\n這裡的 `runBlocking {...}` 用來啟動主線程。我們顯式指定了其返回類型 `Unit`，因為在 Kotlin 中 `main` 方法必須回傳 `Unit`。\n\n## 等待一個作業完成\n\n延遲一段時間來確保協程的運行並不是一個好辦法利用 `job.join()` 來確保工作執行結束。\n\n```kotlin\nval job: Job = GlobalScope.launch {\n    delay(1000L)\n    println(\"World!\")\n}\nprintln(\"Hello,\")\njob.join()\n```\n\n`launch` 會回傳一個 `Job` 物件，而 `job.join()` 其實就是會等待 `job` 的工作完成再繼續持行。\n\n我們也可以利用 `job.cancel()` 取消協程：\n\n```kotlin\nval job: Job = GlobalScope.launch {\n    delay(1000L)\n    println(\"World!\")\n}\nprintln(\"Hello,\")\njob.cancel()\n```\n\n但是如果 `job` 已經完成工作，`cancel` 是不會發生任何事。\n\n## 參考資料\n\n- [Coroutine Basics](https://kotlinlang.org/docs/reference/coroutines/basics.html)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Kotlin/kotlin coroutine.md","excerpt":"Kotlin 在非同步處理上有新的方法，協程 。 不會像  會耗費大量的資源，能在原本的上創建極為輕量的，且較不會發生記憶體洩漏的情況。 導入 Coroutine 在  中添加依賴項 若要在  中使用需要再添加  依賴 第一個 Coroutine 上面的程式碼輸出結果： 基本上  就是輕量的協程 也可以分別將  和  替換成 和 ，也可以得到相同的結果，可以嘗試一下。 如果只將  替換成  你會…","frontmatter":{"title":"Kotlin Coroutine","date":"2021-09-19T07:26:56.000Z","draft":false,"tags":["kotlin","coroutine"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6f11a63e-3923-4ce5-3b6e-d06243815300/public","description":"Kotlin 在非同步處理上有新的方法，協程 Coroutine，Coroutine 不會像 Thread 會耗費大量的資源，能在原本的線程上創建極為輕量的協程，且較不會發生記憶體洩漏的情況。"}}},{"node":{"id":"c18c63aa-34a1-5207-8f88-2ab72f9491df","html":"<p>要在一個 Git 專案中有子專案 (我都叫他 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄 submodule 的路徑和 commit 版本。</p>\n<!--more-->\n<h2>Add Submodule</h2>\n<p>要將專案新增到現有的目錄中，可以使用 <code class=\"language-text\">git submodule add</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> submodule <span class=\"token function\">add</span> <span class=\"token operator\">&lt;</span>repo_url<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>folder<span class=\"token operator\">></span></code></pre></div>\n<p>執行後，可以看到 git 會自動幫你把 submodule clone 到指定的目錄中，並多了一個檔案 <code class=\"language-text\">.gitmodules</code>，這個檔案就是上面說到的 Submodule 只紀錄 commit 版本，和 Submodule URL 的檔案。</p>\n<p>add submodule 後，還是要 commit，因為 Submodule 也就只是紀錄要用子專案的哪一個 commit 版本，所以也可以確保大家都是使用到同一個 Submodule 的版本。可以試著將專案 commit and push 到 GitHub 上，應該可以看到 Submodule 就是連結到另外一個專案的某一個 commit，下面是本站的 Hugo 主題的 submodule：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c4ba8819-787e-4726-fb58-db317f9ed400/public\" alt=\"image\"></p>\n<h2>Clone Submodule</h2>\n<p>在 Clone 含有 Submodule 的專案時，Git 預設是不會自動 clone 子專案的，需要加上 <code class=\"language-text\">--recursive</code> 這個參數，才會自動把 Submodule 也 Clone 下來。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> clone --recursive <span class=\"token operator\">&lt;</span>repo_url<span class=\"token operator\">></span></code></pre></div>\n<p>如果 Clone 下來後才發現有 Submodule，可以用下面的方式補救，把子專案都 Clone 下來：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> submodule init\n<span class=\"token function\">git</span> submodule update --recursive</code></pre></div>","rawMarkdownBody":"\n要在一個 Git 專案中有子專案 (我都叫他 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄 submodule 的路徑和 commit 版本。\n\n<!--more-->\n\n## Add Submodule\n\n要將專案新增到現有的目錄中，可以使用 `git submodule add`：\n\n```shell\ngit submodule add <repo_url> <folder>\n```\n\n執行後，可以看到 git 會自動幫你把 submodule clone 到指定的目錄中，並多了一個檔案 `.gitmodules`，這個檔案就是上面說到的 Submodule 只紀錄 commit 版本，和 Submodule URL 的檔案。\n\nadd submodule 後，還是要 commit，因為 Submodule 也就只是紀錄要用子專案的哪一個 commit 版本，所以也可以確保大家都是使用到同一個 Submodule 的版本。可以試著將專案 commit and push 到 GitHub 上，應該可以看到 Submodule 就是連結到另外一個專案的某一個 commit，下面是本站的 Hugo 主題的 submodule：\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c4ba8819-787e-4726-fb58-db317f9ed400/public)\n\n## Clone Submodule\n\n在 Clone 含有 Submodule 的專案時，Git 預設是不會自動 clone 子專案的，需要加上 `--recursive` 這個參數，才會自動把 Submodule 也 Clone 下來。\n\n```shell\ngit clone --recursive <repo_url>\n```\n\n如果 Clone 下來後才發現有 Submodule，可以用下面的方式補救，把子專案都 Clone 下來：\n\n```shell\ngit submodule init\ngit submodule update --recursive\n```\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Git/git submodule.md","excerpt":"要在一個 Git 專案中有子專案 (我都叫他 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄 submodule 的路徑和 commit 版本。 Add Submodule 要將專案新增到現有的目錄中，可以使用 ： 執行後，可以看到 git 會自動幫你把 submodul…","frontmatter":{"title":"Git Submodule","date":"2021-09-14T05:11:27.000Z","draft":false,"tags":["git","submodule","linux"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6c29c4ca-3fc9-49b2-3109-0876c7492400/public","description":"要在一個 Git 專案中有子專案 (我稱為 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄"}}},{"node":{"id":"a9e11a01-abab-5de8-b3ae-abccff685c14","html":"<p>在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。</p>\n<!--more-->\n<h2>ssh-keygen</h2>\n<p>要使用 ssh 非對稱加密，就會需要公鑰與私鑰，創建 ssh key 的方法就是 <code class=\"language-text\">ssh-keygen</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">user@66c0bf85e710:~$ ssh-keygen\nGenerating public/private rsa key pair.\nEnter <span class=\"token function\">file</span> <span class=\"token keyword\">in</span> <span class=\"token function\">which</span> to save the key <span class=\"token punctuation\">(</span>/home/user/.ssh/id_rsa<span class=\"token punctuation\">)</span>:\nCreated directory <span class=\"token string\">'/home/user/.ssh'</span><span class=\"token builtin class-name\">.</span>\nEnter passphrase <span class=\"token punctuation\">(</span>empty <span class=\"token keyword\">for</span> no passphrase<span class=\"token punctuation\">)</span>:\nEnter same passphrase again:\nYour identification has been saved <span class=\"token keyword\">in</span> /home/user/.ssh/id_rsa\nYour public key has been saved <span class=\"token keyword\">in</span> /home/user/.ssh/id_rsa.pub\nThe key fingerprint is:\nSHA256:+UUuTN0YLUi2eh7HJoJvuy0whUuLvXIQejjPPTZ9gw4 user@66c0bf85e710\nThe key's randomart image is:\n+---<span class=\"token punctuation\">[</span>RSA <span class=\"token number\">3072</span><span class=\"token punctuation\">]</span>----+\n<span class=\"token operator\">|</span>         .o<span class=\"token punctuation\">..</span>.   <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>         <span class=\"token punctuation\">..</span>o.+.  <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>       <span class=\"token builtin class-name\">.</span>  o +<span class=\"token punctuation\">..</span>  <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>    <span class=\"token builtin class-name\">.</span> o<span class=\"token punctuation\">..</span><span class=\"token operator\">=</span> +     <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>   o <span class=\"token operator\">=</span>.+S * *    <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>  + + *. <span class=\"token operator\">=</span> B     <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>   <span class=\"token operator\">=</span> <span class=\"token assign-left variable\">oE</span><span class=\"token operator\">=</span>o.o      <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>    + Bo+oo      <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>     + +++<span class=\"token punctuation\">..</span>     <span class=\"token operator\">|</span>\n+----<span class=\"token punctuation\">[</span>SHA256<span class=\"token punctuation\">]</span>-----+</code></pre></div>\n<p><code class=\"language-text\">ssh-keygen</code> 會問一些問題，最快的方式就是直接留白(保持預設)，一直按 enter 就可以看到已經在 <code class=\"language-text\">~/.ssh</code> 產生了兩個檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">user@66c0bf85e710:~$ <span class=\"token function\">ls</span> -l ~/.ssh\ntotal <span class=\"token number\">8</span>\n-rw------- <span class=\"token number\">1</span> user user <span class=\"token number\">2602</span> Sep <span class=\"token number\">12</span> <span class=\"token number\">22</span>:42 id_rsa\n-rw-r--r-- <span class=\"token number\">1</span> user user  <span class=\"token number\">571</span> Sep <span class=\"token number\">12</span> <span class=\"token number\">22</span>:42 id_rsa.pub\nuser@66c0bf85e710:~$</code></pre></div>\n<p><code class=\"language-text\">id_rsa</code> 就是私鑰，而多個 pub 結尾的 <code class=\"language-text\">id_rsa.pub</code> 就是公鑰。私鑰請不要傳給任何人，公鑰則提供給 GitHub。可以用 cat 將公鑰顯示出來並複製他：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.714d829xbug0.png\" alt=\"image\"></p>\n<h2>把公鑰交給 GitHub</h2>\n<p>到 GitHub 的 Settings -> SSH and GPG keys -> New SSH key：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.5frveu05dt00.png\" alt=\"image\"></p>\n<p>把剛剛複製下來的公鑰貼上，Title 可以自己隨便輸入或打這台電腦的名字：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.56vkhmb55ps0.png\" alt=\"image\"></p>\n<h2>測試連線</h2>\n<p>輸入下面命令就可以知道有沒有連線成功，如果有看到自己的使用者名稱，就代表已經完成 ssh 的認證：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">ssh</span> -T git@github.com</code></pre></div>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.5f99gnzo3ps0.png\" alt=\"image\"></p>\n<p>第一次連線可能會問要不要信任，輸入 <code class=\"language-text\">yes</code> 即可。</p>\n<blockquote>\n<p>如果覺得上面的方法麻煩，也可以直接創建一個私有 repo，然後試著 clone 和 push，就知道有沒有認證成功了。</p>\n</blockquote>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/testing-your-ssh-connection\">Testing your SSH connection</a></li>\n</ul>","rawMarkdownBody":"\n在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。\n\n<!--more-->\n\n## ssh-keygen\n\n要使用 ssh 非對稱加密，就會需要公鑰與私鑰，創建 ssh key 的方法就是 `ssh-keygen`：\n\n```shell\nuser@66c0bf85e710:~$ ssh-keygen\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/user/.ssh/id_rsa):\nCreated directory '/home/user/.ssh'.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/user/.ssh/id_rsa\nYour public key has been saved in /home/user/.ssh/id_rsa.pub\nThe key fingerprint is:\nSHA256:+UUuTN0YLUi2eh7HJoJvuy0whUuLvXIQejjPPTZ9gw4 user@66c0bf85e710\nThe key's randomart image is:\n+---[RSA 3072]----+\n|         .o...   |\n|         ..o.+.  |\n|       .  o +..  |\n|    . o..= +     |\n|   o =.+S * *    |\n|  + + *. = B     |\n|   = oE=o.o      |\n|    + Bo+oo      |\n|     + +++..     |\n+----[SHA256]-----+\n```\n\n`ssh-keygen` 會問一些問題，最快的方式就是直接留白(保持預設)，一直按 enter 就可以看到已經在 `~/.ssh` 產生了兩個檔案：\n\n```shell\nuser@66c0bf85e710:~$ ls -l ~/.ssh\ntotal 8\n-rw------- 1 user user 2602 Sep 12 22:42 id_rsa\n-rw-r--r-- 1 user user  571 Sep 12 22:42 id_rsa.pub\nuser@66c0bf85e710:~$\n```\n\n`id_rsa` 就是私鑰，而多個 pub 結尾的 `id_rsa.pub` 就是公鑰。私鑰請不要傳給任何人，公鑰則提供給 GitHub。可以用 cat 將公鑰顯示出來並複製他：\n\n![image](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.714d829xbug0.png)\n\n## 把公鑰交給 GitHub\n\n到 GitHub 的 Settings -> SSH and GPG keys -> New SSH key：\n\n![image](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.5frveu05dt00.png)\n\n把剛剛複製下來的公鑰貼上，Title 可以自己隨便輸入或打這台電腦的名字：\n\n![image](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.56vkhmb55ps0.png)\n\n## 測試連線\n\n輸入下面命令就可以知道有沒有連線成功，如果有看到自己的使用者名稱，就代表已經完成 ssh 的認證：\n\n```shell\nssh -T git@github.com\n```\n\n![image](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.5f99gnzo3ps0.png)\n\n第一次連線可能會問要不要信任，輸入 `yes` 即可。\n\n> 如果覺得上面的方法麻煩，也可以直接創建一個私有 repo，然後試著 clone 和 push，就知道有沒有認證成功了。\n\n## Reference\n\n- [Testing your SSH connection](https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/testing-your-ssh-connection)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Git/github ssh.md","excerpt":"在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。 ssh-keygen 要使用 ssh 非對稱加密，就會需要公鑰與私鑰，創建 ssh key 的方法就是 ：  會問一些問題，最快的方式就是直接留白(保持預設)，一直按 enter 就可以看到已經在  產生了兩個檔案：  就是私鑰，而多個 pub 結尾的…","frontmatter":{"title":"GitHub SSH","date":"2021-09-12T14:32:19.000Z","draft":false,"tags":["git","github","ssh"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8fdd1b8a-21b2-4d15-9947-a6bdcc6f1000/public","description":"在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。"}}},{"node":{"id":"6768d0b8-3c0c-5392-8320-9c2443f08519","html":"<p>紀錄一下我的 <a href=\"https://github.com/TonyPepeBear/cloud-ide-docker\">Cloud IDE Docker</a> 使用方法。</p>\n<!--more-->\n<h2>Pycharm Community</h2>\n<p><a href=\"https://hub.docker.com/r/tonypepe/pycharmc\">Docker Hub</a></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -dp <span class=\"token number\">8887</span>:8887 tonypepe/pycharmc</code></pre></div>","rawMarkdownBody":"\n紀錄一下我的 [Cloud IDE Docker](https://github.com/TonyPepeBear/cloud-ide-docker) 使用方法。\n\n<!--more-->\n\n## Pycharm Community\n\n[Docker Hub](https://hub.docker.com/r/tonypepe/pycharmc)\n\n```bash\ndocker run -dp 8887:8887 tonypepe/pycharmc\n```\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Dev/Cloud Ide Docker.md","excerpt":"紀錄一下我的 Cloud IDE Docker 使用方法。 Pycharm Community Docker Hub","frontmatter":{"title":"Cloud IDE Docker","date":"2021-08-30T08:13:47.000Z","draft":false,"tags":["ide","docker","jetbrains"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/87cfccae-9904-4391-0e52-2b001fffd500/public","description":null}}},{"node":{"id":"b04ee4c4-22aa-519f-a77a-6ab113d7d6a2","html":"<p>Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。</p>\n<!--more-->\n<h2>Docker v.s. VM</h2>\n<p>入門 Docker 最常見的問題就是，Docker 和 VM 差在哪裡？這個問題不難理解，VM 「虛擬機」，顧名思義是虛擬化「硬體」。而 Docker 則是只虛擬化作業系統，或是稱作「軟體」。</p>\n<p>大家都應該知道每創建一個虛擬機，都會耗費掉數分鐘的時間，若還要安裝環境，那耗費的時間則會相當可觀，也會耗費掉相當大的硬體資源。Docker 只虛擬化軟體的優勢，就是可以在幾秒內就啟動服務，耗費資源也相當少，還省去了建立環境的時間。</p>\n<h2>Docker Hub</h2>\n<blockquote>\n<p>Git 有 GitHub，Docker 有 Docker Hub</p>\n</blockquote>\n<p>Docker Hub 是 Docker 官方用來存放 Image 的倉庫 (Registry)，使用者也可以自架 Registry，但是如果未指定 Registry，Docker 預設會去找 Docker Hub 上的 Image。</p>\n<h2>Image</h2>\n<p>Image 通常可以是一個系統，也可以是一個已經安裝好特定執行環境 (像是 JAVA) 的系統。系統部分最常見的會是用 alpine linux，這是一個非常小的項目，只有一個系統，可以讓你在幾秒內就可以啟動服務，許多執行環境也會建構在這個系統上。現在可以先去 Docker Hub 上看看幾個前幾名的 Image，大概就會比較清楚 Image 的功用。</p>\n<p>Docker Image 可以由下列幾方式取得：</p>\n<ul>\n<li>從 Docker Hub 上下載</li>\n<li>由 Dockerfile 構建</li>\n<li>從其他電腦 import</li>\n</ul>\n<h2>Container</h2>\n<p>Docker 用 Image 創建 Container，也就是說，Container 是 Image 的實例，Container 基本上就是一個完整的作業系統，可以執行任何的程式。</p>\n<h2>Docker Run</h2>\n<p>我們簡單創建一個 Ubuntu 的 Container，並且啟動它：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run ubuntu</code></pre></div>\n<p>執行後可以看到 Docker 自動從 Docker Hub 上下載 Ubuntu 的 Image，但是開始執行後卻甚麼都沒發生就結束了。這是因為 Ubuntu 的 Image 預設是啟動一個 Shell，如果沒有 Attach 到 Sheel 上，Container 馬上就結束了。</p>\n<p>所以如果我們要 Attach 到 Ubuntu 的 Shell 上，可以這樣執行：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -it ubuntu</code></pre></div>\n<p>執行應該就會看到我們到 ubuntu 的 Shell 裡。</p>\n<h2>啟動一個網頁服務</h2>\n<p>Nginx 有官方的 Hello Image，可以更清楚的看到 Container 有在執行 Nginx 服務。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -p <span class=\"token number\">8080</span>:80 -d nginxdemos/hello</code></pre></div>\n<p>上面多了一個 <code class=\"language-text\">-p</code> 的參數，後面跟上 <code class=\"language-text\">8080:80</code>，意思是本機的 8080 Port 對到容器的 80 Port，這樣就可以讓我們在本機的 8080 Port 上看到 Nginx 的網頁了。</p>\n<h2>列出、刪除容器</h2>\n<p>列出正在執行的容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">ps</span></code></pre></div>\n<p>列出所有容器，包含已經停止的容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> -a</code></pre></div>\n<p>刪除容器，若是尚未停止的容器則無法刪除：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token operator\">&lt;</span>container_id<span class=\"token operator\">></span></code></pre></div>\n<p>加上 <code class=\"language-text\">-f</code> 參數，可強制刪除執行中的容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> -f <span class=\"token operator\">&lt;</span>container_id<span class=\"token operator\">></span></code></pre></div>\n<p>強制刪除所有容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> -aq<span class=\"token variable\">)</span></span></code></pre></div>\n<h2>創建自己的 Image</h2>\n<p>要教 Docker 怎麼創建 Image，需要先建立一個 <code class=\"language-text\">Dockerfile</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> ubuntu:latest</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> apt update <span class=\"token operator\">\\</span>\n    &amp;&amp; apt install vim git -y <span class=\"token operator\">\\</span>\n    &amp;&amp; rm -rf /var/lib/apt/lists/*</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"/bin/bash\"</span>]</span></code></pre></div>\n<p>Build Image:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> build -t my-ubuntu <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>注意上面的指令的最後面有一個 <code class=\"language-text\">.</code>，代表 Build 這個目錄。<code class=\"language-text\">-t</code> 的參數則是 Image 的名稱，或是稱作 Tag。</p>","rawMarkdownBody":"\nDocker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。\n\n<!--more-->\n\n## Docker v.s. VM\n\n入門 Docker 最常見的問題就是，Docker 和 VM 差在哪裡？這個問題不難理解，VM 「虛擬機」，顧名思義是虛擬化「硬體」。而 Docker 則是只虛擬化作業系統，或是稱作「軟體」。\n\n大家都應該知道每創建一個虛擬機，都會耗費掉數分鐘的時間，若還要安裝環境，那耗費的時間則會相當可觀，也會耗費掉相當大的硬體資源。Docker 只虛擬化軟體的優勢，就是可以在幾秒內就啟動服務，耗費資源也相當少，還省去了建立環境的時間。\n\n## Docker Hub\n\n> Git 有 GitHub，Docker 有 Docker Hub\n\nDocker Hub 是 Docker 官方用來存放 Image 的倉庫 (Registry)，使用者也可以自架 Registry，但是如果未指定 Registry，Docker 預設會去找 Docker Hub 上的 Image。\n\n## Image\n\nImage 通常可以是一個系統，也可以是一個已經安裝好特定執行環境 (像是 JAVA) 的系統。系統部分最常見的會是用 alpine linux，這是一個非常小的項目，只有一個系統，可以讓你在幾秒內就可以啟動服務，許多執行環境也會建構在這個系統上。現在可以先去 Docker Hub 上看看幾個前幾名的 Image，大概就會比較清楚 Image 的功用。\n\nDocker Image 可以由下列幾方式取得：\n\n- 從 Docker Hub 上下載\n- 由 Dockerfile 構建\n- 從其他電腦 import\n\n## Container\n\nDocker 用 Image 創建 Container，也就是說，Container 是 Image 的實例，Container 基本上就是一個完整的作業系統，可以執行任何的程式。\n\n## Docker Run\n\n我們簡單創建一個 Ubuntu 的 Container，並且啟動它：\n\n```bash\ndocker run ubuntu\n```\n\n執行後可以看到 Docker 自動從 Docker Hub 上下載 Ubuntu 的 Image，但是開始執行後卻甚麼都沒發生就結束了。這是因為 Ubuntu 的 Image 預設是啟動一個 Shell，如果沒有 Attach 到 Sheel 上，Container 馬上就結束了。\n\n所以如果我們要 Attach 到 Ubuntu 的 Shell 上，可以這樣執行：\n\n```bash\ndocker run -it ubuntu\n```\n\n執行應該就會看到我們到 ubuntu 的 Shell 裡。\n\n## 啟動一個網頁服務\n\nNginx 有官方的 Hello Image，可以更清楚的看到 Container 有在執行 Nginx 服務。\n\n```bash\ndocker run -p 8080:80 -d nginxdemos/hello\n```\n\n上面多了一個 `-p` 的參數，後面跟上 `8080:80`，意思是本機的 8080 Port 對到容器的 80 Port，這樣就可以讓我們在本機的 8080 Port 上看到 Nginx 的網頁了。\n\n## 列出、刪除容器\n\n列出正在執行的容器：\n\n```bash\ndocker ps\n```\n\n列出所有容器，包含已經停止的容器：\n\n```bash\ndocker ps -a\n```\n\n刪除容器，若是尚未停止的容器則無法刪除：\n\n```bash\ndocker rm <container_id>\n```\n\n加上 `-f` 參數，可強制刪除執行中的容器：\n\n```bash\ndocker rm -f <container_id>\n```\n\n強制刪除所有容器：\n\n```bash\ndocker rm $(docker ps -aq)\n```\n\n## 創建自己的 Image\n\n要教 Docker 怎麼創建 Image，需要先建立一個 `Dockerfile`：\n\n```dockerfile\nFROM ubuntu:latest\n\nRUN apt update \\\n    && apt install vim git -y \\\n    && rm -rf /var/lib/apt/lists/*\n\nCMD [\"/bin/bash\"]\n```\n\nBuild Image:\n\n```bash\ndocker build -t my-ubuntu .\n```\n\n注意上面的指令的最後面有一個 `.`，代表 Build 這個目錄。`-t` 的參數則是 Image 的名稱，或是稱作 Tag。\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Docker/docker.md","excerpt":"Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。 Docker v.s. VM 入門 Docker 最常見的問題就是，Docker 和 VM 差在哪裡？這個問題不難理解，VM 「虛擬機」，顧名思義是虛擬化「硬體」。而 Docker 則是只虛擬…","frontmatter":{"title":"Docker","date":"2021-08-25T18:31:57.000Z","draft":false,"tags":["docker"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/a45b7e65-d6dd-4ef5-23b4-44e2090c5b00/public","description":"Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。"}}},{"node":{"id":"0328ae6c-1fa1-50d8-aec1-a55575fe59b5","html":"<p>Cloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。</p>\n<p>我覺得目前的缺點就是網路上相關的資料比較少，遇到問題很難找到資料參考，因為他其實主要是 Cloudflare 的一項零信任服務，目標客群都是一些厲害的網管，所以官方寫的文件也都很深奧，如果是新手可能會頭昏眼花。</p>\n<!--more-->\n<p>這一項服務可以先不用帳號就能試用，不過就不能自訂 Domain，我會先介紹免登入的，再介紹要登入的。第一步還是要在本地先安裝環境。</p>\n<h2>安裝 cloudflared</h2>\n<h3>全系統適用</h3>\n<p>注意 Cloudflare 後面多了一個 <code class=\"language-text\">d</code>，這是他連上 Tunnel 的必要程式，是用 Go 編寫，安裝方式就是到<a href=\"https://github.com/cloudflare/cloudflared/releases\">官方 Github</a>下載符合自己環境的執行檔。</p>\n<h3>macOS</h3>\n<p>mac 可以用 Homebrew 安裝：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">brew install cloudflare/cloudflare/cloudflared</code></pre></div>\n<h3>Windows</h3>\n<p>Windows 永遠是最麻煩的，下載完執行檔後，隨便丟到一個資料夾，然後加到 PATH 裡。</p>\n<h3>Update</h3>\n<p>要更新這個執行檔，只要 Run 下面的指令，另外，Windows 不支援自動更新，要更新就只能手動下載覆蓋：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared update</code></pre></div>\n<h2>免登入測試 Tunnel</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel --url http://localhost:8080</code></pre></div>\n<p>執行上面的指令，就可以將本地電腦的 8080 port 用 http 公開到網路上，應該會看到輸出中會給一串個 <code class=\"language-text\">*-*-*.trycloudflare.com</code> 的網址，現在只要訪問那個網址，就可以發現本地的網頁已經可以從全網連到，不需註冊，也不用設定複雜的 Domain，還不限流量。</p>\n<h2>登入 Cloudflare</h2>\n<p>第一步就是先登入 Cloudflare 的帳號，也要有一個已經託管給 Cloudflare 的 Domain：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel login</code></pre></div>\n<p>執行這個命令後，應該會跳出瀏覽器授權，如果沒有跳出，就手動複製提供的授權網址登入 Cloudflare 帳號。</p>\n<h2>創建並使用 Tunnel</h2>\n<p>登入完成後就可以開始創建通道，創建只會在本地產生一些文件，並不會有任何連線的動作，可以放心執行：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel create &lt;Name&gt;</code></pre></div>\n<p>創建完成後，Cloudflare 會給一組 UUID，可以看一下有沒有創建成功：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel list</code></pre></div>\n<p>如果要刪除就是 Delete：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel delete &lt;Name or UUID&gt;</code></pre></div>\n<h2>DNS 設定</h2>\n<p>在創建 Tunnel 後，Cloudflare 會將剛剛創建隧道時產生的 UUID 綁定到 <code class=\"language-text\">&lt;UUID>.cfargotunnel.com</code> 這個 Domain，不過 Cloudflare 會擋掉用這個 Domain 直接連線的流量，所以我們要把我們的 Domain 新增一個 CNAME 紀錄，把流量往這邊導。</p>\n<p>有兩個方法可以設定 CNAME，一個是自己去 Cloudflare 的官網設定：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210813165733.png\" alt=\"img\"></p>\n<p>另一個是直接用指令設定，快又方便，把後面的 domain 改成自己想要綁定的：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel route dns &lt;Name or UUID&gt; test.example.com</code></pre></div>\n<p>打完後如果不放心，還是可以自己到 Cloudflare 的 Dns 設定看一下有沒有設定完成，應該會看到跟上圖一樣產生一個 CNAME Record。</p>\n<h2>Tunnel Config</h2>\n<p>下面是最簡單的 Config 範例，這是一個 <code class=\"language-text\">yml</code> 檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">tunnel</span><span class=\"token punctuation\">:</span> &lt;Name<span class=\"token punctuation\">></span>\n\n<span class=\"token key atrule\">ingress</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">hostname</span><span class=\"token punctuation\">:</span> test.example.com\n    <span class=\"token key atrule\">service</span><span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">:</span>//localhost<span class=\"token punctuation\">:</span><span class=\"token number\">8080</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">service</span><span class=\"token punctuation\">:</span> http_status<span class=\"token punctuation\">:</span><span class=\"token number\">404</span></code></pre></div>\n<p>上面會把 8080 的 HTTP 流量導到 <code class=\"language-text\">domain.example.com</code>，使用剛剛創建的 Tunnel。</p>\n<p>最後一行一定要有一個可以接受所有流量的 Service，不然服務會不能啟動，這裡全部往 404 導。</p>\n<h2>Run Tunnel</h2>\n<p>最後一步，加上 config 的參數，把剛剛的 yml 檔喂給 Cloudflare，就可以啟動通道了：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel --config test.yml run</code></pre></div>\n<h2>後記</h2>\n<p>這篇只介紹了如何創建一個 Http 的 Tunnel，如果要開其他的 TCP Port，還需要其他的設定，而且在 Client 端也會需要安裝 Cloudflared，所以我留到下一篇在介紹。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://developers.cloudflare.com/cloudflare-one/\">Cloudflare for Teams documentation</a></li>\n</ul>","rawMarkdownBody":"\nCloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。\n\n我覺得目前的缺點就是網路上相關的資料比較少，遇到問題很難找到資料參考，因為他其實主要是 Cloudflare 的一項零信任服務，目標客群都是一些厲害的網管，所以官方寫的文件也都很深奧，如果是新手可能會頭昏眼花。\n\n<!--more-->\n\n這一項服務可以先不用帳號就能試用，不過就不能自訂 Domain，我會先介紹免登入的，再介紹要登入的。第一步還是要在本地先安裝環境。\n\n## 安裝 cloudflared\n\n### 全系統適用\n\n注意 Cloudflare 後面多了一個 `d`，這是他連上 Tunnel 的必要程式，是用 Go 編寫，安裝方式就是到[官方 Github](https://github.com/cloudflare/cloudflared/releases)下載符合自己環境的執行檔。\n\n### macOS\n\nmac 可以用 Homebrew 安裝：\n\n```sh\nbrew install cloudflare/cloudflare/cloudflared\n```\n\n### Windows\n\nWindows 永遠是最麻煩的，下載完執行檔後，隨便丟到一個資料夾，然後加到 PATH 裡。\n\n### Update\n\n要更新這個執行檔，只要 Run 下面的指令，另外，Windows 不支援自動更新，要更新就只能手動下載覆蓋：\n\n```sh\ncloudflared update\n```\n\n## 免登入測試 Tunnel\n\n```sh\ncloudflared tunnel --url http://localhost:8080\n```\n\n執行上面的指令，就可以將本地電腦的 8080 port 用 http 公開到網路上，應該會看到輸出中會給一串個 `*-*-*.trycloudflare.com` 的網址，現在只要訪問那個網址，就可以發現本地的網頁已經可以從全網連到，不需註冊，也不用設定複雜的 Domain，還不限流量。\n\n## 登入 Cloudflare\n\n第一步就是先登入 Cloudflare 的帳號，也要有一個已經託管給 Cloudflare 的 Domain：\n\n```sh\ncloudflared tunnel login\n```\n\n執行這個命令後，應該會跳出瀏覽器授權，如果沒有跳出，就手動複製提供的授權網址登入 Cloudflare 帳號。\n\n## 創建並使用 Tunnel\n\n登入完成後就可以開始創建通道，創建只會在本地產生一些文件，並不會有任何連線的動作，可以放心執行：\n\n```sh\ncloudflared tunnel create <Name>\n```\n\n創建完成後，Cloudflare 會給一組 UUID，可以看一下有沒有創建成功：\n\n```sh\ncloudflared tunnel list\n```\n\n如果要刪除就是 Delete：\n\n```sh\ncloudflared tunnel delete <Name or UUID>\n```\n\n## DNS 設定\n\n在創建 Tunnel 後，Cloudflare 會將剛剛創建隧道時產生的 UUID 綁定到 `<UUID>.cfargotunnel.com` 這個 Domain，不過 Cloudflare 會擋掉用這個 Domain 直接連線的流量，所以我們要把我們的 Domain 新增一個 CNAME 紀錄，把流量往這邊導。\n\n有兩個方法可以設定 CNAME，一個是自己去 Cloudflare 的官網設定：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210813165733.png)\n\n另一個是直接用指令設定，快又方便，把後面的 domain 改成自己想要綁定的：\n\n```sh\ncloudflared tunnel route dns <Name or UUID> test.example.com\n```\n\n打完後如果不放心，還是可以自己到 Cloudflare 的 Dns 設定看一下有沒有設定完成，應該會看到跟上圖一樣產生一個 CNAME Record。\n\n## Tunnel Config\n\n下面是最簡單的 Config 範例，這是一個 `yml` 檔案：\n\n```yml\ntunnel: <Name>\n\ningress:\n  - hostname: test.example.com\n    service: http://localhost:8080\n  - service: http_status:404\n```\n\n上面會把 8080 的 HTTP 流量導到 `domain.example.com`，使用剛剛創建的 Tunnel。\n\n最後一行一定要有一個可以接受所有流量的 Service，不然服務會不能啟動，這裡全部往 404 導。\n\n## Run Tunnel\n\n最後一步，加上 config 的參數，把剛剛的 yml 檔喂給 Cloudflare，就可以啟動通道了：\n\n```sh\ncloudflared tunnel --config test.yml run\n```\n\n## 後記\n\n這篇只介紹了如何創建一個 Http 的 Tunnel，如果要開其他的 TCP Port，還需要其他的設定，而且在 Client 端也會需要安裝 Cloudflared，所以我留到下一篇在介紹。\n\n## Reference\n\n- [Cloudflare for Teams documentation](https://developers.cloudflare.com/cloudflare-one/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/Cloudflare Tunnel.md","excerpt":"Cloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。 我覺得目前的缺點就是網路上相關的資料比較少，遇到問題很難找到資料參考，因為他其實主要是 Cloudflare 的一項零信任服務，目標…","frontmatter":{"title":"Cloudflare Tunnel","date":"2021-08-13T07:17:39.000Z","draft":false,"tags":["cloudflare","tunnel","teams","cloudflare-tunnel"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/00e85cf1-4c03-45ea-004c-f61e6216d400/public","description":"Cloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。"}}},{"node":{"id":"acc7e2df-e6e5-5c7a-aa49-4f23527be703","html":"<p>簡單記錄我所認知的 A320 的一些程序。</p>\n<!--more-->\n<blockquote>\n<p>注意這些都不是標準程序，只是我自己亂理解的，也省去蠻多步驟，基本上就是能起讓飛機動起來，標準程序肯定是更複雜的。</p>\n</blockquote>\n<h2>啟動飛機前檢查</h2>\n<p><del>模擬器中跳過還是可以飛</del></p>\n<ol>\n<li>Engine Master 1 and 2 Switch -> OFF\n<ul>\n<li>主引擎 1, 2 都關閉</li>\n</ul>\n</li>\n<li>Engine Mode Selector -> NORM\n<ul>\n<li>引擎模式在 Normal 位置</li>\n</ul>\n</li>\n<li>Weather Radar -> OFF\n<ul>\n<li>關閉氣象雷達</li>\n</ul>\n</li>\n<li>Landing Gear -> Down\n<ul>\n<li>機輪放下</li>\n</ul>\n</li>\n<li>Wipers -> Both OFF\n<ul>\n<li>兩個雨刷都關閉</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/7e29f7e1-bf0b-44d4-7589-29286ed81b00/large\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/ca5109ba-4baf-40e3-850e-ee4002882c00/large\" alt=\"img\"></p>\n<h2>啟動飛機</h2>\n<ol>\n<li>Batt 1 and 2 -> ON</li>\n<li>EXT Power -> ON\n<ul>\n<li>啟動外部電源</li>\n<li>這時應該可以看到所有儀表亮起</li>\n</ul>\n</li>\n<li>APU Fire Test\n<ul>\n<li>APU 滅火測試</li>\n</ul>\n</li>\n<li>APU Master and wait 3 sec -> ON\n<ul>\n<li>打開 APU 主開關，並等待 3 秒</li>\n</ul>\n</li>\n<li>APU START -> ON\n<ul>\n<li>發動 APU</li>\n</ul>\n</li>\n<li>Wait for APU START -> Green \"AVAIL\"\n<ul>\n<li>等 APU 發動完成</li>\n</ul>\n</li>\n<li>APU BLEED -> ON\n<ul>\n<li>開啟 APU 供給氣壓</li>\n</ul>\n</li>\n<li>EXT Power -> OFF\n<ul>\n<li>移除外部電源</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/bcc428a6-c065-4bc3-0d19-ad204b860700/large\" alt=\"img\"></p>\n<h2>Overhead Panel 上方儀表</h2>\n<p>基本上，由左至右，由下而上的檢查</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4aa17d2f-419c-40e6-09f8-e31ca2833a00/large\" alt=\"img\"></p>\n<h3>左邊那排</h3>\n<ol>\n<li>CREW SUPPLY -> ON\n<ul>\n<li>打開組員氧氣供給</li>\n</ul>\n</li>\n<li>ADIRS 1, 2, 3 -> NAV\n<ul>\n<li>開啟三個慣性導航，需等待 6-7 分鐘校準</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b25f2e34-5ff9-4534-4fc2-927961a5ce00/large\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/16fb299e-1847-4767-8093-aa0d058cd400/large\" alt=\"img\"></p>\n<h3>中間那排</h3>\n<ol>\n<li>NAV &#x26; LOGO Light -> ON</li>\n<li>OVHD INTEG LT -> AS REQ.</li>\n<li>DOME LT -> AS REQ.</li>\n<li>ANN LT TEST</li>\n<li>EMER EXIT LT -> ARM</li>\n<li>SEAT BELTS -> ON</li>\n<li>NO SMOKING -> ON</li>\n<li>ALL PUMP -> ON</li>\n<li>ENG 1 FIRE TEST</li>\n<li>ENG 2 FIRE TEST</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/e5f05a70-bc36-4bc3-fff2-61f413e6b900/large\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/613ca5d3-3519-4c5d-cb82-4f9371e1d500/large\" alt=\"img\"></p>\n<h3>右邊那排</h3>\n<p>基本上不用動</p>\n<h2>MCDU 飛行電腦</h2>\n<p>在等待導航校準時，來設定飛行電腦。設定飛行電腦有一個口訣：</p>\n<blockquote>\n<p>D > I > F > S > R > I > P > P</p>\n</blockquote>\n<ul>\n<li>DATA</li>\n<li>INIT A</li>\n<li>F-PLN</li>\n<li>SEC PLAN</li>\n<li>RAD NAV</li>\n<li>INIT B</li>\n<li>PREF</li>\n<li>PROG</li>\n</ul>\n<blockquote>\n<p>飛行電腦設定蠻複雜的，本文就先跳過詳細步驟，專注在冷操到起飛。</p>\n</blockquote>\n<h2>後推 and 啟動引擎前檢查</h2>\n<p>記得等 IRS 校準完後再後推。</p>\n<ol>\n<li>申請後推</li>\n<li>BECON Light -> ON\n<ul>\n<li>啟動 BECAON 燈</li>\n</ul>\n</li>\n<li>Trust Levers -> IDLE\n<ul>\n<li>確定推力桿在 IDLE</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f3d16c92-7e28-4b76-c106-458211015c00/public\" alt=\"img\"></p>\n<p>在 MSFS 的 FlyByWire 中可以用旁邊的 FlyPad 申請後推。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/71f815a8-11e0-4d0b-38a5-2de486a4e000/public\" alt=\"img\"></p>\n<h2>啟動引擎</h2>\n<ol>\n<li>ENG MODE selector -> IGN/START\n<ul>\n<li>把 ENG MODE selector 轉到右邊的啟動引擎模式</li>\n</ul>\n</li>\n<li>ENGINE 2 START -> ON\n<ul>\n<li>啟動右邊的 2 號引擎</li>\n<li>我也不知道為甚麼都是先啟動 2 號引擎</li>\n<li>等待發動完成後再發動 1 號引擎</li>\n<li>發動時應監控引擎數據，19% N1, 68% N2, 520°C EGT, 290 kg/h FF，等待 2 號引擎 AVAIL 字樣出現</li>\n</ul>\n</li>\n<li>ENGINE 1 START -> ON\n<ul>\n<li>啟動左邊的 1 號引擎，重複第 2 步直到 1 號引擎 AVAIL 字樣出現</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/1e82de0e-18d0-402e-b279-780fe5f6b800/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d164d67d-9afb-4bd6-2eb9-835d7fe24300/public\" alt=\"img\"></p>\n<h2>啟動引擎後</h2>\n<ol>\n<li>ENG MODE selectgor -> NORM\n<ul>\n<li>引擎模式轉回中間 NORM</li>\n</ul>\n</li>\n<li>APU Bleed -> OFF\n<ul>\n<li>關閉 APU 供氣</li>\n</ul>\n</li>\n<li>APU MASTER -> OFF\n<ul>\n<li>關閉 APU</li>\n</ul>\n</li>\n<li>FLAPS lever -> SET TAKEOFF POSITION\n<ul>\n<li>放出襟翼到起飛需要的位置</li>\n</ul>\n</li>\n</ol>\n<h2>滑行 Taxi</h2>\n<ol>\n<li>NOSE Light -> Taxi\n<ul>\n<li>開啟滑行燈</li>\n</ul>\n</li>\n<li>RWY TURN OFF -> ON\n<ul>\n<li>開啟脫離跑道燈 (轉彎燈)</li>\n</ul>\n</li>\n<li>PARK BRK -> OFF\n<ul>\n<li>關閉手煞車</li>\n</ul>\n</li>\n<li>AUTO BRK MAX -> ON\n<ul>\n<li>開啟最大自動煞車</li>\n</ul>\n</li>\n</ol>\n<h2>起飛</h2>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://www.youtube.com/channel/UCDKKDx4mNVI7vONL1vqTx7g\">教官我想飛</a></li>\n<li><a href=\"https://www.youtube.com/channel/UCOHc8xzWD25Nn-snDBJUMGQ\">機師阿楷</a></li>\n<li><a href=\"https://github.com/flybywiresim/manuals/blob/master/pdf/A32NX%20Documentation/FBW%20A32NX%20Checklist.pdf\">FBW A32NX Checklist.pdf</a></li>\n<li><a href=\"https://github.com/flybywiresim/manuals/blob/master/pdf/A32NX%20Documentation/FBW%20A32NX%20SOP.pdf\">FBW A32NX SOP.pdf</a></li>\n</ul>","rawMarkdownBody":"\n簡單記錄我所認知的 A320 的一些程序。\n\n<!--more-->\n\n> 注意這些都不是標準程序，只是我自己亂理解的，也省去蠻多步驟，基本上就是能起讓飛機動起來，標準程序肯定是更複雜的。\n\n## 啟動飛機前檢查\n\n~~模擬器中跳過還是可以飛~~\n\n1. Engine Master 1 and 2 Switch -> OFF\n   - 主引擎 1, 2 都關閉\n2. Engine Mode Selector -> NORM\n   - 引擎模式在 Normal 位置\n3. Weather Radar -> OFF\n   - 關閉氣象雷達\n4. Landing Gear -> Down\n   - 機輪放下\n5. Wipers -> Both OFF\n   - 兩個雨刷都關閉\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/7e29f7e1-bf0b-44d4-7589-29286ed81b00/large)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/ca5109ba-4baf-40e3-850e-ee4002882c00/large)\n\n## 啟動飛機\n\n1. Batt 1 and 2 -> ON\n2. EXT Power -> ON\n   - 啟動外部電源\n   - 這時應該可以看到所有儀表亮起\n3. APU Fire Test\n   - APU 滅火測試\n4. APU Master and wait 3 sec -> ON\n   - 打開 APU 主開關，並等待 3 秒\n5. APU START -> ON\n   - 發動 APU\n6. Wait for APU START -> Green \"AVAIL\"\n   - 等 APU 發動完成\n7. APU BLEED -> ON\n   - 開啟 APU 供給氣壓\n8. EXT Power -> OFF\n   - 移除外部電源\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/bcc428a6-c065-4bc3-0d19-ad204b860700/large)\n\n## Overhead Panel 上方儀表\n\n基本上，由左至右，由下而上的檢查\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4aa17d2f-419c-40e6-09f8-e31ca2833a00/large)\n\n### 左邊那排\n\n1. CREW SUPPLY -> ON\n   - 打開組員氧氣供給\n2. ADIRS 1, 2, 3 -> NAV\n   - 開啟三個慣性導航，需等待 6-7 分鐘校準\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b25f2e34-5ff9-4534-4fc2-927961a5ce00/large)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/16fb299e-1847-4767-8093-aa0d058cd400/large)\n\n### 中間那排\n\n1. NAV & LOGO Light -> ON\n2. OVHD INTEG LT -> AS REQ.\n3. DOME LT -> AS REQ.\n4. ANN LT TEST\n5. EMER EXIT LT -> ARM\n6. SEAT BELTS -> ON\n7. NO SMOKING -> ON\n8. ALL PUMP -> ON\n9. ENG 1 FIRE TEST\n10. ENG 2 FIRE TEST\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/e5f05a70-bc36-4bc3-fff2-61f413e6b900/large)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/613ca5d3-3519-4c5d-cb82-4f9371e1d500/large)\n\n### 右邊那排\n\n基本上不用動\n\n## MCDU 飛行電腦\n\n在等待導航校準時，來設定飛行電腦。設定飛行電腦有一個口訣：\n\n> D > I > F > S > R > I > P > P\n\n- DATA\n- INIT A\n- F-PLN\n- SEC PLAN\n- RAD NAV\n- INIT B\n- PREF\n- PROG\n\n> 飛行電腦設定蠻複雜的，本文就先跳過詳細步驟，專注在冷操到起飛。\n\n## 後推 and 啟動引擎前檢查\n\n記得等 IRS 校準完後再後推。\n\n1. 申請後推\n2. BECON Light -> ON\n   - 啟動 BECAON 燈\n3. Trust Levers -> IDLE\n   - 確定推力桿在 IDLE\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f3d16c92-7e28-4b76-c106-458211015c00/public)\n\n在 MSFS 的 FlyByWire 中可以用旁邊的 FlyPad 申請後推。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/71f815a8-11e0-4d0b-38a5-2de486a4e000/public)\n\n## 啟動引擎\n\n1. ENG MODE selector -> IGN/START\n   - 把 ENG MODE selector 轉到右邊的啟動引擎模式\n2. ENGINE 2 START -> ON\n   - 啟動右邊的 2 號引擎\n   - 我也不知道為甚麼都是先啟動 2 號引擎\n   - 等待發動完成後再發動 1 號引擎\n   - 發動時應監控引擎數據，19% N1, 68% N2, 520°C EGT, 290 kg/h FF，等待 2 號引擎 AVAIL 字樣出現\n3. ENGINE 1 START -> ON\n   - 啟動左邊的 1 號引擎，重複第 2 步直到 1 號引擎 AVAIL 字樣出現\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/1e82de0e-18d0-402e-b279-780fe5f6b800/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d164d67d-9afb-4bd6-2eb9-835d7fe24300/public)\n\n## 啟動引擎後\n\n1. ENG MODE selectgor -> NORM\n   - 引擎模式轉回中間 NORM\n2. APU Bleed -> OFF\n   - 關閉 APU 供氣\n3. APU MASTER -> OFF\n   - 關閉 APU\n4. FLAPS lever -> SET TAKEOFF POSITION\n   - 放出襟翼到起飛需要的位置\n\n## 滑行 Taxi\n\n1. NOSE Light -> Taxi\n   - 開啟滑行燈\n2. RWY TURN OFF -> ON\n   - 開啟脫離跑道燈 (轉彎燈)\n3. PARK BRK -> OFF\n   - 關閉手煞車\n4. AUTO BRK MAX -> ON\n   - 開啟最大自動煞車\n\n## 起飛\n\n## Reference\n\n- [教官我想飛](https://www.youtube.com/channel/UCDKKDx4mNVI7vONL1vqTx7g)\n- [機師阿楷](https://www.youtube.com/channel/UCOHc8xzWD25Nn-snDBJUMGQ)\n- [FBW A32NX Checklist.pdf](https://github.com/flybywiresim/manuals/blob/master/pdf/A32NX%20Documentation/FBW%20A32NX%20Checklist.pdf)\n- [FBW A32NX SOP.pdf](https://github.com/flybywiresim/manuals/blob/master/pdf/A32NX%20Documentation/FBW%20A32NX%20SOP.pdf)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Flight/A320 Note.md","excerpt":"簡單記錄我所認知的 A320 的一些程序。 注意這些都不是標準程序，只是我自己亂理解的，也省去蠻多步驟，基本上就是能起讓飛機動起來，標準程序肯定是更複雜的。 啟動飛機前檢查 模擬器中跳過還是可以飛 Engine Master 1 and 2 Switch -> OFF 主引擎 1, 2 都關閉 Engine Mode Selector -> NORM 引擎模式在 Normal 位置 Weathe…","frontmatter":{"title":"A320neo 冷艙到飛行","date":"2021-07-21T14:08:20.000Z","draft":false,"tags":["a320neo","airbus","msfs"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/06a43a08-dc77-48eb-9f4a-f47a29566900/public","description":"簡單記錄我所認知的 A320 的一些程序。"}}},{"node":{"id":"e1f2136a-0c65-5dce-bf47-743229e64ad2","html":"<p>打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210716235146.png\" alt=\"img\"></p>\n<!--more-->\n<p>我們今天主要會用到下面的幾樣技術：</p>\n<ol>\n<li><a href=\"https://zsh.sourceforge.io/\">zsh</a></li>\n<li><a href=\"https://github.com/romkatv/powerlevel10k\">powerlevel10K</a></li>\n<li><a href=\"https://zimfw.sh/#install\">zim</a></li>\n<li><a href=\"https://www.nerdfonts.com/\">Nerd Fonts</a></li>\n</ol>\n<p>看到這幾項技術其實可以自己先去研究一下，看看這些技術是不是自己需要的，以免亂裝一堆東西，搞的自己 Terminal 亂七八糟無法復原。另外，Windows 應該是無法安裝的，至少我自己是沒辦法，不過 WSL 倒是可以玩成這樣，畢竟就是 Linux 麻。</p>\n<p>很多人會推薦在 mac 上安裝 iTerm，我自己是沒裝，我覺得 mac 內建的 Terminal 足夠好用，沒必要安裝其他 Terminal。</p>\n<h2>Font</h2>\n<p>好看的第一步就是有好看的字體，<a href=\"https://www.nerdfonts.com/\">Nerd Fonts</a> 這個專案把一些開發者常用的字體，加上一些在 Terminal 中會用到的一些 icon 和 symbol，常見的 <code class=\"language-text\">Hack</code>、<code class=\"language-text\">Jetbrains Mono</code> 都有在這個專案裡。到 Nerd Fonts 的官網可以下載到這些字體，注意不要到字體們原本的管網下載，要到 Nerd Fonts 下載包含特殊符號的字體。</p>\n<p><img src=\"https://www.nerdfonts.com/assets/img/sankey-glyphs-combined-diagram.png\" alt=\"img\"></p>\n<p>下載安裝好字體後，記得到自己的 Terminal 中變更字體，選擇有包含 Nerd 的字體，以免等等字體都無法顯示，這部分教學我懶得寫，所以附一張圖：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717112205.png\" alt=\"img\"></p>\n<h2>zsh</h2>\n<p>zsh 可以說是 bash 的進階版，提供客製化自己在 Terminal 中想要的主題和功能。要安裝 zsh 通常各個系統都不一樣，自己上網根據系統安裝即可。安裝完成後也要將預設 shell 改成 zsh。</p>\n<p>ubuntu:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token function\">zsh</span>\nchsh -s /bin/zsh <span class=\"token variable\">$USRR</span></code></pre></div>\n<h2>powerlevel10k</h2>\n<p>powerlevel10k 是一個 zsh 主題，提供可高客製化的主題和客製化嚮導，可以簡單地就把 Terminal 變成自己喜歡的模樣，也是本文最重要的部分。powerlevel10k 提供許多安裝方法，可以透過 oh-my-zsh，也可以用腳本安裝，我是認為用腳本安裝就好，可以不用用到 oh-my-zsh，因我們之後會提到 zim 就提供許多可以替代 oh-my-zsh 的功能。</p>\n<p>用腳本安裝 powerlevel10k：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> clone --depth<span class=\"token operator\">=</span><span class=\"token number\">1</span> https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k\n<span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'source ~/powerlevel10k/powerlevel10k.zsh-theme'</span> <span class=\"token operator\">>></span>~/.zshrc</code></pre></div>\n<p>安裝方式可能會因版本變動而不一樣，建議還是到官方 Github 上看一下安裝方式。</p>\n<p>安裝完成後第一次進到 Terminal 會遇到一個安裝嚮導，可以根據自己喜好設定主題樣式。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717214526.gif\" alt=\"img\"></p>\n<p>完成到這裡，Terminal 應該已經變得美美的，如果遇到亂碼，可能是字型沒有調整好。</p>\n<p>powerlevel10k 會提供一個 <code class=\"language-text\">p10k</code> 的命令，可以用於重新啟動嚮導：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717174430.png\" alt=\"img\"></p>\n<h2>Zim</h2>\n<p>全名 Zsh IMproved FrameWork，主要是提供一些方便的 zsh plugin，像是自動補全、語法高亮等，如果是希望好看，不用好用，Zim 就可以不用安裝。</p>\n<p>安裝 Zim 也很簡單，只要 Run 下面的腳本就可以：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> -fsSL https://raw.githubusercontent.com/zimfw/install/master/install.zsh <span class=\"token operator\">|</span> <span class=\"token function\">zsh</span></code></pre></div>\n<p>到這就算是全部完成，如果有發現更多好用的 Terminal 工具，記得分享給我。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://zsh.sourceforge.io/\">zsh</a></li>\n<li><a href=\"https://github.com/romkatv/powerlevel10k\">powerlevel10K</a></li>\n<li><a href=\"https://zimfw.sh/#install\">zim</a></li>\n<li><a href=\"https://www.nerdfonts.com/\">Nerd Fonts</a></li>\n</ul>","rawMarkdownBody":"\n打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210716235146.png)\n\n<!--more-->\n\n我們今天主要會用到下面的幾樣技術：\n\n1. [zsh](https://zsh.sourceforge.io/)\n2. [powerlevel10K](https://github.com/romkatv/powerlevel10k)\n3. [zim](https://zimfw.sh/#install)\n4. [Nerd Fonts](https://www.nerdfonts.com/)\n\n看到這幾項技術其實可以自己先去研究一下，看看這些技術是不是自己需要的，以免亂裝一堆東西，搞的自己 Terminal 亂七八糟無法復原。另外，Windows 應該是無法安裝的，至少我自己是沒辦法，不過 WSL 倒是可以玩成這樣，畢竟就是 Linux 麻。\n\n很多人會推薦在 mac 上安裝 iTerm，我自己是沒裝，我覺得 mac 內建的 Terminal 足夠好用，沒必要安裝其他 Terminal。\n\n## Font\n\n好看的第一步就是有好看的字體，[Nerd Fonts](https://www.nerdfonts.com/) 這個專案把一些開發者常用的字體，加上一些在 Terminal 中會用到的一些 icon 和 symbol，常見的 `Hack`、`Jetbrains Mono` 都有在這個專案裡。到 Nerd Fonts 的官網可以下載到這些字體，注意不要到字體們原本的管網下載，要到 Nerd Fonts 下載包含特殊符號的字體。\n\n![img](https://www.nerdfonts.com/assets/img/sankey-glyphs-combined-diagram.png)\n\n下載安裝好字體後，記得到自己的 Terminal 中變更字體，選擇有包含 Nerd 的字體，以免等等字體都無法顯示，這部分教學我懶得寫，所以附一張圖：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717112205.png)\n\n## zsh\n\nzsh 可以說是 bash 的進階版，提供客製化自己在 Terminal 中想要的主題和功能。要安裝 zsh 通常各個系統都不一樣，自己上網根據系統安裝即可。安裝完成後也要將預設 shell 改成 zsh。\n\nubuntu:\n\n```bash\nsudo apt install zsh\nchsh -s /bin/zsh $USRR\n```\n\n## powerlevel10k\n\npowerlevel10k 是一個 zsh 主題，提供可高客製化的主題和客製化嚮導，可以簡單地就把 Terminal 變成自己喜歡的模樣，也是本文最重要的部分。powerlevel10k 提供許多安裝方法，可以透過 oh-my-zsh，也可以用腳本安裝，我是認為用腳本安裝就好，可以不用用到 oh-my-zsh，因我們之後會提到 zim 就提供許多可以替代 oh-my-zsh 的功能。\n\n用腳本安裝 powerlevel10k：\n\n```bash\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k\necho 'source ~/powerlevel10k/powerlevel10k.zsh-theme' >>~/.zshrc\n```\n\n安裝方式可能會因版本變動而不一樣，建議還是到官方 Github 上看一下安裝方式。\n\n安裝完成後第一次進到 Terminal 會遇到一個安裝嚮導，可以根據自己喜好設定主題樣式。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717214526.gif)\n\n完成到這裡，Terminal 應該已經變得美美的，如果遇到亂碼，可能是字型沒有調整好。\n\npowerlevel10k 會提供一個 `p10k` 的命令，可以用於重新啟動嚮導：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717174430.png)\n\n## Zim\n\n全名 Zsh IMproved FrameWork，主要是提供一些方便的 zsh plugin，像是自動補全、語法高亮等，如果是希望好看，不用好用，Zim 就可以不用安裝。\n\n安裝 Zim 也很簡單，只要 Run 下面的腳本就可以：\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/zimfw/install/master/install.zsh | zsh\n```\n\n到這就算是全部完成，如果有發現更多好用的 Terminal 工具，記得分享給我。\n\n## Reference\n\n- [zsh](https://zsh.sourceforge.io/)\n- [powerlevel10K](https://github.com/romkatv/powerlevel10k)\n- [zim](https://zimfw.sh/#install)\n- [Nerd Fonts](https://www.nerdfonts.com/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Linux/Beautiful Terminal.md","excerpt":"打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。 img 我們今天主要會用到下面的幾樣技術： zsh powerlevel10K zim Nerd Fonts 看到這幾項技術其實可以自己先去研究一下，看看這些技術是不是自己需要的，以免亂裝一堆東西，搞的自己 Terminal 亂七八糟無法復原。另外，W…","frontmatter":{"title":"Beautiful Terminal","date":"2021-07-16T15:43:07.000Z","draft":false,"tags":["terminl","zsh","zim","powerlevel","powerlevel10k","nerd-font","ubuntu","mac"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/939d8b79-aeab-465b-8bc7-fcf3cc4def00/public","description":"打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。"}}},{"node":{"id":"01f03396-06dd-573b-95a5-793a7fd2bc95","html":"<p>Markdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。</p>\n<!--more-->\n<p>我們來看看 <a href=\"https://github.com/apple/swift\">Swift</a> 的官網，可以發現 <code class=\"language-text\">[README.md](http://readme.md)</code> 這個檔案就是由 Markdown 編寫，Github 也會自動將這個檔案渲染在網頁下方。到這裡可以發現，在 Github 上的所有開源專案的文件，幾乎都是由 Markdown 編寫。</p>\n<h2>哲學</h2>\n<p>引述自 <a href=\"https://markdown.tw\">https://markdown.tw</a></p>\n<blockquote>\n<p>Markdown 的目標是實現「易讀易寫」。<br>\n不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 語法受到一些既有 text-to-HTML 格式的影響，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，然而最大靈感來源其實是純文字的電子郵件格式。<br>\n因此 Markdown 的語法全由標點符號所組成，並經過嚴謹慎選，是為了讓它們看起來就像所要表達的意思。像是在文字兩旁加上星號，看起來就像<em>強調</em>。Markdown 的清單看起來，嗯，就是清單。假如你有使用過電子郵件，區塊引言看起來就真的像是引用一段文字。</p>\n</blockquote>\n<h2>Tools</h2>\n<p>Q: 那要用什麼來寫呢？</p>\n<p>因為 Markdown 基本上也是純文字檔案，所以只要是文字編輯器都可以編輯，你要用 txt 來寫也是個不錯的方法 ❤️。</p>\n<h3>VSCode</h3>\n<p>目前最推薦的就是工程師的好夥伴 <code class=\"language-text\">VSCode</code> ，VSCode 在寫 Markdown 時，有提供即時渲染，可以快速的看到結果，而且 VSCode 應該在各位工程師的電腦裡都應該有安裝才對。</p>\n<h3>HackMD</h3>\n<p>HackMD 是一個在網頁中的 Markdown 編輯器，可以方便地在網頁中編輯和看到編寫的結果，HackMD 最厲害的功能是可以將 Markdown 轉換成簡報，用 Markdown 取代 PowerPoint？這夠帥吧！</p>\n<h3>MarkText</h3>\n<p>這是一個在 <a href=\"https://github.com/marktext/marktext\">Github</a> 上的開源專案，可以所寫所得，方便使用，但我還是比較推薦新手使用上面兩項工具，因為這東西真的太方便了，有點沒有在寫 Markdown 的感覺。</p>\n<h3>Microsoft Word</h3>\n<p>推薦指數：⭐⭐⭐⭐⭐</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=X34ZmkeZDos\">[YouTube] Why Microsoft Word is the best IDE for programming</a></li>\n</ul>\n<h2>Markdown 語法</h2>\n<!-- markdownlint-disable MD025 -->\n<h1>大標題</h1>\n<!-- markdownlint-enable MD025 -->\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token title important\"><span class=\"token punctuation\">#</span> 大標題</span></code></pre></div>\n<hr>\n<h2>次標題</h2>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h2</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token title important\"><span class=\"token punctuation\">##</span> 次標題</span></code></pre></div>\n<hr>\n<h3>次次標題</h3>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h3</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token title important\"><span class=\"token punctuation\">###</span> 次次標題</span></code></pre></div>\n<hr>\n<h2>內文</h2>\n<p>內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文</p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span>\n\n內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文</code></pre></div>\n<hr>\n<h2>斜體 粗體</h2>\n<p>內文內文內文<em>斜體</em>內文內文內文內文內文內文<br>\n內文內文內文<strong>粗體</strong>內文內文內文內文內文內文</p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">內文內文內文<span class=\"token italic\"><span class=\"token punctuation\">*</span><span class=\"token content\">斜體</span><span class=\"token punctuation\">*</span></span>內文內文內文內文內文內文  \n內文內文內文<span class=\"token bold\"><span class=\"token punctuation\">**</span><span class=\"token content\">粗體</span><span class=\"token punctuation\">**</span></span>內文內文內文內文內文內文</code></pre></div>\n<hr>\n<h2>有序清單</h2>\n<ol>\n<li>有序清單 1</li>\n<li>有序清單 2</li>\n<li>有序清單 3</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ol</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token list punctuation\">1.</span> 有序清單 1\n<span class=\"token list punctuation\">2.</span> 有序清單 2\n<span class=\"token list punctuation\">3.</span> 有序清單 3</code></pre></div>\n<hr>\n<h2>無序清單</h2>\n<ul>\n<li>無序清單 1</li>\n<li>無序清單 2</li>\n<li>無序清單 3</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token list punctuation\">-</span> 無序清單 1\n<span class=\"token list punctuation\">-</span> 無序清單 2\n<span class=\"token list punctuation\">-</span> 無序清單 3\n\n<span class=\"token list punctuation\">*</span> 無序清單 1\n<span class=\"token list punctuation\">*</span> 無序清單 2\n<span class=\"token list punctuation\">*</span> 無序清單 3\n\n<span class=\"token list punctuation\">-</span> 無序清單 1\n<span class=\"token list punctuation\">-</span> 無序清單 2\n<span class=\"token list punctuation\">-</span> 無序清單 3</code></pre></div>\n<hr>\n<h2>程式碼區塊</h2>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hi 程式碼區塊\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717220425.png\" alt=\"img\"></p>\n<hr>\n<h2>標記程式碼</h2>\n<p>inline <code class=\"language-text\">code</code></p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">inline <span class=\"token code-snippet code keyword\">`code`</span></code></pre></div>\n<hr>\n<h2>超連結</h2>\n<p><a href=\"https://google.com\">Google 首頁</a></p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token url\">[<span class=\"token content\">Google 首頁</span>](<span class=\"token url\">https://google.com</span>)</span></code></pre></div>\n<hr>\n<h2>圖片連結</h2>\n<p><img src=\"https://www.google.com.tw/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png\" alt=\"img\"></p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">![](https://www.google.com.tw/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png)</code></pre></div>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://markdown.tw/\">Markdown 文件</a></li>\n</ul>","rawMarkdownBody":"\nMarkdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。\n\n<!--more-->\n\n我們來看看 [Swift](https://github.com/apple/swift) 的官網，可以發現 `[README.md](http://readme.md)` 這個檔案就是由 Markdown 編寫，Github 也會自動將這個檔案渲染在網頁下方。到這裡可以發現，在 Github 上的所有開源專案的文件，幾乎都是由 Markdown 編寫。\n\n## 哲學\n\n引述自 [https://markdown.tw](https://markdown.tw)\n\n> Markdown 的目標是實現「易讀易寫」。  \n> 不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 語法受到一些既有 text-to-HTML 格式的影響，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，然而最大靈感來源其實是純文字的電子郵件格式。  \n> 因此 Markdown 的語法全由標點符號所組成，並經過嚴謹慎選，是為了讓它們看起來就像所要表達的意思。像是在文字兩旁加上星號，看起來就像*強調*。Markdown 的清單看起來，嗯，就是清單。假如你有使用過電子郵件，區塊引言看起來就真的像是引用一段文字。\n\n## Tools\n\nQ: 那要用什麼來寫呢？\n\n因為 Markdown 基本上也是純文字檔案，所以只要是文字編輯器都可以編輯，你要用 txt 來寫也是個不錯的方法 ❤️。\n\n### VSCode\n\n目前最推薦的就是工程師的好夥伴 `VSCode` ，VSCode 在寫 Markdown 時，有提供即時渲染，可以快速的看到結果，而且 VSCode 應該在各位工程師的電腦裡都應該有安裝才對。\n\n### HackMD\n\nHackMD 是一個在網頁中的 Markdown 編輯器，可以方便地在網頁中編輯和看到編寫的結果，HackMD 最厲害的功能是可以將 Markdown 轉換成簡報，用 Markdown 取代 PowerPoint？這夠帥吧！\n\n### MarkText\n\n這是一個在 [Github](https://github.com/marktext/marktext) 上的開源專案，可以所寫所得，方便使用，但我還是比較推薦新手使用上面兩項工具，因為這東西真的太方便了，有點沒有在寫 Markdown 的感覺。\n\n### Microsoft Word\n\n推薦指數：⭐⭐⭐⭐⭐\n\n- [[YouTube] Why Microsoft Word is the best IDE for programming](https://www.youtube.com/watch?v=X34ZmkeZDos)\n\n## Markdown 語法\n\n<!-- markdownlint-disable MD025 -->\n\n# 大標題\n\n<!-- markdownlint-enable MD025 -->\n\n```md\n<h1>\n\n# 大標題\n```\n\n---\n\n## 次標題\n\n```md\n<h2>\n\n## 次標題\n```\n\n---\n\n### 次次標題\n\n```md\n<h3>\n\n### 次次標題\n```\n\n---\n\n## 內文\n\n內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文\n\n```md\n<p>\n\n內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文\n```\n\n---\n\n## 斜體 粗體\n\n內文內文內文*斜體*內文內文內文內文內文內文  \n內文內文內文**粗體**內文內文內文內文內文內文\n\n```md\n內文內文內文*斜體*內文內文內文內文內文內文  \n內文內文內文**粗體**內文內文內文內文內文內文\n```\n\n---\n\n## 有序清單\n\n1. 有序清單 1\n2. 有序清單 2\n3. 有序清單 3\n\n```md\n<ol>\n\n1. 有序清單 1\n2. 有序清單 2\n3. 有序清單 3\n```\n\n---\n\n## 無序清單\n\n- 無序清單 1\n- 無序清單 2\n- 無序清單 3\n\n```md\n<ul>\n\n- 無序清單 1\n- 無序清單 2\n- 無序清單 3\n\n* 無序清單 1\n* 無序清單 2\n* 無序清單 3\n\n- 無序清單 1\n- 無序清單 2\n- 無序清單 3\n```\n\n---\n\n## 程式碼區塊\n\n```c\nprintf(\"Hi 程式碼區塊\");\n```\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210717220425.png)\n\n---\n\n## 標記程式碼\n\ninline `code`\n\n```md\ninline `code`\n```\n\n---\n\n## 超連結\n\n[Google 首頁](https://google.com)\n\n```md\n[Google 首頁](https://google.com)\n```\n\n---\n\n## 圖片連結\n\n![img](https://www.google.com.tw/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png)\n\n```md\n![](https://www.google.com.tw/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png)\n```\n\n## Reference\n\n- [Markdown 文件](https://markdown.tw/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/markdown.md","excerpt":"Markdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。 我們來看看 Swift 的官網，可以發現  這個檔案就是由 Markdown 編寫，Github 也會自動將這個檔案渲染在網頁下方。到這裡可以發現，在 Github 上的…","frontmatter":{"title":"Markdown","date":"2021-07-05T09:05:38.000Z","draft":false,"tags":["markdown"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/0ecfde1e-521f-4e7c-ab46-30357d4e5e00/public","description":"Markdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。"}}},{"node":{"id":"12cf7dd4-2218-52e9-b731-11bbf415cd30","html":"<p>frp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。</p>\n<!--more-->\n<p>frp 會需要一台 Server，Server 需要公網 ip，如果沒有公網 ip，可以使用 aws 或 gcp 買一個簡單的 VPS。</p>\n<h2>安裝</h2>\n<p>網路上有許多一鍵安裝的到腳本，但我們不使用那些，有興趣的自己上網搜尋。</p>\n<p>到官方 <a href=\"https://github.com/fatedier/frp/releases\">Release</a> 下載最新版，根據系統選擇，解壓後會看到 <code class=\"language-text\">frps</code> 、<code class=\"language-text\">frpc</code> 各有三個檔案，跟 <code class=\"language-text\">frps</code> 有關的就是 Server 端用的，<code class=\"language-text\">frpc</code> 的就是 Client 端用的。如果是 Server 端，就可以將 <code class=\"language-text\">frpc</code> 的檔案都刪除。</p>\n<h2>Server 端設定</h2>\n<p>在 Server 上打開設定文件 <code class=\"language-text\">frps.ini</code> 可以看到預設就有如下的內容：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">bind_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span></code></pre></div>\n<p><code class=\"language-text\">common</code> 內綁定了 7000 port，這個 port 是讓 client 端連接用的，基本現在不用改設定就可以直接用。執行 <code class=\"language-text\">frps</code> 要用 <code class=\"language-text\">-c</code> 參數給定設定檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">./frps -c ./frps.ini</code></pre></div>\n<p>如果沒看到問題，基本上 Server 端就設定好了，其他功能晚點再介紹，我們先設定好 Client。</p>\n<h2>Client 端設定</h2>\n<p>Client 就是要發布服務伺服器，所以雖然叫做 Client 但本身應該也是一台提供服務的 Server。Client 就可以刪除有關 <code class=\"language-text\">frps</code> 相關的檔案。</p>\n<p>一樣先打開設定檔 <code class=\"language-text\">frpc.ini</code>，也會有如下預設內容：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">server_addr</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">server_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span>\n\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">ssh</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">type</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">tcp</span>\n<span class=\"token key attr-name\">local_ip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">local_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">22</span>\n<span class=\"token key attr-name\">remote_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">6000</span></code></pre></div>\n<p>Client 端的設定檔就不能直接用，需要修改 Server ip 才行，更改 <code class=\"language-text\">server_addr</code> 為剛剛 Server 端的 ip 地址或是 Domain 都可以。</p>\n<p>下方方的 ssh 區塊設一個將 Client 端的 ssh 22 port 公開到 Server 端的 6000 port 的範本，如果有其他的 port 要開放，用相同的思維更改即可。像是如過要加 Minecraft 25565 port 也到 Server 端的 25565 port，就可以新增一個區塊：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">server_addr</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">example.com</span>\n<span class=\"token key attr-name\">server_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span>\n\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">ssh</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">type</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">tcp</span>\n<span class=\"token key attr-name\">local_ip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">local_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">22</span>\n<span class=\"token key attr-name\">remote_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">6000</span>\n\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">minecraft</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">type</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">tcp</span>\n<span class=\"token key attr-name\">local_ip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">local_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">25565</span>\n<span class=\"token key attr-name\">remote_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">25565</span></code></pre></div>\n<p>到目前為止應該就可以用 Server 端的 ip 連接到 Client 端了，如果連不上，可能要檢查一下 Server 端防火牆的設定，這邊就不贅述。</p>\n<h2>Token 認證</h2>\n<p>不知道大家有沒有發現，基本上只要知道你 Server ip 或 domain 的人都可以新增自己的 port，要避免這樣的狀況，我們可以使用 token。使用方法也很簡單，只要在 Server 和 Client 端的 <code class=\"language-text\">[common]</code> 都加上相同的 token 參數，就可以進行簡單的認證。</p>\n<p>Server 端範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">bind_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span>\n<span class=\"token key attr-name\">token</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7Jc2ZCvVzHu</span></code></pre></div>\n<p>Client 端範例：</p>\n<div class=\"gatsby-highlight\" data-language=\"ini\"><pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">common</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">server_addr</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">example.com</span>\n<span class=\"token key attr-name\">server_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7000</span>\n<span class=\"token key attr-name\">token</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">7Jc2ZCvVzHu</span>\n\n<span class=\"token section\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">ssh</span><span class=\"token punctuation\">]</span></span>\n<span class=\"token key attr-name\">type</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">tcp</span>\n<span class=\"token key attr-name\">local_ip</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">127.0.0.1</span>\n<span class=\"token key attr-name\">local_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">22</span>\n<span class=\"token key attr-name\">remote_port</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">6000</span></code></pre></div>\n<h2>Refrence</h2>\n<p><a href=\"https://github.com/fatedier/frp\">GitHub</a></p>\n<p><a href=\"https://gofrp.org/docs/\">中文文檔</a></p>","rawMarkdownBody":"\nfrp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。\n\n<!--more-->\n\nfrp 會需要一台 Server，Server 需要公網 ip，如果沒有公網 ip，可以使用 aws 或 gcp 買一個簡單的 VPS。\n\n## 安裝\n\n網路上有許多一鍵安裝的到腳本，但我們不使用那些，有興趣的自己上網搜尋。\n\n到官方 [Release](https://github.com/fatedier/frp/releases) 下載最新版，根據系統選擇，解壓後會看到 `frps` 、`frpc` 各有三個檔案，跟 `frps` 有關的就是 Server 端用的，`frpc` 的就是 Client 端用的。如果是 Server 端，就可以將 `frpc` 的檔案都刪除。\n\n## Server 端設定\n\n在 Server 上打開設定文件 `frps.ini` 可以看到預設就有如下的內容：\n\n```ini\n[common]\nbind_port = 7000\n```\n\n`common` 內綁定了 7000 port，這個 port 是讓 client 端連接用的，基本現在不用改設定就可以直接用。執行 `frps` 要用 `-c` 參數給定設定檔案：\n\n```shell\n./frps -c ./frps.ini\n```\n\n如果沒看到問題，基本上 Server 端就設定好了，其他功能晚點再介紹，我們先設定好 Client。\n\n## Client 端設定\n\nClient 就是要發布服務伺服器，所以雖然叫做 Client 但本身應該也是一台提供服務的 Server。Client 就可以刪除有關 `frps` 相關的檔案。\n\n一樣先打開設定檔 `frpc.ini`，也會有如下預設內容：\n\n```ini\n[common]\nserver_addr = 127.0.0.1\nserver_port = 7000\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n```\n\nClient 端的設定檔就不能直接用，需要修改 Server ip 才行，更改 `server_addr` 為剛剛 Server 端的 ip 地址或是 Domain 都可以。\n\n下方方的 ssh 區塊設一個將 Client 端的 ssh 22 port 公開到 Server 端的 6000 port 的範本，如果有其他的 port 要開放，用相同的思維更改即可。像是如過要加 Minecraft 25565 port 也到 Server 端的 25565 port，就可以新增一個區塊：\n\n```ini\n[common]\nserver_addr = example.com\nserver_port = 7000\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n\n[minecraft]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 25565\nremote_port = 25565\n```\n\n到目前為止應該就可以用 Server 端的 ip 連接到 Client 端了，如果連不上，可能要檢查一下 Server 端防火牆的設定，這邊就不贅述。\n\n## Token 認證\n\n不知道大家有沒有發現，基本上只要知道你 Server ip 或 domain 的人都可以新增自己的 port，要避免這樣的狀況，我們可以使用 token。使用方法也很簡單，只要在 Server 和 Client 端的 `[common]` 都加上相同的 token 參數，就可以進行簡單的認證。\n\nServer 端範例：\n\n```ini\n[common]\nbind_port = 7000\ntoken = 7Jc2ZCvVzHu\n```\n\nClient 端範例：\n\n```ini\n[common]\nserver_addr = example.com\nserver_port = 7000\ntoken = 7Jc2ZCvVzHu\n\n[ssh]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 22\nremote_port = 6000\n```\n\n## Refrence\n\n[GitHub](https://github.com/fatedier/frp)\n\n[中文文檔](https://gofrp.org/docs/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Linux/frp.md","excerpt":"frp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。 frp 會需要一台 Server，Server 需要公網 ip，如果沒有公網 ip，可以使用 aws 或 gcp 買一個簡單的 VPS。 安…","frontmatter":{"title":"Frp","date":"2021-06-20T13:48:33.000Z","draft":false,"tags":["frp","linux"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/34046c81-cb6e-40a5-7b3a-8623c613f400/public","description":"frp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。"}}},{"node":{"id":"0c0b9771-fcc3-543e-a234-33d6b9792da1","html":"<p>我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。</p>\n<!--more-->\n<p>本篇使用 Kotlin 和 OKHttp，來嘗試撰寫一個應用程式，來協助發布 Markdwon 至 Medium，專案原始碼在 <a href=\"https://github.com/TonyPepeBear/MediumMarkdownUploader\">Github</a> 上。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/2021/02/10-21-47-48-%E6%88%AA%E5%9C%96%202021-02-10%20%E4%B8%8B%E5%8D%889.47.40.png\" alt=\"截圖 2021-02-10 下午9.47.40.png\"></p>\n<h2>申請 token</h2>\n<p>Medium API 的 <a href=\"https://github.com/Medium/medium-api-docs\">官方文件</a> 在這，可以用 <code class=\"language-text\">HTTP POST</code> 的方式來發布文章。要使用 API 第一件事就是要有 <code class=\"language-text\">token</code>，要申請 <code class=\"language-text\">token</code> 不用錢，官方目前好像也沒有使用限制，到 <a href=\"https://medium.com/me/settings\">用戶設定</a> 的頁面，找到 <code class=\"language-text\">Integration tokens</code> 的地方，申請一個 token，說明隨便輸入就好。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/2021/02/10-01-42-07-%E6%88%AA%E5%9C%96%202021-02-10%20%E4%B8%8A%E5%8D%881.42.04.png\" alt=\"img\"></p>\n<h2>UserID</h2>\n<p>根據官方文檔，想要發布文章，需要 UserID，我找了好久才發現 UserID 不是 Name 也不是 UserName，也是要先用 API 的方式取得。</p>\n<p>用 Http GET 的方式可以取得 token 主人資料，使用方式如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\">GET https://api.medium.com/v1/me</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">GET</span> <span class=\"token request-target url\">/v1/me</span> <span class=\"token http-version property\">HTTP/1.1</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">api.medium.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Authorization</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Bearer 181d415f34379af07b2c11d144dfbe35d</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept-Charset</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">utf-8</span></span></code></pre></div>\n<p><code class=\"language-text\">token</code> 是放在 Post 的 header，的 <code class=\"language-text\">Authorization:Bearer</code> 後方，下方是用 Kotlin 和 OKHttp 實作的方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> request <span class=\"token operator\">=</span> Request<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"https://api.medium.com/v1/me\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Authorization\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Bearer </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">token</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> response <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>範例的 Response 如下，可以拿到用 UserID、UserName 等資料：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"data\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"5303d74c64f66366f00cb9b2a94f3251bf5\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"username\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"majelbstoat\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Jamie Talbot\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://medium.com/@majelbstoat\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"imageUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://images.medium.com/0*fkfQiTzT7TlUGGyI.png\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>根據上方的 Json，可以產生 <code class=\"language-text\">Kotlin Data Class</code> 來放取回的資料：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">MediumApiMe</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> `<span class=\"token keyword\">data</span>`<span class=\"token operator\">:</span> MediumMeData\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">MediumMeData</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> id<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> imageUrl<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> name<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> url<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> username<span class=\"token operator\">:</span> String\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>取回的 Response 用 <code class=\"language-text\">gson</code> 轉換 json 到 Data Class，最後寫成一個完整的方法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">getUserData</span><span class=\"token punctuation\">(</span>token<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MediumApiMe <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> request <span class=\"token operator\">=</span> Request<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"https://api.medium.com/v1/me\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Authorization\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Bearer </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">token</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> response <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>code <span class=\"token operator\">!=</span> <span class=\"token number\">200</span> <span class=\"token operator\">||</span> response<span class=\"token punctuation\">.</span>body <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token function\">RuntimeException</span><span class=\"token punctuation\">(</span>\n            <span class=\"token string-literal singleline\"><span class=\"token string\">\"Can not get User info. Maybe token is wrong.\"</span></span> <span class=\"token operator\">+</span>\n            <span class=\"token punctuation\">{</span>response<span class=\"token punctuation\">.</span>body<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">byteStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">readLines</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">val</span> text <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>body<span class=\"token operator\">!!</span><span class=\"token punctuation\">.</span><span class=\"token function\">byteStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">readText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> gson<span class=\"token punctuation\">.</span><span class=\"token function\">fromJson</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">,</span> MediumApiMe<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上方的程式碼有判斷 Response Code 是否為 200，若不是 200 代表取得資料沒有成功，就拋出 Exception。</p>\n<h2>Post 文章</h2>\n<p>取得 UserID 後就可以用 Http Post 的方式向 Medium 發布文章。下方的 authorId 就是剛剛用 Http Get 的方式取得的 UserID。</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\">POST https://api.medium.com/v1/users/{{authorId}}/posts</code></pre></div>\n<p>下面是 Post 的範例，<code class=\"language-text\">token</code> 一樣是放在 <code class=\"language-text\">header</code> 裡。官方的範例是用 html 來發布文章，我們只要將 <code class=\"language-text\">contentFormat</code> 改成 markdown 就可以達成目的。</p>\n<div class=\"gatsby-highlight\" data-language=\"http\"><pre class=\"language-http\"><code class=\"language-http\"><span class=\"token request-line\"><span class=\"token method property\">POST</span> <span class=\"token request-target url\">/v1/users/5303d74c64f66366f00cb9b2a94f3251bf5/posts</span> <span class=\"token http-version property\">HTTP/1.1</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">api.medium.com</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Authorization</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Bearer 181d415f34379af07b2c11d144dfbe35d</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Content-Type</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">application/json</span></span>\n<span class=\"token header\"><span class=\"token header-name keyword\">Accept-Charset</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">utf-8</span></span>\n<span class=\"token application-json\">\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"title\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Liverpool FC\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"contentFormat\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"html\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"content\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"&lt;h1>Liverpool FC&lt;/h1>&lt;p>You’ll never walk alone.&lt;/p>\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"canonicalUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://jamietalbot.com/posts/liverpool-fc\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"tags\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"football\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"sport\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Liverpool\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"publishStatus\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"public\"</span>\n<span class=\"token punctuation\">}</span></span></code></pre></div>\n<p>根據上面 Post 的 Json 範例，我們可以產生出如下的 Kotlin Data Class，我順便寫了一個快速轉成 Json 的方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">MediumApiPost</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">val</span> title<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> content<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> contentFormat<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> tags<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">val</span> publishStatus<span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"draft\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token comment\">//預設是草稿</span>\n    <span class=\"token keyword\">val</span> canonicalUrl<span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"\"</span></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">toJson</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> String <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> gson<span class=\"token punctuation\">.</span><span class=\"token function\">toJson</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>產生出 Data Class 就可以嘗試 Post 看看，是否會發布文章，直接利用剛剛寫好的 <code class=\"language-text\">getUserData</code> 拿到 UserID，之後在 Post：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> userID <span class=\"token operator\">=</span> <span class=\"token function\">getUserData</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>id\n<span class=\"token keyword\">val</span> medimuApiPost <span class=\"token operator\">=</span>\n    <span class=\"token function\">MdieumApiPost</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Title\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"# Title\\nHi\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"markdown\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> request <span class=\"token operator\">=</span> Request<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"https://api.medium.com/v1/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">userID</span></span><span class=\"token string\">/posts\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span>mediumApiPost<span class=\"token punctuation\">.</span><span class=\"token function\">toJson</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toRequestBody</span><span class=\"token punctuation\">(</span>contentType <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"application/json\"</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">toMediaType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Authorization\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Bearer </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">token</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> response <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>如果發布成功，可以拿到 Response Code 201，其他的都代表發布失敗。</p>\n<p>寫成完整的發布方法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">newPost</span><span class=\"token punctuation\">(</span>token<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span> mediumApiPost<span class=\"token operator\">:</span> MediumApiPost<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> String <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> userID <span class=\"token operator\">=</span> <span class=\"token function\">getUserData</span><span class=\"token punctuation\">(</span>token<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>id\n\n    <span class=\"token keyword\">val</span> request <span class=\"token operator\">=</span> Request<span class=\"token punctuation\">.</span><span class=\"token function\">Builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">url</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"https://api.medium.com/v1/users/</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">userID</span></span><span class=\"token string\">/posts\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span>mediumApiPost<span class=\"token punctuation\">.</span><span class=\"token function\">toJson</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toRequestBody</span><span class=\"token punctuation\">(</span>contentType <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"application/json\"</span></span><span class=\"token punctuation\">.</span><span class=\"token function\">toMediaType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Authorization\"</span></span><span class=\"token punctuation\">,</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"Bearer </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">token</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">val</span> response <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">newCall</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>code <span class=\"token operator\">!=</span> <span class=\"token number\">201</span> <span class=\"token operator\">||</span> response<span class=\"token punctuation\">.</span>body <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token function\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Something Wrong. </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token expression\">response<span class=\"token punctuation\">.</span>body<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">byteStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">readText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">val</span> text <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>body<span class=\"token operator\">!!</span><span class=\"token punctuation\">.</span><span class=\"token function\">byteStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">readText</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">var</span> json <span class=\"token operator\">=</span> gson<span class=\"token punctuation\">.</span><span class=\"token function\">fromJson</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">,</span> MediumNewPostResponse<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> json<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>url\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的方法會直接回傳發布成功的 URL，失敗則會直接拋出 Exception。</p>\n<h2>GUI</h2>\n<p>寫好方法後，最後再用 <code class=\"language-text\">TornadoFX</code> 寫 GUI，這邊就不講述 GUI 的部分，有興趣可以自己到 GitHub 上看專案的原始碼。</p>\n<h2>程式碼區塊</h2>\n<p>因為 Medium 目前並不支援程式碼高亮，傳上去的程式碼區塊都會變成黑底的，目前我有想到的解法是在 Post 上去之前，就先將程式碼區塊都換成 GitHub Gist，但這就需要更複雜的方式解決問題了，有興趣的人可以自己試試看。</p>\n<h2>Reference</h2>\n<p><a href=\"https://github.com/Medium/medium-api-docs\">Medium’s API Documentation</a></p>","rawMarkdownBody":"\n我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。\n\n<!--more-->\n\n本篇使用 Kotlin 和 OKHttp，來嘗試撰寫一個應用程式，來協助發布 Markdwon 至 Medium，專案原始碼在 [Github](https://github.com/TonyPepeBear/MediumMarkdownUploader) 上。\n\n![截圖 2021-02-10 下午9.47.40.png](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/2021/02/10-21-47-48-%E6%88%AA%E5%9C%96%202021-02-10%20%E4%B8%8B%E5%8D%889.47.40.png)\n\n## 申請 token\n\nMedium API 的 [官方文件](https://github.com/Medium/medium-api-docs) 在這，可以用 `HTTP POST` 的方式來發布文章。要使用 API 第一件事就是要有 `token`，要申請 `token` 不用錢，官方目前好像也沒有使用限制，到 [用戶設定](https://medium.com/me/settings) 的頁面，找到 `Integration tokens` 的地方，申請一個 token，說明隨便輸入就好。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/2021/02/10-01-42-07-%E6%88%AA%E5%9C%96%202021-02-10%20%E4%B8%8A%E5%8D%881.42.04.png)\n\n## UserID\n\n根據官方文檔，想要發布文章，需要 UserID，我找了好久才發現 UserID 不是 Name 也不是 UserName，也是要先用 API 的方式取得。\n\n用 Http GET 的方式可以取得 token 主人資料，使用方式如下：\n\n```http\nGET https://api.medium.com/v1/me\n```\n\n```http\nGET /v1/me HTTP/1.1\nHost: api.medium.com\nAuthorization: Bearer 181d415f34379af07b2c11d144dfbe35d\nContent-Type: application/json\nAccept: application/json\nAccept-Charset: utf-8\n```\n\n`token` 是放在 Post 的 header，的 `Authorization:Bearer` 後方，下方是用 Kotlin 和 OKHttp 實作的方法：\n\n```kotlin\nval request = Request.Builder()\n    .url(\"https://api.medium.com/v1/me\")\n    .get()\n    .addHeader(\"Authorization\", \"Bearer $token\")\n    .build()\nval response = client.newCall(request).execute()\n```\n\n範例的 Response 如下，可以拿到用 UserID、UserName 等資料：\n\n```json\n{\n  \"data\": {\n    \"id\": \"5303d74c64f66366f00cb9b2a94f3251bf5\",\n    \"username\": \"majelbstoat\",\n    \"name\": \"Jamie Talbot\",\n    \"url\": \"https://medium.com/@majelbstoat\",\n    \"imageUrl\": \"https://images.medium.com/0*fkfQiTzT7TlUGGyI.png\"\n  }\n}\n```\n\n根據上方的 Json，可以產生 `Kotlin Data Class` 來放取回的資料：\n\n```kotlin\ndata class MediumApiMe(\n    val `data`: MediumMeData\n)\n\ndata class MediumMeData(\n    val id: String,\n    val imageUrl: String,\n    val name: String,\n    val url: String,\n    val username: String\n)\n```\n\n取回的 Response 用 `gson` 轉換 json 到 Data Class，最後寫成一個完整的方法如下：\n\n```kotlin\nfun getUserData(token: String): MediumApiMe {\n    val request = Request.Builder()\n        .url(\"https://api.medium.com/v1/me\")\n        .get()\n        .addHeader(\"Authorization\", \"Bearer $token\")\n        .build()\n    val response = client.newCall(request).execute()\n    if (response.code != 200 || response.body == null)\n        throw RuntimeException(\n            \"Can not get User info. Maybe token is wrong.\" +\n            {response.body?.byteStream()?.reader()?.readLines()}\n        )\n\n    val text = response.body!!.byteStream()\n        .reader()\n        .readText()\n    return gson.fromJson(text, MediumApiMe::class.java)\n}\n```\n\n上方的程式碼有判斷 Response Code 是否為 200，若不是 200 代表取得資料沒有成功，就拋出 Exception。\n\n## Post 文章\n\n取得 UserID 後就可以用 Http Post 的方式向 Medium 發布文章。下方的 authorId 就是剛剛用 Http Get 的方式取得的 UserID。\n\n```http\nPOST https://api.medium.com/v1/users/{{authorId}}/posts\n```\n\n下面是 Post 的範例，`token` 一樣是放在 `header` 裡。官方的範例是用 html 來發布文章，我們只要將 `contentFormat` 改成 markdown 就可以達成目的。\n\n```http\nPOST /v1/users/5303d74c64f66366f00cb9b2a94f3251bf5/posts HTTP/1.1\nHost: api.medium.com\nAuthorization: Bearer 181d415f34379af07b2c11d144dfbe35d\nContent-Type: application/json\nAccept: application/json\nAccept-Charset: utf-8\n\n{\n  \"title\": \"Liverpool FC\",\n  \"contentFormat\": \"html\",\n  \"content\": \"<h1>Liverpool FC</h1><p>You’ll never walk alone.</p>\",\n  \"canonicalUrl\": \"http://jamietalbot.com/posts/liverpool-fc\",\n  \"tags\": [\"football\", \"sport\", \"Liverpool\"],\n  \"publishStatus\": \"public\"\n}\n```\n\n根據上面 Post 的 Json 範例，我們可以產生出如下的 Kotlin Data Class，我順便寫了一個快速轉成 Json 的方法：\n\n```kotlin\ndata class MediumApiPost(\n    val title: String,\n    val content: String,\n    val contentFormat: String,\n    val tags: List<String> = listOf(),\n    val publishStatus: String = \"draft\", //預設是草稿\n    val canonicalUrl: String = \"\",\n) {\n    fun toJson(): String {\n        return gson.toJson(this)\n    }\n}\n```\n\n產生出 Data Class 就可以嘗試 Post 看看，是否會發布文章，直接利用剛剛寫好的 `getUserData` 拿到 UserID，之後在 Post：\n\n```kotlin\nval userID = getUserData(token).data.id\nval medimuApiPost =\n    MdieumApiPost(\"Title\", \"# Title\\nHi\", \"markdown\")\nval request = Request.Builder()\n    .url(\"https://api.medium.com/v1/users/$userID/posts\")\n    .post(mediumApiPost.toJson().toRequestBody(contentType = \"application/json\".toMediaType()))\n    .addHeader(\"Authorization\", \"Bearer $token\")\n    .build()\nval response = client.newCall(request).execute()\n```\n\n如果發布成功，可以拿到 Response Code 201，其他的都代表發布失敗。\n\n寫成完整的發布方法如下：\n\n```kotlin\nfun newPost(token: String, mediumApiPost: MediumApiPost): String {\n    val userID = getUserData(token).data.id\n\n    val request = Request.Builder()\n        .url(\"https://api.medium.com/v1/users/$userID/posts\")\n        .post(mediumApiPost.toJson().toRequestBody(contentType = \"application/json\".toMediaType()))\n        .addHeader(\"Authorization\", \"Bearer $token\")\n        .build()\n    val response = client.newCall(request).execute()\n\n    if (response.code != 201 || response.body == null)\n        throw RuntimeException(\"Something Wrong. ${response.body?.byteStream()?.reader()?.readText()}\")\n\n    val text = response.body!!.byteStream().reader().readText()\n    println(text)\n\n    var json = gson.fromJson(text, MediumNewPostResponse::class.java)\n\n    return json.data.url\n}\n```\n\n上面的方法會直接回傳發布成功的 URL，失敗則會直接拋出 Exception。\n\n## GUI\n\n寫好方法後，最後再用 `TornadoFX` 寫 GUI，這邊就不講述 GUI 的部分，有興趣可以自己到 GitHub 上看專案的原始碼。\n\n## 程式碼區塊\n\n因為 Medium 目前並不支援程式碼高亮，傳上去的程式碼區塊都會變成黑底的，目前我有想到的解法是在 Post 上去之前，就先將程式碼區塊都換成 GitHub Gist，但這就需要更複雜的方式解決問題了，有興趣的人可以自己試試看。\n\n## Reference\n\n[Medium’s API Documentation](https://github.com/Medium/medium-api-docs)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Kotlin/medium-api.md","excerpt":"我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。 本篇…","frontmatter":{"title":"發布 Markdown 至 Medium","date":"2021-06-15T18:35:56.000Z","draft":false,"tags":["medium","markdown","kotlin","tornadofx"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/98587dc3-5d4e-446a-7d98-b0b1ad36d500/public","description":"我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。"}}},{"node":{"id":"dc1d7172-8fd3-59ca-b4a9-f5085ecbd89e","html":"<p>其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩，要先經過不少設定。而且在官方的文件中，其實是教你怎麼建置專案，執行 Debug，如果只是寫一點簡單的小程式根本用不到那麼複雜的設定，所以本文是我目前發現比較容易在 VSCode 中執行 C 和 C++ 的方法。</p>\n<!--more-->\n<h2>gcc g++</h2>\n<p>在了解如何設定 vscode 前，我們先來了解一下基本的 gcc、g++ 指令，這是一個用來編譯 C 程式碼最快的方法，gcc 就是 C 的編譯器，g++ 則是 C++ 的。這裡不會解說如何安裝，在 Windows 下可以使用 MinGW (如果要在 Windows 安裝 MinGW，用 Chocolatey 安裝是最快的方式)，macOS 則是只要在 Terminal 下 gcc 指令，就會自動問你要不要安裝。</p>\n<p>下面的範例會編譯 <code class=\"language-text\">main.cpp</code> 的 C++ 檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">g++ main.cpp</code></pre></div>\n<p>執行上面的指令後，會產生名為 <code class=\"language-text\">a.out</code> 的檔案，因為我們沒有指定輸出檔名，所以預設就是 <code class=\"language-text\">a.out</code>，在 Windows 上則為 <code class=\"language-text\">a.exe</code> 的執行檔。如果要執行產生的執行檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">./a.out\n./a.exe <span class=\"token comment\"># On Windows</span></code></pre></div>\n<p>要指定輸出檔名也很簡單，加個 <code class=\"language-text\">-o</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">g++ -o main.out main.cpp</code></pre></div>\n<p>這樣就可以將 <code class=\"language-text\">main.cpp</code> 編譯成 <code class=\"language-text\">main.out</code> 的執行檔。</p>\n<p>上面這些不會也沒關係，但我還是建議了解一下，因為等一下要安裝的模組，只是幫你完成這些步驟，如果完全不了解指令的功能，發生問題可能自己會沒辦法解決。</p>\n<h2>設定 VSCode</h2>\n<p>第一步就是先在 VSCode 中安裝 <strong>C/C++</strong>，和 <strong>Code Runner</strong>，兩個延伸模組。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608014749.png\" alt=\"img\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608021309.png\" alt=\"img\"></p>\n<p>安裝完成後，應該就會看到右上角出現了一個執行的按鈕，可以按按看程式會不會執行。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608021808.png\" alt=\"img\"></p>\n<p>如果找不到按鈕，或是想要停下程式，也可以用按下 <code class=\"language-text\">f1</code> 的方式叫出 VSCode 的指令輸入窗，輸入 <code class=\"language-text\">Run Code</code> 或是 <code class=\"language-text\">Stop Code Run</code>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608022037.png\" alt=\"img\"></p>\n<h2>Run In Terminal</h2>\n<p>現在可能會發先一個問題，這種執行模式是沒有辦法接收鍵盤輸入的，如果想要接收鍵盤輸入，我們要把執行模式改成在 Terminal 中。所以我們要開啟 VSCode 的 <code class=\"language-text\">settings.json</code> 設定檔，來更改設定，一樣是用 <code class=\"language-text\">f1</code> 叫出命令輸入區，並尋找 <code class=\"language-text\">open settings json</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608024052.png\" alt=\"img\"></p>\n<p>打開後在裡面新增一行：</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token property\">\"code-runner.runInTerminal\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span></code></pre></div>\n<p>如果前方有其他設定值，記得在前面的設定值的最後面加個逗號 <code class=\"language-text\">,</code>：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608024259.png\" alt=\"img\"></p>\n<p>現在就可以方便的在 VSCode 中寫 C，和方便的執行他們。</p>","rawMarkdownBody":"\n其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩，要先經過不少設定。而且在官方的文件中，其實是教你怎麼建置專案，執行 Debug，如果只是寫一點簡單的小程式根本用不到那麼複雜的設定，所以本文是我目前發現比較容易在 VSCode 中執行 C 和 C++ 的方法。\n\n<!--more-->\n\n## gcc g++\n\n在了解如何設定 vscode 前，我們先來了解一下基本的 gcc、g++ 指令，這是一個用來編譯 C 程式碼最快的方法，gcc 就是 C 的編譯器，g++ 則是 C++ 的。這裡不會解說如何安裝，在 Windows 下可以使用 MinGW (如果要在 Windows 安裝 MinGW，用 Chocolatey 安裝是最快的方式)，macOS 則是只要在 Terminal 下 gcc 指令，就會自動問你要不要安裝。\n\n下面的範例會編譯 `main.cpp` 的 C++ 檔案：\n\n```bash\ng++ main.cpp\n```\n\n執行上面的指令後，會產生名為 `a.out` 的檔案，因為我們沒有指定輸出檔名，所以預設就是 `a.out`，在 Windows 上則為 `a.exe` 的執行檔。如果要執行產生的執行檔案：\n\n```bash\n./a.out\n./a.exe # On Windows\n```\n\n要指定輸出檔名也很簡單，加個 `-o`：\n\n```bash\ng++ -o main.out main.cpp\n```\n\n這樣就可以將 `main.cpp` 編譯成 `main.out` 的執行檔。\n\n上面這些不會也沒關係，但我還是建議了解一下，因為等一下要安裝的模組，只是幫你完成這些步驟，如果完全不了解指令的功能，發生問題可能自己會沒辦法解決。\n\n## 設定 VSCode\n\n第一步就是先在 VSCode 中安裝 **C/C++**，和 **Code Runner**，兩個延伸模組。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608014749.png)\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608021309.png)\n\n安裝完成後，應該就會看到右上角出現了一個執行的按鈕，可以按按看程式會不會執行。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608021808.png)\n\n如果找不到按鈕，或是想要停下程式，也可以用按下 `f1` 的方式叫出 VSCode 的指令輸入窗，輸入 `Run Code` 或是 `Stop Code Run`。\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608022037.png)\n\n## Run In Terminal\n\n現在可能會發先一個問題，這種執行模式是沒有辦法接收鍵盤輸入的，如果想要接收鍵盤輸入，我們要把執行模式改成在 Terminal 中。所以我們要開啟 VSCode 的 `settings.json` 設定檔，來更改設定，一樣是用 `f1` 叫出命令輸入區，並尋找 `open settings json`：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608024052.png)\n\n打開後在裡面新增一行：\n\n```json\n\"code-runner.runInTerminal\": true\n```\n\n如果前方有其他設定值，記得在前面的設定值的最後面加個逗號 `,`：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210608024259.png)\n\n現在就可以方便的在 VSCode 中寫 C，和方便的執行他們。\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/VSCode/vscode-clang.md","excerpt":"其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩，要先經過不少設定。而且在官方的文件中，其實是教你怎麼建置專案，執行 Debug，如果只是寫一點簡單的小程式根本用不到那麼複雜的設定，所以本文是我目前發現比較容易在 VSCode 中執行 C 和 C++ 的方法。 …","frontmatter":{"title":"用 VSCode 寫 C/C++","date":"2021-06-07T16:55:19.000Z","draft":false,"tags":["vscode","code","c","c++"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/48d8b9f1-209f-44ab-0f7b-92b5f082a500/public","description":"其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩。"}}},{"node":{"id":"870e064c-4e10-52cf-8ee4-7e88a63fa689","html":"<p>Github Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到 <code class=\"language-text\">gh-pages</code> 的 git 分支。</p>\n<!--more-->\n<p>Github Actions 也是容器化技術的一環，也是類似 Docker 容器的一種，如果對 Docker 還不熟悉，應該會對本文有點吃力，但也可以對完全不了解 Docker 的人，多一點對容器化技術的認識。</p>\n<h2>編寫 Workflows 檔案</h2>\n<p>Workflows 工作流檔案，就是在 CI/CD 中最重要的檔案，這個檔案寫下這個專案的工作流程，像是如何 Test、交付成品，都是寫在這的檔案裡，Github 會自動讀取所有工作留檔案和自動執行，所以只要寫好一次，基本上就一勞永逸，每次只需要 Push，Gihtub 就會按照腳本完成指定的工作。</p>\n<p>Github Actions 的 Worksflows 檔案都是放在專案跟目錄的 <code class=\"language-text\">/.github/workflows</code> 這個資料夾中，Github 會讀取這個資料夾中的 <code class=\"language-text\">*.yml</code> 檔案，並且自動執行他們。我們現在在這個目錄下新增一個叫做 <code class=\"language-text\">hugo-public.yml</code> 的檔案，檔名可以自訂沒關係，Github 不會關心檔名長怎樣，如果有多個檔案也每個都會分別執行。</p>\n<p>我們在現在 <code class=\"language-text\">/.github/workflows/hugo-public.yml</code> 的檔案中新增如下的腳本：</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> github pages\n\n<span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> master <span class=\"token comment\"># Set a branch to deploy</span>\n  <span class=\"token key atrule\">pull_request</span><span class=\"token punctuation\">:</span>\n\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span><span class=\"token number\">20.04</span>\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">submodules</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span> <span class=\"token comment\"># Fetch Hugo themes (true OR recursive)</span>\n          <span class=\"token key atrule\">fetch-depth</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span> <span class=\"token comment\"># Fetch all history for .GitInfo and .Lastmod</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Hugo\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>hugo@v2\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">hugo-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"latest\"</span>\n          <span class=\"token key atrule\">extended</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build\n        <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> hugo <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>minify\n\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Deploy\n        <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>gh<span class=\"token punctuation\">-</span>pages@v3\n        <span class=\"token key atrule\">if</span><span class=\"token punctuation\">:</span> github.ref == 'refs/heads/master'\n        <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">github_token</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.ACCESS_TOKEN <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n          <span class=\"token key atrule\">publish_dir</span><span class=\"token punctuation\">:</span> ./public</code></pre></div>\n<p>下面我們分段來解釋上面腳本每行的意思。</p>\n<h2>Name</h2>\n<p>基本上就是這個腳本的名稱，可以隨意自訂不會影響結果。</p>\n<h2>On</h2>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> master <span class=\"token comment\"># Set a branch to deploy</span>\n  pull_request<span class=\"token punctuation\">:</span></code></pre></div>\n<p><code class=\"language-text\">on</code> 區段定義了這個腳本什麼時候會被執行，我們現在這個範例中，定義了這個腳本會在 <code class=\"language-text\">master</code> 這個分支被 push 的時候自動執行。Github 現在預設的分支名稱是 <code class=\"language-text\">main</code>，如果是 <code class=\"language-text\">main</code> 的人千萬要記得改，以免這個腳本永遠不會執行。</p>\n<h2>Jobs</h2>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 以下省略</span></code></pre></div>\n<p>jobs 是整個檔案中最核心的部分，可以分成許多不同的 Job，目前我們只有一個叫做 <code class=\"language-text\">deploy</code> 的 Job，這個名稱也是可以自訂的，這裡只是取叫 <code class=\"language-text\">deploy</code> 看不順眼可以自己換。如果還需要有其他工作，可以自己視情況增加。</p>\n<h3>Job</h3>\n<p>終於來到最核心的部分，deploy 任務中的第一行，就定義了這個任務要 Run 在哪個容器內，或是稱作哪個系統內。這邊是用 <code class=\"language-text\">ubuntu</code> 的 20.04，建議不要亂改，因為其他的 Linux 不一定可以完任務。</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span><span class=\"token number\">20.04</span>\n  <span class=\"token comment\">## 以下省略</span></code></pre></div>\n<h3>Steps</h3>\n<p>接下來就是分步驟執行命令，<code class=\"language-text\">uses</code> 是利用 Github 上別人已經寫好的 Actions 腳本來執行命令，像是第一個 <code class=\"language-text\">uses: actions/checkout@v2</code> 就是李用 Github 上別人已經寫好的 <code class=\"language-text\">git checkout</code> 命令來把專案 checkout 到容器中。</p>\n<p>第二個部分也是使用別人已經寫好的腳本，快速的安裝 Hugo 到容器內，用別人寫好的東西來完成工作，避免不必要的重複造輪子。</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2\n    <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">submodules</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>  <span class=\"token comment\"># Fetch Hugo themes (true OR recursive)</span>\n        <span class=\"token key atrule\">fetch-depth</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span>    <span class=\"token comment\"># Fetch all history for .GitInfo and .Lastmod</span>\n\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Hugo\n    <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>hugo@v2\n    <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">hugo-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'latest'</span>\n        <span class=\"token key atrule\">extended</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build\n    <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> hugo <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>minify\n\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Deploy\n    <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>gh<span class=\"token punctuation\">-</span>pages@v3\n    <span class=\"token key atrule\">if</span><span class=\"token punctuation\">:</span> github.ref == 'refs/heads/master'\n    <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">github_token</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.ACCESS_TOKEN <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n        <span class=\"token key atrule\">publish_dir</span><span class=\"token punctuation\">:</span> ./public</code></pre></div>\n<p>看到這裡也可以發現任務也是分很多步驟，第三部分的 Build 就是像是我們在本機目錄的產生方法一樣，直接輸入 <code class=\"language-text\">hugo</code> 命令產生靜態網頁。</p>\n<p>第四部分的 Deploy 就會比較複雜，這邊也是利用別人寫好用來發布 Github Pages 的任務，他會需要一個 Github Token，這個 Token 是要用來對 Repository 有 Push 的權限，雖然可以直接寫在腳本裡，但是就所有人都看得到你的 Token，那就會產生資安問題。所以 Github 提供 Secrets 的模式，可以把不方便直接寫在專案裡的機敏資料，放在 Github 上。</p>\n<p>所以我們現在會有兩件事要做：</p>\n<ol>\n<li>產生 Token</li>\n<li>把 Token 放到專案的 Secrets 中</li>\n</ol>\n<p>我們先來產生 Token，先到個人的設定頁面找到 Developer settings：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9cec1b4f-5bf6-4e41-9177-3cbe9ccfd400/large\" alt=\"img\"></p>\n<p>再到 Token 的頁面產生新的 Token：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/dfa652f6-b8b1-4df2-5b7f-ccdda2e8df00/large\" alt=\"img\"></p>\n<p>名稱可以自己隨意訂，Repo 的權限就全部打開，除了 Repo 以外的權限則都不需要。都確定後直接拉到最下面產生 Token：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/94de0480-f57a-4bef-b1e1-9ce3f75d2c00/large\" alt=\"img\"></p>\n<p>會得到一組新的 Token，請注意不要像我一樣 Show 出來給別人看，請妥善保存，而且 Github 也只會顯示這一次，以後想要看都看不到，只能產生新的 Token。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/13bcbfe0-5bbc-4292-5679-cd5d1dba9f00/large\" alt=\"img\"></p>\n<p>複製下 Token 後，我們到專案層級的設定，注意是<strong>專案</strong>的設定，不是個人設定：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d5b06f39-8b64-4f76-3f68-84d30fbc9a00/large\" alt=\"img\"></p>\n<p>找到 Secrets 並新增 Secrets：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/409789e1-87f4-4469-fcf4-032a27e05700/large\" alt=\"img\"></p>\n<p>名字取好後，填入剛剛拿到的 Token，注意名稱要和剛剛在腳本中寫的一樣：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8e7912d5-53fc-491a-a638-bee48f87be00/large\" alt=\"img\"></p>\n<p>都填完後就大功告成，基本上只要 Push 到 Github 上，應該就會自動觸發上面寫的工作，以後只要文章有新的變動，Push 上來就會自動更新網頁網頁到專案的 <code class=\"language-text\">gh-pages</code> 分之上。想要進一步看到 Pages 的設定，可以到專案下的 Pages 的設定下看看，也可以在這裡自訂 Domian。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/e1c327a2-2e73-45ff-7305-a8440010d600/large\" alt=\"img\"></p>","rawMarkdownBody":"\nGithub Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到 `gh-pages` 的 git 分支。\n\n<!--more-->\n\nGithub Actions 也是容器化技術的一環，也是類似 Docker 容器的一種，如果對 Docker 還不熟悉，應該會對本文有點吃力，但也可以對完全不了解 Docker 的人，多一點對容器化技術的認識。\n\n## 編寫 Workflows 檔案\n\nWorkflows 工作流檔案，就是在 CI/CD 中最重要的檔案，這個檔案寫下這個專案的工作流程，像是如何 Test、交付成品，都是寫在這的檔案裡，Github 會自動讀取所有工作留檔案和自動執行，所以只要寫好一次，基本上就一勞永逸，每次只需要 Push，Gihtub 就會按照腳本完成指定的工作。\n\nGithub Actions 的 Worksflows 檔案都是放在專案跟目錄的 `/.github/workflows` 這個資料夾中，Github 會讀取這個資料夾中的 `*.yml` 檔案，並且自動執行他們。我們現在在這個目錄下新增一個叫做 `hugo-public.yml` 的檔案，檔名可以自訂沒關係，Github 不會關心檔名長怎樣，如果有多個檔案也每個都會分別執行。\n\n我們在現在 `/.github/workflows/hugo-public.yml` 的檔案中新增如下的腳本：\n\n```yml\nname: github pages\n\non:\n  push:\n    branches:\n      - master # Set a branch to deploy\n  pull_request:\n\njobs:\n  deploy:\n    runs-on: ubuntu-20.04\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          submodules: true # Fetch Hugo themes (true OR recursive)\n          fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod\n\n      - name: Setup Hugo\n        uses: peaceiris/actions-hugo@v2\n        with:\n          hugo-version: \"latest\"\n          extended: true\n\n      - name: Build\n        run: hugo --minify\n\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        if: github.ref == 'refs/heads/master'\n        with:\n          github_token: ${{ secrets.ACCESS_TOKEN }}\n          publish_dir: ./public\n```\n\n下面我們分段來解釋上面腳本每行的意思。\n\n## Name\n\n基本上就是這個腳本的名稱，可以隨意自訂不會影響結果。\n\n## On\n\n```yml\non:\n  push:\n    branches:\n      - master # Set a branch to deploy\n  pull_request:\n```\n\n`on` 區段定義了這個腳本什麼時候會被執行，我們現在這個範例中，定義了這個腳本會在 `master` 這個分支被 push 的時候自動執行。Github 現在預設的分支名稱是 `main`，如果是 `main` 的人千萬要記得改，以免這個腳本永遠不會執行。\n\n## Jobs\n\n```yml\njobs:\n  deploy:\n    # 以下省略\n```\n\njobs 是整個檔案中最核心的部分，可以分成許多不同的 Job，目前我們只有一個叫做 `deploy` 的 Job，這個名稱也是可以自訂的，這裡只是取叫 `deploy` 看不順眼可以自己換。如果還需要有其他工作，可以自己視情況增加。\n\n### Job\n\n終於來到最核心的部分，deploy 任務中的第一行，就定義了這個任務要 Run 在哪個容器內，或是稱作哪個系統內。這邊是用 `ubuntu` 的 20.04，建議不要亂改，因為其他的 Linux 不一定可以完任務。\n\n```yml\ndeploy:\n  runs-on: ubuntu-20.04\n  ## 以下省略\n```\n\n### Steps\n\n接下來就是分步驟執行命令，`uses` 是利用 Github 上別人已經寫好的 Actions 腳本來執行命令，像是第一個 `uses: actions/checkout@v2` 就是李用 Github 上別人已經寫好的 `git checkout` 命令來把專案 checkout 到容器中。\n\n第二個部分也是使用別人已經寫好的腳本，快速的安裝 Hugo 到容器內，用別人寫好的東西來完成工作，避免不必要的重複造輪子。\n\n```yml\nsteps:\n    - uses: actions/checkout@v2\n    with:\n        submodules: true  # Fetch Hugo themes (true OR recursive)\n        fetch-depth: 0    # Fetch all history for .GitInfo and .Lastmod\n\n    - name: Setup Hugo\n    uses: peaceiris/actions-hugo@v2\n    with:\n        hugo-version: 'latest'\n        extended: true\n\n    - name: Build\n    run: hugo --minify\n\n    - name: Deploy\n    uses: peaceiris/actions-gh-pages@v3\n    if: github.ref == 'refs/heads/master'\n    with:\n        github_token: ${{ secrets.ACCESS_TOKEN }}\n        publish_dir: ./public\n```\n\n看到這裡也可以發現任務也是分很多步驟，第三部分的 Build 就是像是我們在本機目錄的產生方法一樣，直接輸入 `hugo` 命令產生靜態網頁。\n\n第四部分的 Deploy 就會比較複雜，這邊也是利用別人寫好用來發布 Github Pages 的任務，他會需要一個 Github Token，這個 Token 是要用來對 Repository 有 Push 的權限，雖然可以直接寫在腳本裡，但是就所有人都看得到你的 Token，那就會產生資安問題。所以 Github 提供 Secrets 的模式，可以把不方便直接寫在專案裡的機敏資料，放在 Github 上。\n\n所以我們現在會有兩件事要做：\n\n1. 產生 Token\n2. 把 Token 放到專案的 Secrets 中\n\n我們先來產生 Token，先到個人的設定頁面找到 Developer settings：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/9cec1b4f-5bf6-4e41-9177-3cbe9ccfd400/large)\n\n再到 Token 的頁面產生新的 Token：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/dfa652f6-b8b1-4df2-5b7f-ccdda2e8df00/large)\n\n名稱可以自己隨意訂，Repo 的權限就全部打開，除了 Repo 以外的權限則都不需要。都確定後直接拉到最下面產生 Token：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/94de0480-f57a-4bef-b1e1-9ce3f75d2c00/large)\n\n會得到一組新的 Token，請注意不要像我一樣 Show 出來給別人看，請妥善保存，而且 Github 也只會顯示這一次，以後想要看都看不到，只能產生新的 Token。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/13bcbfe0-5bbc-4292-5679-cd5d1dba9f00/large)\n\n複製下 Token 後，我們到專案層級的設定，注意是**專案**的設定，不是個人設定：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d5b06f39-8b64-4f76-3f68-84d30fbc9a00/large)\n\n找到 Secrets 並新增 Secrets：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/409789e1-87f4-4469-fcf4-032a27e05700/large)\n\n名字取好後，填入剛剛拿到的 Token，注意名稱要和剛剛在腳本中寫的一樣：\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8e7912d5-53fc-491a-a638-bee48f87be00/large)\n\n都填完後就大功告成，基本上只要 Push 到 Github 上，應該就會自動觸發上面寫的工作，以後只要文章有新的變動，Push 上來就會自動更新網頁網頁到專案的 `gh-pages` 分之上。想要進一步看到 Pages 的設定，可以到專案下的 Pages 的設定下看看，也可以在這裡自訂 Domian。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/e1c327a2-2e73-45ff-7305-a8440010d600/large)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Hugo/hugo-github-actions.md","excerpt":"Github Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到  …","frontmatter":{"title":"用 Github Actions 來發布 Hugo 靜態網頁","date":"2021-06-07T14:00:53.000Z","draft":false,"tags":["hugo","github","github-actions","web"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/3820056d-8496-4b29-efa0-716d71a45100/public","description":"Github Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到 gh-pages 的 git 分支。"}}},{"node":{"id":"766ef66b-681e-5784-9c0d-39c5a162ea4d","html":"<p>Hugo 是靜態網頁的產生器，類似 Hexo 和 Jekyll，Hugo 由 go 語言編寫，效率極高，我原本是用 Hexo 在產生文章，後來發現 Hugo 這個好東西，也觀望了一陣子<del>其實是懶</del>，就決定換過來了，目前也用得非常順手。</p>\n<!--more-->\n<h2>安裝 Hugo</h2>\n<p>這是 Hugo 的<a href=\"https://gohugo.io/\">官網</a>，進去後可以看到一些簡單的介紹和安裝方法。</p>\n<p>我蠻推薦在 vscode 的 <code class=\"language-text\">code in container</code> 的方式用 Hugo，因為我自己也是這樣用，這樣就不用擔心會弄髒環境，但就讓有興趣的人自己研究吧，這裡我介紹一般電腦的安裝方式。</p>\n<h3>Windows</h3>\n<p>Windows 我建議是用 Chocolatey 來安裝是最方便的：</p>\n<div class=\"gatsby-highlight\" data-language=\"ps1\"><pre class=\"language-ps1\"><code class=\"language-ps1\">choco install hugo</code></pre></div>\n<p>但是如果不想要用 Chocolatey 安裝，可以去官方的 <a href=\"https://github.com/gohugoio/hugo/releases\">Github Release</a> 下載最新的 Windows 版本，下載完後記得加入 PATH。</p>\n<h3>Mac</h3>\n<p>macOS 安裝最簡單，用 Homebrew 就可以快速的安裝。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">brew <span class=\"token function\">install</span> hugo</code></pre></div>\n<h3>Linux</h3>\n<p>Linux 我一律建議從官方的 <a href=\"https://github.com/gohugoio/hugo/releases\">Github Release</a> 下載最新的版本，並自己加到 PATH。</p>\n<p>雖然 apt 等版本管理器好像有提供，但官方的文件上都說版本幾乎都不是最新版，所以也不建議。用下載的方式還是最方便的，或是用 Docker 也是好辦法。</p>\n<h2>開始使用 Hugo</h2>\n<p>先創建一個新的 Hugo 專案，下面的 <code class=\"language-text\">MyBlog</code> 可以換成自己想要的專案名稱：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">hugo new site MyBlog</code></pre></div>\n<h3>新增主題</h3>\n<p>創建好專案後，就可以來新增主題，目前在 Hugo 上提供非常多的主題，我們可以到官方的這個<a href=\"https://themes.gohugo.io/\">網站</a>找找看，但目前些不要增加難度，用最官房提供的簡單的 ananke 主題就好，反正主題是隨時都可以換的。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> MyBlog\n<span class=\"token function\">git</span> init\n<span class=\"token function\">git</span> submodule <span class=\"token function\">add</span> https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke\n<span class=\"token builtin class-name\">echo</span> theme <span class=\"token operator\">=</span> <span class=\"token punctuation\">\\</span>\"ananke<span class=\"token punctuation\">\\</span>\" <span class=\"token operator\">>></span> config.toml</code></pre></div>\n<p>可以看到，官方是建議使用 <code class=\"language-text\">git submodule</code> 的方式新增主題，這樣之後在更新主題的時候也比較方便。</p>\n<p>最後一行的 <code class=\"language-text\">echo</code> 指令會在專案底下產生一個 <code class=\"language-text\">config.toml</code> 的檔案，基本上之後所有有關 Hugo 網站的設定，都可以在這裡變更。這一行指令應該會幫你在檔案中產生如下的內容：</p>\n<div class=\"gatsby-highlight\" data-language=\"toml\"><pre class=\"language-toml\"><code class=\"language-toml\"><span class=\"token key property\">theme</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"ananke\"</span></code></pre></div>\n<h3>新增文章</h3>\n<p>在 Hugo 中新增文章的指令就是如下，可以自己修改檔名。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">hugo new posts/my-first-post.md</code></pre></div>\n<p>產生完成後可以看到 Hugo 幫你產生了一些 Front Matter。</p>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\"><span class=\"token front-matter-block\"><span class=\"token punctuation\">---</span>\n<span class=\"token front-matter yaml language-yaml\"><span class=\"token key atrule\">title</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"My First Post\"</span>\n<span class=\"token key atrule\">date</span><span class=\"token punctuation\">:</span> <span class=\"token datetime number\">2019-03-26T08:47:11+01:00</span>\n<span class=\"token key atrule\">draft</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span></span>\n<span class=\"token punctuation\">---</span></span></code></pre></div>\n<p>上面的 <code class=\"language-text\">draft</code> 的指令是草稿的意思，如果沒有在上線前改成 <code class=\"language-text\">false</code>，是不會在正式網站中渲染的。</p>\n<p>現在可以自己產生的 Markdown 檔案中加一些內容，等等就可以看看效果怎麼樣。</p>\n<h2>執行 Hugo Server</h2>\n<p>要啟動 Hugo Server 也非常簡單：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">hugo server -D</code></pre></div>\n<p>上面的 <code class=\"language-text\">-D</code> 參數的意思是把 <code class=\"language-text\">draft</code> 的草稿文件也渲染，如果想要看看上線的網頁會長怎樣，可以不要加上這個參數。</p>\n<h2>產生靜態網頁</h2>\n<p>這個最簡單了，連猴子都會，<code class=\"language-text\">-D</code> 的參數一樣是渲染草稿文件，可視需求加上。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">hugo</code></pre></div>\n<p>到這裡就介紹完成所有 Hugo 基本的使用方法了，之後我會介紹如何使用 Github Actio\bn，讓我們每次只需要 Push 專案，Github 就會幫我們重新建置並部署網站。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://gohugo.io/getting-started/quick-start/\">Hugo Quick Start</a></li>\n</ul>","rawMarkdownBody":"\nHugo 是靜態網頁的產生器，類似 Hexo 和 Jekyll，Hugo 由 go 語言編寫，效率極高，我原本是用 Hexo 在產生文章，後來發現 Hugo 這個好東西，也觀望了一陣子~~其實是懶~~，就決定換過來了，目前也用得非常順手。\n\n<!--more-->\n\n## 安裝 Hugo\n\n這是 Hugo 的[官網](https://gohugo.io/)，進去後可以看到一些簡單的介紹和安裝方法。\n\n我蠻推薦在 vscode 的 `code in container` 的方式用 Hugo，因為我自己也是這樣用，這樣就不用擔心會弄髒環境，但就讓有興趣的人自己研究吧，這裡我介紹一般電腦的安裝方式。\n\n### Windows\n\nWindows 我建議是用 Chocolatey 來安裝是最方便的：\n\n```ps1\nchoco install hugo\n```\n\n但是如果不想要用 Chocolatey 安裝，可以去官方的 [Github Release](https://github.com/gohugoio/hugo/releases) 下載最新的 Windows 版本，下載完後記得加入 PATH。\n\n### Mac\n\nmacOS 安裝最簡單，用 Homebrew 就可以快速的安裝。\n\n```bash\nbrew install hugo\n```\n\n### Linux\n\nLinux 我一律建議從官方的 [Github Release](https://github.com/gohugoio/hugo/releases) 下載最新的版本，並自己加到 PATH。\n\n雖然 apt 等版本管理器好像有提供，但官方的文件上都說版本幾乎都不是最新版，所以也不建議。用下載的方式還是最方便的，或是用 Docker 也是好辦法。\n\n## 開始使用 Hugo\n\n先創建一個新的 Hugo 專案，下面的 `MyBlog` 可以換成自己想要的專案名稱：\n\n```bash\nhugo new site MyBlog\n```\n\n### 新增主題\n\n創建好專案後，就可以來新增主題，目前在 Hugo 上提供非常多的主題，我們可以到官方的這個[網站](https://themes.gohugo.io/)找找看，但目前些不要增加難度，用最官房提供的簡單的 ananke 主題就好，反正主題是隨時都可以換的。\n\n```bash\ncd MyBlog\ngit init\ngit submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke\necho theme = \\\"ananke\\\" >> config.toml\n```\n\n可以看到，官方是建議使用 `git submodule` 的方式新增主題，這樣之後在更新主題的時候也比較方便。\n\n最後一行的 `echo` 指令會在專案底下產生一個 `config.toml` 的檔案，基本上之後所有有關 Hugo 網站的設定，都可以在這裡變更。這一行指令應該會幫你在檔案中產生如下的內容：\n\n```toml\ntheme = \"ananke\"\n```\n\n### 新增文章\n\n在 Hugo 中新增文章的指令就是如下，可以自己修改檔名。\n\n```bash\nhugo new posts/my-first-post.md\n```\n\n產生完成後可以看到 Hugo 幫你產生了一些 Front Matter。\n\n```md\n---\ntitle: \"My First Post\"\ndate: 2019-03-26T08:47:11+01:00\ndraft: true\n---\n```\n\n上面的 `draft` 的指令是草稿的意思，如果沒有在上線前改成 `false`，是不會在正式網站中渲染的。\n\n現在可以自己產生的 Markdown 檔案中加一些內容，等等就可以看看效果怎麼樣。\n\n## 執行 Hugo Server\n\n要啟動 Hugo Server 也非常簡單：\n\n```bash\nhugo server -D\n```\n\n上面的 `-D` 參數的意思是把 `draft` 的草稿文件也渲染，如果想要看看上線的網頁會長怎樣，可以不要加上這個參數。\n\n## 產生靜態網頁\n\n這個最簡單了，連猴子都會，`-D` 的參數一樣是渲染草稿文件，可視需求加上。\n\n```bash\nhugo\n```\n\n到這裡就介紹完成所有 Hugo 基本的使用方法了，之後我會介紹如何使用 Github Actio\bn，讓我們每次只需要 Push 專案，Github 就會幫我們重新建置並部署網站。\n\n## Reference\n\n- [Hugo Quick Start](https://gohugo.io/getting-started/quick-start/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Hugo/hugo.md","excerpt":"Hugo 是靜態網頁的產生器，類似 Hexo 和 Jekyll，Hugo 由 go 語言編寫，效率極高，我原本是用 Hexo 在產生文章，後來發現 Hugo 這個好東西，也觀望了一陣子其實是懶，就決定換過來了，目前也用得非常順手。 安裝 Hugo 這是 Hugo 的官網，進去後可以看到一些簡單的介紹和安裝方法。 我蠻推薦在 vscode 的  的方式用 Hugo，因為我自己也是這樣用，這樣就不用…","frontmatter":{"title":"用 Hugo 來寫文章吧","date":"2021-06-06T18:10:46.000Z","draft":false,"tags":["hugo","blog","mac","linux","windows"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f50473d3-1acc-431a-402d-3c79f4170b00/public","description":"Hugo 是靜態網頁的產生器，類似 Hexo 和 Jekyll，Hugo 由 go 語言編寫，效率極高。"}}},{"node":{"id":"ee3543ff-035e-5645-80a8-1eb87f4dfa6f","html":"<p>我目前的工作環境都是用 Ubuntu <del>(被 Windows 氣到)</del>，前幾天我重新安裝 Ubuntu 的時候，一直安裝失敗，重新安裝四、五次後都沒有畫面，最後才發現是顯卡驅動問題。</p>\n<blockquote>\n<p>聽說 Ubuntu 開機沒有畫面或是只有 Logo，十次有九次都是顯卡驅動的問題</p>\n</blockquote>\n<!--more-->\n<h2>解決問題</h2>\n<p>在開機引導時會看到這個畫面，立馬按下鍵盤上的 <code class=\"language-text\">c</code> 鍵。</p>\n<p><img src=\"https://i.stack.imgur.com/8RYuZ.png\" alt=\"img\"></p>\n<p>按下 c 後，會以下畫面，找到 <code class=\"language-text\">quite splash</code>。</p>\n<p><img src=\"https://i.stack.imgur.com/0Cfhc.png\" alt=\"img\"></p>\n<p>把 <code class=\"language-text\">quite splash</code> 改成 <code class=\"language-text\">nomodeset</code>，不要懷疑，把兩個字刪掉，改成一個字，改錯也沒關係，下次重開就會復原。</p>\n<p>改完後，按下 <code class=\"language-text\">f10</code> 應該就可以順利進入系統，只是是在沒有顯卡驅動的狀態，畫面可能非常不流暢，所以我們現在來安裝顯卡驅動。</p>\n<h2>顯卡驅動</h2>\n<p>開啟 Terminal，輸入下面的指令，可以自動檢查顯卡的驅動</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ubuntu-drivers devices</code></pre></div>\n<p>應該可以看到其中一項後面有 recommended，基本上安裝那個版本就沒有問題。下面我們直接用自動安裝的方式安裝推薦的驅動。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ubuntu-drivers autoinstall</code></pre></div>\n<p>如果你懶的關心 <code class=\"language-text\">autoinstall</code> 會幫你安裝哪個版本，基本上直接執行上面的指令就可以解決問題了。</p>\n<p>安裝完成後重開機，如果沒有遇到其他問題，這樣應該就可以順利進入系統了。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://askubuntu.com/questions/162075/my-computer-boots-to-a-black-screen-what-options-do-i-have-to-fix-it\">My computer boots to a black screen, what options do I have to fix it?</a></li>\n</ul>","rawMarkdownBody":"\n我目前的工作環境都是用 Ubuntu ~~(被 Windows 氣到)~~，前幾天我重新安裝 Ubuntu 的時候，一直安裝失敗，重新安裝四、五次後都沒有畫面，最後才發現是顯卡驅動問題。\n\n> 聽說 Ubuntu 開機沒有畫面或是只有 Logo，十次有九次都是顯卡驅動的問題\n\n<!--more-->\n\n## 解決問題\n\n在開機引導時會看到這個畫面，立馬按下鍵盤上的 `c` 鍵。\n\n![img](https://i.stack.imgur.com/8RYuZ.png)\n\n按下 c 後，會以下畫面，找到 `quite splash`。\n\n![img](https://i.stack.imgur.com/0Cfhc.png)\n\n把 `quite splash` 改成 `nomodeset`，不要懷疑，把兩個字刪掉，改成一個字，改錯也沒關係，下次重開就會復原。\n\n改完後，按下 `f10` 應該就可以順利進入系統，只是是在沒有顯卡驅動的狀態，畫面可能非常不流暢，所以我們現在來安裝顯卡驅動。\n\n## 顯卡驅動\n\n開啟 Terminal，輸入下面的指令，可以自動檢查顯卡的驅動\n\n```bash\nsudo ubuntu-drivers devices\n```\n\n應該可以看到其中一項後面有 recommended，基本上安裝那個版本就沒有問題。下面我們直接用自動安裝的方式安裝推薦的驅動。\n\n```bash\nsudo ubuntu-drivers autoinstall\n```\n\n如果你懶的關心 `autoinstall` 會幫你安裝哪個版本，基本上直接執行上面的指令就可以解決問題了。\n\n安裝完成後重開機，如果沒有遇到其他問題，這樣應該就可以順利進入系統了。\n\n## Reference\n\n- [My computer boots to a black screen, what options do I have to fix it?](https://askubuntu.com/questions/162075/my-computer-boots-to-a-black-screen-what-options-do-i-have-to-fix-it)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Linux/ubuntu-black-screen.md","excerpt":"我目前的工作環境都是用 Ubuntu (被 Windows 氣到)，前幾天我重新安裝 Ubuntu 的時候，一直安裝失敗，重新安裝四、五次後都沒有畫面，最後才發現是顯卡驅動問題。 聽說 Ubuntu 開機沒有畫面或是只有 Logo，十次有九次都是顯卡驅動的問題 解決問題 在開機引導時會看到這個畫面，立馬按下鍵盤上的  鍵。 img 按下 c 後，會以下畫面，找到 。 img 把  改成 ，不要懷…","frontmatter":{"title":"Ubuntu 開機黑屏","date":"2021-06-05T17:17:17.000Z","draft":false,"tags":["ubuntu"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/87c17ef3-d429-42ba-30ab-32ac2864c500/public","description":"聽說 Ubuntu 開機沒有畫面或是只有 Logo，十次有九次都是顯卡驅動的問題。"}}},{"node":{"id":"ef50281c-b92b-5cc4-9c42-2f5e4b971e4d","html":"<p>學過 Docker 的人都應該有用過 Docker Playground 來學習或是測試過軟體，不想在本機跑 Docker 可以先用 Docker Playground 試試看軟體可不可以跑。</p>\n<!--more-->\n<p>官方已經有架設 <a href=\"https://labs.play-with-docker.com/\">Docker Playground</a>，可以讓大家方便使用，但我使用的時後常發現他會 Lag，也不知道是 Docker Server 的問題，還是臺灣網路的問題。剛好最近想要教社團 Docker，這樣我架好一個，大家就不需要準備環境，直接就可以開始學了。</p>\n<p>本專案的 <a href=\"https://github.com/play-with-docker/play-with-docker\">GitHub</a></p>\n<h2>準備環境</h2>\n<ul>\n<li>\n<p>Docker <code class=\"language-text\">18.06.0+</code></p>\n</li>\n<li>\n<p>Go 最新版</p>\n</li>\n</ul>\n<p>以上的安裝兩個在這邊都不贅述，請自行參閱官方文檔。</p>\n<h2>開始部署</h2>\n<h3>第一步：下載專案</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> clone https://github.com/play-with-docker/play-with-docker\n<span class=\"token builtin class-name\">cd</span> play-with-docker</code></pre></div>\n<h3>第二步：確認驅動</h3>\n<p>其實我不是很確定這一步驟是要幹嘛，但是官方文檔有寫到，但是我在 Mac 上無法執行此命令，也可以順利部署。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> modprobe xt_ipvs</code></pre></div>\n<h3>第三步：Docker swarm</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> swarm init</code></pre></div>\n<h3>第四步：下載 image</h3>\n<p>這個 Image 是之後在 PWD 中創建容器時要用到的 Image。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> pull franela/dind</code></pre></div>\n<h3>第五步：go mod</h3>\n<p>這步也是非必要的，我也不懂 Golang 所以也不確定是要幹嘛。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">go mod vendor</code></pre></div>\n<h3>最後：啟動</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker-compose</span> up</code></pre></div>\n<p>若沒有其他問題，理論上現在連接到 <code class=\"language-text\">http://localhost:80</code> 就可以看到 PWD 正在執行，也可以開始創建容器使用。</p>\n<h2>localhost or 404</h2>\n<p>上一段的最後寫到可以連接到 localhost，但如果你試著用 localhost 以外的方式連接，就會出現問題，不管是 <code class=\"language-text\">127.0.0.1</code> 或是用網址 <code class=\"language-text\">pwd.example.com</code> 之類的都沒有辦法連接到 PWD，會不斷地出現 404，就是只有 localhost 可以。官方的文件就寫到這裡，也沒寫解法，以下是我自己發現的解決方法。</p>\n<p>基本上這個問題是 DNS 解析發生的問題，PWD 一次只能解析一種網址，預設是 <code class=\"language-text\">localhost</code>，我們可以去他的設定檔中變更他。</p>\n<p>設定檔案在 <code class=\"language-text\">play-with-docker/config/config.go</code> 之中，其中會有一行長下面的樣子：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">flag<span class=\"token punctuation\">.</span><span class=\"token function\">StringVar</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>PlaygroundDomain<span class=\"token punctuation\">,</span> <span class=\"token string\">\"playground-domain\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"localhost\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Domain to use for the playground\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>可以看到 PWD 這裡可以設定要解析的網址就是 <code class=\"language-text\">localhost</code>，所以只要將此變更為 <code class=\"language-text\">pwd.example.com</code>，就可以用這個網址連上 PWD。</p>\n<h3>連上容器內的 Port</h3>\n<p>就算做完上面的設定，也順利了啟動 Docker 容器，但最後才發現想要連上特定的 Port 還是會失敗，因為他是用子網域的方式去連線 <code class=\"language-text\">http://ip&lt;hyphen-ip>-&lt;session_jd>-&lt;port>.direct.pwd.example.com</code>，所以又會遇到無法解析 DNS 的情況，我的解法是在 DNS 的設定中把 <code class=\"language-text\">pwd.example.com</code> 和 <code class=\"language-text\">*.pwd.example.com</code> 都加入 A Record，才順利連上。</p>\n<h2>Nginx Proxy Pass</h2>\n<p>這部分我研究了蠻久，如果要把 Server 隱藏在 Nginx 後面，要設定的東西比較複雜，因為 PWD 有使用到 WebSocket，但是這部分我沒有過多的心得，所以直接把我的 <code class=\"language-text\">conf</code> 放在下面，容我不做解釋了：</p>\n<div class=\"gatsby-highlight\" data-language=\"nginx\"><pre class=\"language-nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">map</span> <span class=\"token variable\">$http_upgrade</span> <span class=\"token variable\">$connection_upgrade</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">default</span> upgrade</span><span class=\"token punctuation\">;</span>\n    ''      <span class=\"token directive\"><span class=\"token keyword\">close</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">listen</span>       <span class=\"token number\">80</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server_name</span>  pwd.example.com *.pwd.example.com</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">location</span> /</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_pass</span> http://192.168.1.1:80</span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Upgrade <span class=\"token variable\">$http_upgrade</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Connection <span class=\"token variable\">$connection_upgrade</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span> Host <span class=\"token variable\">$host</span></span><span class=\"token punctuation\">;</span>\n        <span class=\"token directive\"><span class=\"token keyword\">proxy_cache_bypass</span> <span class=\"token variable\">$http_upgrade</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token directive\"><span class=\"token keyword\">error_page</span>   <span class=\"token number\">500</span> <span class=\"token number\">502</span> <span class=\"token number\">503</span> <span class=\"token number\">504</span>  /50x.html</span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">location</span> = /50x.html</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token directive\"><span class=\"token keyword\">root</span>   /usr/share/nginx/html</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面是假設 PWD Server 跑在 <code class=\"language-text\">192.168.1.1:80</code> 上。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://github.com/play-with-docker/play-with-docker\">Play With Docker</a></li>\n</ul>","rawMarkdownBody":"\n學過 Docker 的人都應該有用過 Docker Playground 來學習或是測試過軟體，不想在本機跑 Docker 可以先用 Docker Playground 試試看軟體可不可以跑。\n\n<!--more-->\n\n官方已經有架設 [Docker Playground](https://labs.play-with-docker.com/)，可以讓大家方便使用，但我使用的時後常發現他會 Lag，也不知道是 Docker Server 的問題，還是臺灣網路的問題。剛好最近想要教社團 Docker，這樣我架好一個，大家就不需要準備環境，直接就可以開始學了。\n\n本專案的 [GitHub](https://github.com/play-with-docker/play-with-docker)\n\n## 準備環境\n\n- Docker `18.06.0+`\n\n- Go 最新版\n\n以上的安裝兩個在這邊都不贅述，請自行參閱官方文檔。\n\n## 開始部署\n\n### 第一步：下載專案\n\n```bash\ngit clone https://github.com/play-with-docker/play-with-docker\ncd play-with-docker\n```\n\n### 第二步：確認驅動\n\n其實我不是很確定這一步驟是要幹嘛，但是官方文檔有寫到，但是我在 Mac 上無法執行此命令，也可以順利部署。\n\n```bash\nsudo modprobe xt_ipvs\n```\n\n### 第三步：Docker swarm\n\n```bash\ndocker swarm init\n```\n\n### 第四步：下載 image\n\n這個 Image 是之後在 PWD 中創建容器時要用到的 Image。\n\n```bash\ndocker pull franela/dind\n```\n\n### 第五步：go mod\n\n這步也是非必要的，我也不懂 Golang 所以也不確定是要幹嘛。\n\n```bash\ngo mod vendor\n```\n\n### 最後：啟動\n\n```bash\ndocker-compose up\n```\n\n若沒有其他問題，理論上現在連接到 `http://localhost:80` 就可以看到 PWD 正在執行，也可以開始創建容器使用。\n\n## localhost or 404\n\n上一段的最後寫到可以連接到 localhost，但如果你試著用 localhost 以外的方式連接，就會出現問題，不管是 `127.0.0.1` 或是用網址 `pwd.example.com` 之類的都沒有辦法連接到 PWD，會不斷地出現 404，就是只有 localhost 可以。官方的文件就寫到這裡，也沒寫解法，以下是我自己發現的解決方法。\n\n基本上這個問題是 DNS 解析發生的問題，PWD 一次只能解析一種網址，預設是 `localhost`，我們可以去他的設定檔中變更他。\n\n設定檔案在 `play-with-docker/config/config.go` 之中，其中會有一行長下面的樣子：\n\n```go\nflag.StringVar(&PlaygroundDomain, \"playground-domain\", \"localhost\", \"Domain to use for the playground\")\n```\n\n可以看到 PWD 這裡可以設定要解析的網址就是 `localhost`，所以只要將此變更為 `pwd.example.com`，就可以用這個網址連上 PWD。\n\n### 連上容器內的 Port\n\n就算做完上面的設定，也順利了啟動 Docker 容器，但最後才發現想要連上特定的 Port 還是會失敗，因為他是用子網域的方式去連線 `http://ip<hyphen-ip>-<session_jd>-<port>.direct.pwd.example.com`，所以又會遇到無法解析 DNS 的情況，我的解法是在 DNS 的設定中把 `pwd.example.com` 和 `*.pwd.example.com` 都加入 A Record，才順利連上。\n\n## Nginx Proxy Pass\n\n這部分我研究了蠻久，如果要把 Server 隱藏在 Nginx 後面，要設定的東西比較複雜，因為 PWD 有使用到 WebSocket，但是這部分我沒有過多的心得，所以直接把我的 `conf` 放在下面，容我不做解釋了：\n\n```nginx\nmap $http_upgrade $connection_upgrade {\n    default upgrade;\n    ''      close;\n}\n\nserver {\n    listen       80;\n    server_name  pwd.example.com *.pwd.example.com;\n\n    location / {\n        proxy_pass http://192.168.1.1:80;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection $connection_upgrade;\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n    }\n\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n}\n```\n\n上面是假設 PWD Server 跑在 `192.168.1.1:80` 上。\n\n## Reference\n\n- [Play With Docker](https://github.com/play-with-docker/play-with-docker)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Docker/pwd-hosting.md","excerpt":"學過 Docker 的人都應該有用過 Docker Playground 來學習或是測試過軟體，不想在本機跑 Docker 可以先用 Docker Playground 試試看軟體可不可以跑。 官方已經有架設 Docker Playground，可以讓大家方便使用，但我使用的時後常發現他會 Lag，也不知道是 Docker Server 的問題，還是臺灣網路的問題。剛好最近想要教社團 Docke…","frontmatter":{"title":"自架 Play With Docker","date":"2021-06-05T16:08:29.000Z","draft":false,"tags":["docker","play-with-docker","nginx"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f6db1841-15c5-40fc-7174-8a5e73647700/public","description":"學過 Docker 的人都應該有用過 Docker Playground 來學習或是測試過軟體，不想在本機跑 Docker 可以先用 Docker Playground 試試看軟體可不可以跑。"}}},{"node":{"id":"3017bf12-85be-53c2-8f3c-5b82fb78ad3c","html":"<p>This is my first <code class=\"language-text\">post</code> in hugo.</p>\n<p><a href=\"google.com\">google</a></p>\n<!--more-->\n<h2>Kotlin</h2>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">hi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\"><span class=\"token keyword\">this</span></span></span><span class=\"token string\"> HI\"</span></span>\n\n<span class=\"token keyword\">class</span> <span class=\"token function\">Test</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> p <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"13 13\"</span></span>\n    <span class=\"token keyword\">var</span> p <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"--------------------------------------------------------------------------------------------------\"</span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>meilisearch</p>\n<h3>引用</h3>\n<blockquote>\n<p>引引用引用引用引用引用引用引用引用引用引用引用引用引用引用引用用引用引用</p>\n</blockquote>\n<h3>Test list</h3>\n<p>ol</p>\n<ol>\n<li>one</li>\n<li>two</li>\n<li>three</li>\n<li><a href=\"google.com\">google</a></li>\n</ol>\n<p>ul</p>\n<ul>\n<li>one</li>\n<li>two</li>\n<li>three</li>\n</ul>\n<p>ul ul</p>\n<ul>\n<li>one\n<ul>\n<li>one</li>\n</ul>\n</li>\n<li>two\n<ul>\n<li>two</li>\n<li>three</li>\n</ul>\n</li>\n<li>three\n<ul>\n<li>four\n-five</li>\n</ul>\n</li>\n</ul>\n<p>preview</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/be2106f3-0557-4e94-803a-9dda63550300/preview\" alt=\"img\"></p>\n<p>public</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/be2106f3-0557-4e94-803a-9dda63550300/public\" alt=\"img\"></p>","rawMarkdownBody":"\nThis is my first `post` in hugo.\n\n[google](google.com)\n\n<!--more-->\n\n## Kotlin\n\n```kotlin\nfun String.hi() = \"$this HI\"\n\nclass Test(var i: Int) {\n    var p = \"13 13\"\n    var p = \"--------------------------------------------------------------------------------------------------\"\n}\n```\n\nmeilisearch\n\n### 引用\n\n> 引引用引用引用引用引用引用引用引用引用引用引用引用引用引用引用用引用引用\n\n### Test list\n\nol\n\n1. one\n2. two\n3. three\n4. [google](google.com)\n\nul\n\n- one\n- two\n- three\n\nul ul\n\n- one\n  - one\n- two\n  - two\n  - three\n- three\n  - four\n    -five\n\npreview\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/be2106f3-0557-4e94-803a-9dda63550300/preview)\n\npublic\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/be2106f3-0557-4e94-803a-9dda63550300/public)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Others/hello-world.md","excerpt":"This is my first  in hugo. google Kotlin meilisearch 引用 引引用引用引用引用引用引用引用引用引用引用引用引用引用引用引用用引用引用 Test list ol one two three google ul one two three ul ul one one two two three three four\n-five preview im…","frontmatter":{"title":"Hello World","date":"2021-06-05T11:15:18.000Z","draft":false,"tags":null,"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c5285615-fab6-46e7-b548-1528e0be0d00/large","description":"Hello World. This is a test post."}}}]}},"pageContext":{}},"staticQueryHashes":[]}