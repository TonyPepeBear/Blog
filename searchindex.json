[{"id":0,"date":"1642168105","url":"https://tonypepebear.github.io/HugoBlog/posts/web/iconify/","title":"Iconify -- icon 大禮包","summary":"GitHub 上有許許多多開源的 icon，但是每個用法不盡相同，甚至大部分的使用方式，都是直接下載 SVG 使用。雖然使用 SVG 也不是不好，但是就會需要自己多一步驟的使用。Iconify 把許多 icon 整合在一起，並且提供非常簡單的辦法，就可以讓網頁有很精美的 icon。\n","content":"GitHub 上有許許多多開源的 icon，但是每個用法不盡相同，甚至大部分的使用方式，都是直接下載 SVG 使用。雖然使用 SVG 也不是不好，但是就會需要自己多一步驟的使用。Iconify 把許多 icon 整合在一起，並且提供非常簡單的辦法，就可以讓網頁有很精美的 icon。\n使用 Iconify 使用 Iconify 只需要先在 HTML 中引入 Iconify 的 Script：\n\u0026lt;script src=\u0026#34;https://code.iconify.design/2/2.1.0/iconify.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 接下來只需要在要使用 icon 的地方，新增一個 span，其中要有包含 class=\u0026quot;iconify\u0026quot; 和 data-icon：\n\u0026lt;span class=\u0026#34;iconify\u0026#34; data-icon=\u0026#34;fa:home\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 正確使用後，應該就可以在網頁中正確的顯示下面的 icon：\n搜尋 Icon 就像前面說的，Iconify 提供非常多的 icon，所以作者也有寫一個可以搜尋圖標的地方，而且搜尋到圖標後，還提供許多可以協助客製化圖標的方法：\n如果真的不想使用 Iconify 的方式顯示圖標，也可以單純的當作圖標蒐尋器，搜尋到之後直接下載 SVG 使用即可。\nReference  Iconify ","tags":["icon","web","ios","android","design"],"section":"posts"},{"id":1,"date":"1639233015","url":"https://tonypepebear.github.io/HugoBlog/posts/telegram/go-tg-bot/","title":"用 Go 寫 Telegram Bot","summary":"Telegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。","content":"Telegram Bot 沒有任何使用限制，可以寫出許多屬於自己的幫手。本篇簡單的用 Go 寫一個鸚鵡機器人，用戶說什麼，機器人就回什麼。\n新增自己的 Bot Telegram 非常有趣，要新增自己的 Bot，只要跟 Telegram 上的 BotFather 說一下，他就會給你一個 Bot。\n按 BotFather 給你的步驟做，最後可以看到他會提供一個 API Token 給你，只要有這個 Token 就可以跟 Bot 溝通，要保存好，等等會用到，也不要給別人看到，以免自己的 Bot 變成別人的玩具。\ngo-telegram-bot-api Go 已經有社區開發的函式庫可以用 telegram-bot-api。\ngo get -u github.com/go-telegram-bot-api/telegram-bot-api/v5 之後只要 import 就可以使用：\nimport ( tgbotapi \u0026#34;github.com/go-telegram-bot-api/telegram-bot-api/v5\u0026#34; ) 連線到 Telegram Bot 利用剛剛 import 的函式庫，只需要剛剛創建好的 Bot 的 API Token 就可以連線到 Telegram。\nbot, err := tgbotapi.NewBotAPI(os.Getenv(\u0026#34;TELEGRAM_API_TOKEN\u0026#34;)) if err != nil { panic(err) } 上面用環境變數的方式來取得 TOKEN，避免需要直接寫在程式碼裡，如果覺得在測試時設定環境變數很麻煩，可以用 JetBrains 的 GoLand，設定 Runtime 的環境變數：\n處理 Update 要接收使用者傳過來的訊息，Telegram API 稱為 Update，我們使用的函示庫基本上都自動處理好了，只需要接收一個 Channel 就好。使用 bot.GetUpdatesChan(config) 會需要給一個 Config，這可以用 tgbotapi.NewUpdate(0) 來生，然後這邊設定 Timeout 為 60，如果對這個設定值有興趣，可以去看 Telegram 的文件。\nupdateConfig := tgbotapi.NewUpdate(0) updateConfig.Timeout = 60 updates := bot.GetUpdatesChan(updateConfig) 回復 我們先簡單寫一隻鸚鵡，把用戶傳過來的 Text，直接傳回去。\n用 for 把 Channel 中的 Update 一個一個拿出來，然後用 tgbotapi 產生一個 Message 物件，裡面放在聊天室的 ID 和要回傳的 Text，最後用 bot 把 Message 傳回去。\nfor update := range updates { text := update.Message.Text chatID := update.Message.Chat.ID replyMsg := tgbotapi.NewMessage(chatID, text) _, _ = bot.Send(replyMsg) } 簡單鸚鵡的完整程式碼 package main import ( tgbotapi \u0026#34;github.com/go-telegram-bot-api/telegram-bot-api/v5\u0026#34; \u0026#34;os\u0026#34; ) func main() { bot, err := tgbotapi.NewBotAPI(os.Getenv(\u0026#34;TELEGRAM_API_TOKEN\u0026#34;)) if err != nil { panic(err) } bot.Debug = true updateConfig := tgbotapi.NewUpdate(0) updateConfig.Timeout = 60 updates := bot.GetUpdatesChan(updateConfig) for update := range updates { text := update.Message.Text chatID := update.Message.Chat.ID replyMsg := tgbotapi.NewMessage(chatID, text) _, _ = bot.Send(replyMsg) } } 改寫成非阻塞的 Goroutine 因為每次處理和回復都會需要一點時間，甚至是要去 DB 找資料，如果用上面的寫法，在處理多人或高速傳訊息的時候會被卡住，一次只能處理的一個訊息。還好 Go 的併發寫法非常簡單，只要放一個 go 在前面，就可以非阻塞的執行 function 中的內容。\n我們先把 handleUpdate 提取成一個 function，然後再用 go 去執行他：\nfunc main() { bot, err := tgbotapi.NewBotAPI(os.Getenv(\u0026#34;TELEGRAM_API_TOKEN\u0026#34;)) if err != nil { panic(err) } bot.Debug = true updateConfig := tgbotapi.NewUpdate(0) updateConfig.Timeout = 60 updates := bot.GetUpdatesChan(updateConfig) for update := range updates { go handleUpdate(bot, update) } } func handleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) { text := update.Message.Text chatID := update.Message.Chat.ID replyMsg := tgbotapi.NewMessage(chatID, text) _, _ = bot.Send(replyMsg) } 回復特定訊息 要回復 回復訊息 ，像是下面的效果也很簡單：\n只需要設定 replyMsg.ReplyToMessageID 就可以回復特定的訊息，下面就是直接回覆接收到的訊息：\nfunc handleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) { text := update.Message.Text chatID := update.Message.Chat.ID replyMsg := tgbotapi.NewMessage(chatID, text) replyMsg.ReplyToMessageID = update.Message.MessageID _, _ = bot.Send(replyMsg) } 處理 Command Telegram 中，用 / 開頭的文字就是 Command，這個函示庫也有寫好處理 Command 的方法，只需要用 isCommand()，確認一下是不是 Command 就可以：\nfunc handleUpdate(bot *tgbotapi.BotAPI, update tgbotapi.Update) { text := update.Message.Text chatID := update.Message.Chat.ID replyMsg := tgbotapi.NewMessage(chatID, text) if update.Message.IsCommand() { switch update.Message.Command() { case \u0026#34;start\u0026#34;: replyMsg.Text = \u0026#34;Hello \u0026#34; + update.Message.From.FirstName case \u0026#34;help\u0026#34;: replyMsg.Text = \u0026#34;What can I help you?\u0026#34; default: replyMsg.Text = \u0026#34;No such command!!!\u0026#34; } } _, _ = bot.Send(replyMsg) } 上面的程式碼其實也可以看到如何拿到傳送者的一些基本資料。\nReference  Telegram APIs Golang bindings for the Telegram Bot API - GitHub ","tags":["go","golang","telegram","bot","telegram-bot"],"section":"posts"},{"id":2,"date":"1636005164","url":"https://tonypepebear.github.io/HugoBlog/posts/flutter/dart-function-lambda-diff/","title":"Flutter/Dart (){} 和 () =\u003e 的差別","summary":"Flutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是 () {} 寫法，另一個是 () = 寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。","content":"Flutter 因為大量使用依賴注入，所以常常會需要傳入 Function。傳入 Function 時，常常會看到兩種寫法，一下是 () {} 寫法，另一個是 () =\u0026gt; 寫法。我剛開始寫的時候被搞得頭昏腦脹，查了一下才發現這兩個本身沒什麼不同。\n不同在哪 下面我用在寫 Flutter 中常見的創建一個有 10 個 Text 的 List 舉例。\n創建一個有 10 項元素的 List：\nList\u0026lt;Text\u0026gt; list = List.generate(10, (index) =\u0026gt; Text(index.toString())); 上面就是輸出一個帶有 0-9 的 List，那現在假設我會需要再創建 Text 前，根據 index 來做一些改變，下面就做最簡單的平方。\nList\u0026lt;Text\u0026gt; list = List.generate(10, (index) { // do some work  var text = (index * index).toString(); return Text(text); }); 觀察上面兩個例子，不難發現兩個的差別，第一個寫法 () =\u0026gt; 後面直接接上一個表達式(Expression)，當作回傳值。而 () {} 則是在大括號中寫一個完整的 Function，所以要寫一個 return。\nReference  Flutter/Dart - Difference between () {} and () =\u0026gt; {} ","tags":["dart","flutter","function"],"section":"posts"},{"id":3,"date":"1633450258","url":"https://tonypepebear.github.io/HugoBlog/posts/web/cloudflare-speed-week/","title":"Cloudflare Speed Week","summary":"上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。","content":"上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。\n No one likes to wait. Internet impatience is something we all suffer from.\n 文章一開頭就用一句點出大家在上網時會遇到的狀況，沒有人喜歡等待，可是所有人都在上網時身受其害，相信大家都遇過下面的情況：\n 等待 App 完成內容更新 等待網頁出現 等待電影開始播放  但有寫過程式或服務的都知道，人一多，就一定慢，非常的難避免，所以這時候就要用 Cloudflare，這時又宣傳了一下 Cloudflare。\n許多使用者家裡都會覺得網路很慢，然後買了很快很快的網速，像是 100Mbpa, 1Gbps 甚至 2Gbps，但其實就算家裡的網路再怎麼快，你連線的 Server 就是很慢，你的上網體驗還是大打折扣。\n如果要讓自己的服務不卡，只需要完成下面三樣要求：\n Server 有充足的帶寬 讓 Server 盡量接近 User 讓你的 Web 或 App 盡量得快  看起來很簡單，但如果要完成這三個要求，都會耗費極大的成本。\nDNS 現今的網路世界主要是由 ipv4 組成，也就是說，如果沒有 ipv4 地址，所有的網路連線都不會發生，如果我只知道 www.fcu.edu.tw，是完全沒有辦法上網的，因為我並不知道這個網址對應的 ip 是多少 (像是 140.134.xxx.xxx)，就完全沒有辦法和伺服器產生連線。DNS 出現前，大家都是直接用 ip 溝通，快速方便，最大的缺點就是非常難記。所以 DNS 就出現了，DNS 就像你打電話會需要電話簿一樣，我只我需要一個簡單好記的名字，再去電話簿搜尋真正的電話號碼就好。\n在知道電話號碼前，所有網路連線都不會發生，所以用最快速的方式查找電話簿絕對是上網速度最重要的一環，如果光是要知道 ip 位置就花掉 50ms(甚至更多)，上網效率就會大大降低。如今網路上有許多的 DNS 提供商，為大家記下這龐大的 DNS 電話簿，最著名的就是 Google 的 8.8.8.8，和 Cloudflare 的 1.1.1.1，Cloudflare 宣稱他是全世界最快的 DNS 提供商，(雖然在台灣好像未必)，但 Cloudflare 承諾他不會紀錄使用者查過的 DNS 紀錄，或上過什麼網頁 (好像是在暗示競爭對手會這麼做)。\n另外，就算 DNS 伺服器完全不假思索 (沒有反應時間) 就回傳 DNS 的查詢結果，這也付出了至少一個光速的代價，聽起來好像沒什麼影響，但可以看看下面簡單的計算。\n光速損耗 假設我家和 DNS 伺服器之間的直線距離是 100 公里，而且中華電信筆直的連接了一條筆直光纖到 DNS 伺服器，而光在光纖中的速度是 200,000,000 公尺/秒，往返需要 200,000 公尺。經過這樣簡單的計算，光是光速就已經耗費整整 1 毫秒(ms)，可以試著想想看更糟的情況，光速已經開始在嚴重拖累網速。\nHello Hello OK 知道了 ip 後，瀏覽器終於可以連上目標伺服器取得網頁，不久後就可以看到網頁出現在眼前。\n上面的步驟，幾乎都是由 TCP 協定完成，協定的第一步就是你的電腦和伺服器互相同意連線，這個過程稱作三向交握 (Three-Way Handshake)，步驟如下：\n Client 對 Server 說：Hello Server 對 Client 說：我聽到你說 Hello Client 對 Server 說：我聽到 \u0026ndash; 你說你聽到我說 Hello，我們現在可以溝通了。  從上面的步驟就可以發現，已經至少耗費了一個光速的時間，所以也是一樣，伺服器愈靠近用戶，網速就愈快。這也是為什麼 Cloudflare 在世界各地廣設伺服器。\nTLS/SSL 有了 TCP 我們就可以安全的連線了嗎？當然不是，TCP 一點也不安全，現在的網路連線幾乎都是透過 TLS (或稱作 SSL) 加密連線，所以 TCP 連線後，下一步是建立安全的加密連線。\nTLS 是一個非常複雜的加密協定，會牽涉到下面的設備：網路瀏覽器、建立鑰匙的伺服器，而且還要有一個可以證明他的身分的伺服器，因為不會想要和銀行建立安全連線，但你根本不確定他是不是你的銀行。\n上面的步驟也會需要好幾次光速損耗，所以讓伺服器愈靠近用戶端愈好。另外，也要盡量使用最新的 TLS 標準 (現在是 TLS 1.3)。\n後記 我覺得這篇文章最有趣的的部分就是一直在討論光速對網路連線的影響，以往我都覺得光速很快，但光就算很快，光也是要跑很長一段距離，這樣耗損來回個幾次就已經對網路連線產生極大的影響了，而且更何況一個連線就一定會需要來回溝通好幾次。這篇文章後面還有蠻多內容，但我覺得沒有那麼重要就懶得寫了，有興趣的話可以自己繼續往下看。\nReference  Welcome to Speed Week and a Waitless Internet ","tags":["cloudflare","web","internet","tcp"],"section":"posts"},{"id":4,"date":"1632036416","url":"https://tonypepebear.github.io/HugoBlog/posts/kotlin/kotlin-coroutine/","title":"Kotlin Coroutine","summary":"Kotlin 在非同步處理上有新的方法，協程 Coroutine，Coroutine 不會像 Thread 會耗費大量的資源，能在原本的線程上創建極為輕量的協程，且較不會發生記憶體洩漏的情況。","content":"Kotlin 在非同步處理上有新的方法，協程 Coroutine。Coroutine 不會像 Thread 會耗費大量的資源，能在原本的線程上創建極為輕量的協程，且較不會發生記憶體洩漏的情況。\n導入 Coroutine 在 build.gradle 中添加依賴項\ndependencies { implementation \u0026#39;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2\u0026#39; } 若要在 Android 中使用需要再添加 Android 依賴\nimplementation \u0026#39;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2\u0026#39; 第一個 Coroutine import kotlinx.coroutines.* fun main() { GlobalScope.launch { //在後台啟動一個新的縣協程  delay(1000L) //非阻塞式的等待 1 秒鐘  println(\u0026#34;World!\u0026#34;) } println(\u0026#34;Hello,\u0026#34;) Thread.sleep(2000L) // 阻塞主線程兩秒確保主線程存活 } 上面的程式碼輸出結果：\nHellow, World 基本上 Coroutine 就是輕量的協程\n也可以分別將 GlobalScope.launch{...} 和 delay(...) 替換成thread { ... } 和 Thread.Sleap(...)，也可以得到相同的結果，可以嘗試一下。\n如果只將 GlobalScope.launch{...} 替換成 thread{...} 你會得到以下錯誤：\nError: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function 因為 delay() 是一個特殊的 suspend function (有人譯作 掛起函數)，他不會阻塞線程，但是會 suspend 協程，而且只能在協程中使用。\n橋接阻塞和非阻塞的世界 上面的範例中同時使用了非阻塞式的 delay() 和阻塞式的 Thread.sleap()，這樣很容易讓我們混淆哪個會阻塞線程。下面我們使用 runblocking{...} 來阻塞線程\nimport kotlinx.coroutines.* fun main() { GlobalScope.launch { // 在後台啟動一個新的協程  delay(1000L) println(\u0026#34;World!\u0026#34;) } println(\u0026#34;Hello,\u0026#34;) runBlocking { // 這個表達式會阻塞主線程  delay(2000L) // 延遲兩秒來確保主線程存活  } } 結果基本上是相似的，只是都是使用了非組塞式的 delay()。調用了 runblocking{...} 的主線程會被阻塞直到 runblocking{...} 內的協程執行完畢。\n下面用一個更合乎慣用法的方法在寫一次，用 runblocking{...} 來包裝 main 方法：\nimport kotlinx.coroutines.* fun main() = runBlocking\u0026lt;Unit\u0026gt; { // 開始執行主協程  GlobalScope.launch { // 在後台啓動一個協程並繼續執行  delay(1000L) println(\u0026#34;World!\u0026#34;) } println(\u0026#34;Hello,\u0026#34;) delay(2000L) // 延遲 2 秒來確保主線程存活 } 這裡的 runBlocking {...} 用來啟動主線程。我們顯式指定了其返回類型 Unit，因為在 Kotlin 中 main 方法必須回傳 Unit。\n等待一個作業完成 延遲一段時間來確保協程的運行並不是一個好辦法利用 job.join() 來確保工作執行結束。\nval job: Job = GlobalScope.launch { delay(1000L) println(\u0026#34;World!\u0026#34;) } println(\u0026#34;Hello,\u0026#34;) job.join() launch 會回傳一個 Job 物件，而 job.join() 其實就是會等待 job 的工作完成再繼續持行。\n我們也可以利用 job.cancel() 取消協程：\nval job: Job = GlobalScope.launch { delay(1000L) println(\u0026#34;World!\u0026#34;) } println(\u0026#34;Hello,\u0026#34;) job.cancel() 但是如果 job 已經完成工作，cancel 是不會發生任何事。\n參考資料  Coroutine Basics ","tags":["kotlin","coroutine"],"section":"posts"},{"id":5,"date":"1631596287","url":"https://tonypepebear.github.io/HugoBlog/posts/git/git-submodule/","title":"Git Submodule","summary":"要在一個 Git 專案中有子專案 (我稱為 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄","content":"要在一個 Git 專案中有子專案 (我稱為 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄 submodule 的路徑和 commit 版本。\nAdd Submodule 要將專案新增到現有的目錄中，可以使用 git submodule add：\ngit submodule add \u0026lt;repo_url\u0026gt; \u0026lt;folder\u0026gt; 執行後，可以看到 git 會自動幫你把 submodule clone 到指定的目錄中，並多了一個檔案 .gitmodules，這個檔案就是上面說到的 Submodule 只紀錄 commit 版本，和 Submodule URL 的檔案。\nadd submodule 後，還是要 commit，因為 Submodule 也就只是紀錄要用子專案的哪一個 commit 版本，所以也可以確保大家都是使用到同一個 Submodule 的版本。可以試著將專案 commit and push 到 GitHub 上，應該可以看到 Submodule 就是連結到另外一個專案的某一個 commit，下面是本站的 Hugo 主題的 submodule：\nClone Submodule 在 Clone 含有 Submodule 的專案時，Git 預設是不會自動 clone 子專案的，需要加上 --recursive 這個參數，才會自動把 Submodule 也 Clone 下來。\ngit clone --recursive \u0026lt;repo_url\u0026gt; 如果 Clone 下來後才發現有 Submodule，可以用下面的方式補救，把子專案都 Clone 下來：\ngit submodule init git submodule update --recursive ","tags":["git","submodule","linux"],"section":"posts"},{"id":6,"date":"1631457139","url":"https://tonypepebear.github.io/HugoBlog/posts/git/github-ssh/","title":"GitHub SSH","summary":"在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。","content":"在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。\nssh-keygen 要使用 ssh 非對稱加密，就會需要公鑰與私鑰，創建 ssh key 的方法就是 ssh-keygen：\nuser@66c0bf85e710:~$ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/home/user/.ssh/id_rsa): Created directory \u0026#39;/home/user/.ssh\u0026#39;. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/user/.ssh/id_rsa Your public key has been saved in /home/user/.ssh/id_rsa.pub The key fingerprint is: SHA256:+UUuTN0YLUi2eh7HJoJvuy0whUuLvXIQejjPPTZ9gw4 user@66c0bf85e710 The key\u0026#39;s randomart image is: +---[RSA 3072]----+ | .o... | | ..o.+. | | . o +.. | | . o..= + | | o =.+S * * | | + + *. = B | | = oE=o.o | | + Bo+oo | | + +++.. | +----[SHA256]-----+ ssh-keygen 會問一些問題，最快的方式就是直接留白(保持預設)，一直按 enter 就可以看到已經在 ~/.ssh 產生了兩個檔案：\nuser@66c0bf85e710:~$ ls -l ~/.ssh total 8 -rw------- 1 user user 2602 Sep 12 22:42 id_rsa -rw-r--r-- 1 user user 571 Sep 12 22:42 id_rsa.pub user@66c0bf85e710:~$ id_rsa 就是私鑰，而多個 pub 結尾的 id_rsa.pub 就是公鑰。私鑰請不要傳給任何人，公鑰則提供給 GitHub。可以用 cat 將公鑰顯示出來並複製他：\n把公鑰交給 GitHub 到 GitHub 的 Settings -\u0026gt; SSH and GPG keys -\u0026gt; New SSH key：\n把剛剛複製下來的公鑰貼上，Title 可以自己隨便輸入或打這台電腦的名字：\n測試連線 輸入下面命令就可以知道有沒有連線成功，如果有看到自己的使用者名稱，就代表已經完成 ssh 的認證：\nssh -T git@github.com 第一次連線可能會問要不要信任，輸入 yes 即可。\n 如果覺得上面的方法麻煩，也可以直接創建一個私有 repo，然後試著 clone 和 push，就知道有沒有認證成功了。\n Reference  Testing your SSH connection ","tags":["git","github","ssh"],"section":"posts"},{"id":7,"date":"1630505220","url":"https://tonypepebear.github.io/HugoBlog/posts/web/web-basic/","title":"Web Basic","summary":"瀏覽器只看得懂三種東西：Html、CSS、Javascript。但是常可以發現以這些以外的語言編寫網頁，像是 Python、Ruby、PHP、Java 等等，其實這些東西寫出來的網頁，最後也都是編譯(轉換)成 Html、CSS、Javascript。所以要學網頁，就先從這三樣東西開始學。","content":"瀏覽器只看得懂三種東西：Html、CSS、Javascript。但是常可以發現以這些以外的語言編寫網頁，像是 Python、Ruby、PHP、Java 等等，其實這些東西寫出來的網頁，最後也都是編譯(轉換)成 Html、CSS、Javascript。所以要學網頁，就先從這三樣東西開始學。\n 本文目的於 iOS Club 幹訓使用，內容口述為主，所以文章內容有點草率，基本上不適合閱讀。\n HTML vs CSS vs Javascript 只是寫個網頁，就要學三種程式語言？不，嚴格來說，只有 Javascript 是程式語言，其他兩個都只是標記語言：HTML 提供網頁的骨幹，CSS 提供衣服，JS 提供大腦，但你也確實要學三樣東西。\nHTML \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Page Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Heading \u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CSS body { background-color: lightblue; } h1 { color: white; text-align: center; } p { font-family: verdana; font-size: 20px; } Bootstrap Bootstrap 就是來拯救世界的，提供網頁設計師們一個好用的框架，用簡單幾句話就可以寫出響應式網頁，也有很多漂亮的原件，讓大家不必每次寫網頁都重新造輪子。用了 Bootstrap 基本上就只需要碰 HTML，CSS 和 JS 都不用寫，就可以寫出堪用的網頁很多大學生的專題都是這樣搞出來。\n只要套了下面的模板，就能開始使用 Bootstrap：\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;link href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; integrity=\u0026#34;sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello, world!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js\u0026#34; integrity=\u0026#34;sha384-U1DAWAznBHeqEIlVSCgzq+c9gqGAJn5c/t99JyeKa9xxaYpSvHU5awsuZVVFIhvj\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Reference  HTML Tutorial CSS JavaScript Tutorial HTML vs JS vs CSS ","tags":["web","html","css","javascript"],"section":"posts"},{"id":8,"date":"1630311227","url":"https://tonypepebear.github.io/HugoBlog/posts/dev/cloud-ide-docker/","title":"Cloud IDE Docker","summary":"紀錄一下我的 Cloud IDE Docker 使用方法。\n","content":"紀錄一下我的 Cloud IDE Docker 使用方法。\nPycharm Community Docker Hub\ndocker run -dp 8887:8887 tonypepe/pycharmc ","tags":["ide","docker","jetbrains"],"section":"posts"},{"id":9,"date":"1629916317","url":"https://tonypepebear.github.io/HugoBlog/posts/docker/docker/","title":"Docker","summary":"Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。","content":"Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。\nDocker v.s. VM 入門 Docker 最常見的問題就是，Docker 和 VM 差在哪裡？這個問題不難理解，VM 「虛擬機」，顧名思義是虛擬化「硬體」。而 Docker 則是只虛擬化作業系統，或是稱作「軟體」。\n大家都應該知道每創建一個虛擬機，都會耗費掉數分鐘的時間，若還要安裝環境，那耗費的時間則會相當可觀，也會耗費掉相當大的硬體資源。Docker 只虛擬化軟體的優勢，就是可以在幾秒內就啟動服務，耗費資源也相當少，還省去了建立環境的時間。\nDocker Hub  Git 有 GitHub，Docker 有 Docker Hub\n Docker Hub 是 Docker 官方用來存放 Image 的倉庫 (Registry)，使用者也可以自架 Registry，但是如果未指定 Registry，Docker 預設會去找 Docker Hub 上的 Image。\nImage Image 通常可以是一個系統，也可以是一個已經安裝好特定執行環境 (像是 JAVA) 的系統。系統部分最常見的會是用 alpine linux，這是一個非常小的項目，只有一個系統，可以讓你在幾秒內就可以啟動服務，許多執行環境也會建構在這個系統上。現在可以先去 Docker Hub 上看看幾個前幾名的 Image，大概就會比較清楚 Image 的功用。\nDocker Image 可以由下列幾方式取得：\n 從 Docker Hub 上下載 由 Dockerfile 構建 從其他電腦 import  Container Docker 用 Image 創建 Container，也就是說，Container 是 Image 的實例，Container 基本上就是一個完整的作業系統，可以執行任何的程式。\nDocker Run 我們簡單創建一個 Ubuntu 的 Container，並且啟動它：\ndocker run ubuntu 執行後可以看到 Docker 自動從 Docker Hub 上下載 Ubuntu 的 Image，但是開始執行後卻甚麼都沒發生就結束了。這是因為 Ubuntu 的 Image 預設是啟動一個 Shell，如果沒有 Attach 到 Sheel 上，Container 馬上就結束了。\n所以如果我們要 Attach 到 Ubuntu 的 Shell 上，可以這樣執行：\ndocker run -it ubuntu 執行應該就會看到我們到 ubuntu 的 Shell 裡。\n啟動一個網頁服務 Nginx 有官方的 Hello Image，可以更清楚的看到 Container 有在執行 Nginx 服務。\ndocker run -p 8080:80 -d nginxdemos/hello 上面多了一個 -p 的參數，後面跟上 8080:80，意思是本機的 8080 Port 對到容器的 80 Port，這樣就可以讓我們在本機的 8080 Port 上看到 Nginx 的網頁了。\n列出、刪除容器 列出正在執行的容器：\ndocker ps 列出所有容器，包含已經停止的容器：\ndocker ps -a 刪除容器，若是尚未停止的容器則無法刪除：\ndocker rm \u0026lt;container_id\u0026gt; 加上 -f 參數，可強制刪除執行中的容器：\ndocker rm -f \u0026lt;container_id\u0026gt; 強制刪除所有容器：\ndocker rm $(docker ps -aq) 創建自己的 Image 要教 Docker 怎麼創建 Image，需要先建立一個 Dockerfile：\nFROMubuntu:latestRUN apt update \\  \u0026amp;\u0026amp; apt install vim git -y \\  \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/*CMD [\u0026#34;/bin/bash\u0026#34;]Build Image:\ndocker build -t my-ubuntu . 注意上面的指令的最後面有一個 .，代表 Build 這個目錄。-t 的參數則是 Image 的名稱，或是稱作 Tag。\n","tags":["docker"],"section":"posts"},{"id":10,"date":"1628839059","url":"https://tonypepebear.github.io/HugoBlog/posts/web/cloudflare-tunnel/","title":"Cloudflare Tunnel","summary":"Cloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。","content":"Cloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。\n我覺得目前的缺點就是網路上相關的資料比較少，遇到問題很難找到資料參考，因為他其實主要是 Cloudflare 的一項零信任服務，目標客群都是一些厲害的網管，所以官方寫的文件也都很深奧，如果是新手可能會頭昏眼花。\n這一項服務可以先不用帳號就能試用，不過就不能自訂 Domain，我會先介紹免登入的，再介紹要登入的。第一步還是要在本地先安裝環境。\n安裝 cloudflared 全系統適用 注意 Cloudflare 後面多了一個 d，這是他連上 Tunnel 的必要程式，是用 Go 編寫，安裝方式就是到官方 Github下載符合自己環境的執行檔。\nmacOS mac 可以用 Homebrew 安裝：\nbrew install cloudflare/cloudflare/cloudflared Windows Windows 永遠是最麻煩的，下載完執行檔後，隨便丟到一個資料夾，然後加到 PATH 裡。\nUpdate 要更新這個執行檔，只要 Run 下面的指令，另外，Windows 不支援自動更新，要更新就只能手動下載覆蓋：\ncloudflared update 免登入測試 Tunnel cloudflared tunnel --url http://localhost:8080 執行上面的指令，就可以將本地電腦的 8080 port 用 http 公開到網路上，應該會看到輸出中會給一串個 *-*-*.trycloudflare.com 的網址，現在只要訪問那個網址，就可以發現本地的網頁已經可以從全網連到，不需註冊，也不用設定複雜的 Domain，還不限流量。\n登入 Cloudflare 第一步就是先登入 Cloudflare 的帳號，也要有一個已經託管給 Cloudflare 的 Domain：\ncloudflared tunnel login 執行這個命令後，應該會跳出瀏覽器授權，如果沒有跳出，就手動複製提供的授權網址登入 Cloudflare 帳號。\n創建並使用 Tunnel 登入完成後就可以開始創建通道，創建只會在本地產生一些文件，並不會有任何連線的動作，可以放心執行：\ncloudflared tunnel create \u0026lt;Name\u0026gt; 創建完成後，Cloudflare 會給一組 UUID，可以看一下有沒有創建成功：\ncloudflared tunnel list 如果要刪除就是 Delete：\ncloudflared tunnel delete \u0026lt;Name or UUID\u0026gt; DNS 設定 在創建 Tunnel 後，Cloudflare 會將剛剛創建隧道時產生的 UUID 綁定到 \u0026lt;UUID\u0026gt;.cfargotunnel.com 這個 Domain，不過 Cloudflare 會擋掉用這個 Domain 直接連線的流量，所以我們要把我們的 Domain 新增一個 CNAME 紀錄，把流量往這邊導。\n有兩個方法可以設定 CNAME，一個是自己去 Cloudflare 的官網設定：\n另一個是直接用指令設定，快又方便，把後面的 domain 改成自己想要綁定的：\ncloudflared tunnel route dns \u0026lt;Name or UUID\u0026gt; test.example.com 打完後如果不放心，還是可以自己到 Cloudflare 的 Dns 設定看一下有沒有設定完成，應該會看到跟上圖一樣產生一個 CNAME Record。\nTunnel Config 下面是最簡單的 Config 範例，這是一個 yml 檔案：\ntunnel: \u0026lt;Name\u0026gt; ingress: - hostname: test.example.com service: http://localhost:8080 - service: http_status:404 上面會把 8080 的 HTTP 流量導到 domain.example.com，使用剛剛創建的 Tunnel。\n最後一行一定要有一個可以接受所有流量的 Service，不然服務會不能啟動，這裡全部往 404 導。\nRun Tunnel 最後一步，加上 config 的參數，把剛剛的 yml 檔喂給 Cloudflare，就可以啟動通道了：\ncloudflared tunnel --config test.yml run 後記 這篇只介紹了如何創建一個 Http 的 Tunnel，如果要開其他的 TCP Port，還需要其他的設定，而且在 Client 端也會需要安裝 Cloudflared，所以我留到下一篇在介紹。\nReference  Cloudflare for Teams documentation ","tags":["cloudflare","tunnel","teams","cloudflare-tunnel"],"section":"posts"},{"id":11,"date":"1626876500","url":"https://tonypepebear.github.io/HugoBlog/posts/flight/a320-note/","title":"A320neo 冷艙到飛行","summary":"簡單記錄我所認知的 A320 的一些程序。","content":"簡單記錄我所認知的 A320 的一些程序。\n 注意這些都不是標準程序，只是我自己亂理解的，也省去蠻多步驟，基本上就是能起讓飛機動起來，標準程序肯定是更複雜的。\n 啟動飛機前檢查 模擬器中跳過還是可以飛\n Engine Master 1 and 2 Switch -\u0026gt; OFF  主引擎 1, 2 都關閉   Engine Mode Selector -\u0026gt; NORM  引擎模式在 Normal 位置   Weather Radar -\u0026gt; OFF  關閉氣象雷達   Landing Gear -\u0026gt; Down  機輪放下   Wipers -\u0026gt; Both OFF  兩個雨刷都關閉    啟動飛機  Batt 1 and 2 -\u0026gt; ON EXT Power -\u0026gt; ON  啟動外部電源 這時應該可以看到所有儀表亮起   APU Fire Test  APU 滅火測試   APU Master and wait 3 sec -\u0026gt; ON  打開 APU 主開關，並等待 3 秒   APU START -\u0026gt; ON  發動 APU   Wait for APU START -\u0026gt; Green \u0026ldquo;AVAIL\u0026rdquo;  等 APU 發動完成   APU BLEED -\u0026gt; ON  開啟 APU 供給氣壓   EXT Power -\u0026gt; OFF  移除外部電源    Overhead Panel 上方儀表 基本上，由左至右，由下而上的檢查\n左邊那排  CREW SUPPLY -\u0026gt; ON  打開組員氧氣供給   ADIRS 1, 2, 3 -\u0026gt; NAV  開啟三個慣性導航，需等待 6-7 分鐘校準    中間那排  NAV \u0026amp; LOGO Light -\u0026gt; ON OVHD INTEG LT -\u0026gt; AS REQ. DOME LT -\u0026gt; AS REQ. ANN LT TEST EMER EXIT LT -\u0026gt; ARM SEAT BELTS -\u0026gt; ON NO SMOKING -\u0026gt; ON ALL PUMP -\u0026gt; ON ENG 1 FIRE TEST ENG 2 FIRE TEST  右邊那排 基本上不用動\nMCDU 飛行電腦 在等待導航校準時，來設定飛行電腦。設定飛行電腦有一個口訣：\n D \u0026gt; I \u0026gt; F \u0026gt; S \u0026gt; R \u0026gt; I \u0026gt; P \u0026gt; P\n  DATA INIT A F-PLN SEC PLAN RAD NAV INIT B PREF PROG  TODO Reference  教官我想飛 機師阿楷 a320-normal-procedures.pdf ","tags":["a320neo","airbus","msfs"],"section":"posts"},{"id":12,"date":"1626450187","url":"https://tonypepebear.github.io/HugoBlog/posts/linux/beautiful-terminal/","title":"Beautiful Terminal","summary":"打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。","content":"打不贏別人，至少長得比他帥。最近終於把我的 Terminal 弄成自己喜歡的樣子，所以做一下簡單的紀錄，希望大家都可以把東西變成自己喜歡的樣子。\n我們今天主要會用到下面的幾樣技術：\n zsh powerlevel10K zim Nerd Fonts  看到這幾項技術其實可以自己先去研究一下，看看這些技術是不是自己需要的，以免亂裝一堆東西，搞的自己 Terminal 亂七八糟無法復原。另外，Windows 應該是無法安裝的，至少我自己是沒辦法，不過 WSL 倒是可以玩成這樣，畢竟就是 Linux 麻。\n很多人會推薦在 mac 上安裝 iTerm，我自己是沒裝，我覺得 mac 內建的 Terminal 足夠好用，沒必要安裝其他 Terminal。\nFont 好看的第一步就是有好看的字體，Nerd Fonts 這個專案把一些開發者常用的字體，加上一些在 Terminal 中會用到的一些 icon 和 symbol，常見的 Hack、Jetbrains Mono 都有在這個專案裡。到 Nerd Fonts 的官網可以下載到這些字體，注意不要到字體們原本的管網下載，要到 Nerd Fonts 下載包含特殊符號的字體。\n下載安裝好字體後，記得到自己的 Terminal 中變更字體，選擇有包含 Nerd 的字體，以免等等字體都無法顯示，這部分教學我懶得寫，所以附一張圖：\nzsh zsh 可以說是 bash 的進階版，提供客製化自己在 Terminal 中想要的主題和功能。要安裝 zsh 通常各個系統都不一樣，自己上網根據系統安裝即可。安裝完成後也要將預設 shell 改成 zsh。\nubuntu:\nsudo apt install zsh chsh -s /bin/zsh $USRR powerlevel10k powerlevel10k 是一個 zsh 主題，提供可高客製化的主題和客製化嚮導，可以簡單地就把 Terminal 變成自己喜歡的模樣，也是本文最重要的部分。powerlevel10k 提供許多安裝方法，可以透過 oh-my-zsh，也可以用腳本安裝，我是認為用腳本安裝就好，可以不用用到 oh-my-zsh，因我們之後會提到 zim 就提供許多可以替代 oh-my-zsh 的功能。\n用腳本安裝 powerlevel10k：\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10k echo \u0026#39;source ~/powerlevel10k/powerlevel10k.zsh-theme\u0026#39; \u0026gt;\u0026gt;~/.zshrc 安裝方式可能會因版本變動而不一樣，建議還是到官方 Github 上看一下安裝方式。\n安裝完成後第一次進到 Terminal 會遇到一個安裝嚮導，可以根據自己喜好設定主題樣式。\n完成到這裡，Terminal 應該已經變得美美的，如果遇到亂碼，可能是字型沒有調整好。\npowerlevel10k 會提供一個 p10k 的命令，可以用於重新啟動嚮導：\nZim 全名 Zsh IMproved FrameWork，主要是提供一些方便的 zsh plugin，像是自動補全、語法高亮等，如果是希望好看，不用好用，Zim 就可以不用安裝。\n安裝 Zim 也很簡單，只要 Run 下面的腳本就可以：\ncurl -fsSL https://raw.githubusercontent.com/zimfw/install/master/install.zsh | zsh 到這就算是全部完成，如果有發現更多好用的 Terminal 工具，記得分享給我。\nReference  zsh powerlevel10K zim Nerd Fonts ","tags":["terminl","zsh","zim","powerlevel","powerlevel10k","nerd font","ubuntu","mac"],"section":"posts"},{"id":13,"date":"1625475938","url":"https://tonypepebear.github.io/HugoBlog/posts/web/markdown/","title":"Markdown","summary":"Markdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。","content":"Markdown 可以想像成 Html 的簡化版本，廣泛用於編寫文章或是技術文件，因為其特性基本上由 Html 簡化而來，所以方便的由寫好的 Markdown 產生 Html 網頁，像是這篇文章也是由 Markdown 編寫。\n我們來看看 Swift 的官網，可以發現 [README.md](http://readme.md) 這個檔案就是由 Markdown 編寫，Github 也會自動將這個檔案渲染在網頁下方。到這裡可以發現，在 Github 上的所有開源專案的文件，幾乎都是由 Markdown 編寫。\n哲學 引述自 https://markdown.tw\n Markdown的目標是實現「易讀易寫」。\n不過最需要強調的便是它的可讀性。一份使用Markdown格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown語法受到一些既有text-to-HTML格式的影響，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，然而最大靈感來源其實是純文字的電子郵件格式。\n因此Markdown的語法全由標點符號所組成，並經過嚴謹慎選，是為了讓它們看起來就像所要表達的意思。像是在文字兩旁加上星號，看起來就像強調。Markdown的清單看起來，嗯，就是清單。假如你有使用過電子郵件，區塊引言看起來就真的像是引用一段文字。\n Tools Q: 那要用什麼來寫呢？\n因為 Markdown 基本上也是純文字檔案，所以只要是文字編輯器都可以編輯，你要用 txt 來寫也是個不錯的方法❤️。\nVSCode 目前最推薦的就是工程師的好夥伴 VSCode ，VSCode 在寫 Markdown 時，有提供即時渲染，可以快速的看到結果，而且 VSCode 應該在各位工程師的電腦裡都應該有安裝才對。\nHackMD HackMD 是一個在網頁中的 Markdown 編輯器，可以方便地在網頁中編輯和看到編寫的結果，HackMD 最厲害的功能是可以將 Markdown 轉換成簡報，用 Markdown 取代 PowerPoint？這夠帥吧！\nMarkText 這是一個在 Github 上的開源專案，可以所寫所得，方便使用，但我還是比較推薦新手使用上面兩項工具，因為這東西真的太方便了，有點沒有在寫 Markdown 的感覺。\nMicrosoft Word 推薦指數：⭐⭐⭐⭐⭐\n [YouTube] Why Microsoft Word is the best IDE for programming  Markdown 語法 大標題 \u0026lt;h1\u0026gt; # 大標題  次標題 \u0026lt;h2\u0026gt; ## 次標題  次次標題 \u0026lt;h3\u0026gt; ### 次次標題  內文 內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文\n\u0026lt;p\u0026gt; 內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文內文  斜體 粗體 內文內文內文斜體內文內文內文內文內文內文\n內文內文內文粗體內文內文內文內文內文內文\n內文內文內文*斜體*內文內文內文內文內文內文 內文內文內文**粗體**內文內文內文內文內文內文  有序清單  有序清單 1 有序清單 2 有序清單 3  \u0026lt;ol\u0026gt; 1. 有序清單 1 2. 有序清單 2 3. 有序清單 3  無序清單  無序清單 1 無序清單 2 無序清單 3  \u0026lt;ul\u0026gt; * 無序清單 1 * 無序清單 2 * 無序清單 3 + 無序清單 1 + 無序清單 2 + 無序清單 3 - 無序清單 1 - 無序清單 2 - 無序清單 3  程式碼區塊 printf(\u0026#34;Hi 程式碼區塊\u0026#34;);  標記程式碼 inline code\ninline `code`  超連結 Google首頁\n[Google首頁](https://google.com)  圖片連結 ![](https://www.google.com.tw/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png) Reference  Markdown文件 ","tags":["markdown"],"section":"posts"},{"id":14,"date":"1624196913","url":"https://tonypepebear.github.io/HugoBlog/posts/linux/frp/","title":"Frp","summary":"frp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。","content":"frp 全名是 fast reverse proxy，可以將在 NAT 後方的服務快速的發布到公網 ip 上，可以支援 TCP 和 UDP 協議，我覺得唯一的缺點就是所有流量都會經過 Server 端，所以如果 Server 端的流量有限制就需要注意一下。\nfrp 會需要一台 Server，Server 需要公網 ip，如果沒有公網 ip，可以使用 aws 或 gcp 買一個簡單的 VPS。\n安裝 網路上有許多一鍵安裝的到腳本，但我們不使用那些，有興趣的自己上網搜尋。\n到官方 Release 下載最新版，根據系統選擇，解壓後會看到 frps 、frpc 各有三個檔案，跟 frps 有關的就是 Server 端用的，frpc 的就是 Client 端用的。如果是 Server 端，就可以將 frpc 的檔案都刪除。\nServer 端設定 在 Server 上打開設定文件 frps.ini 可以看到預設就有如下的內容：\n[common] bind_port = 7000 common 內綁定了 7000 port，這個 port 是讓 client 端連接用的，基本現在不用改設定就可以直接用。執行 frps 要用 -c 參數給定設定檔案：\n./frps -c ./frps.ini 如果沒看到問題，基本上 Server 端就設定好了，其他功能晚點再介紹，我們先設定好 Client。\nClient 端設定 Client 就是要發布服務伺服器，所以雖然叫做 Client 但本身應該也是一台提供服務的 Server。Client 就可以刪除有關 frps 相關的檔案。\n一樣先打開設定檔 frpc.ini，也會有如下預設內容：\n[common] server_addr = 127.0.0.1 server_port = 7000 [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 Client 端的設定檔就不能直接用，需要修改 Server ip 才行，更改 server_addr 為剛剛 Server 端的 ip 地址或是 Domain 都可以。\n下方方的 ssh 區塊設一個將 Client 端的 ssh 22 port 公開到 Server 端的 6000 port 的範本，如果有其他的 port 要開放，用相同的思維更改即可。像是如過要加 Minecraft 25565 port 也到 Server 端的 25565 port，就可以新增一個區塊：\n[common] server_addr = example.com server_port = 7000 [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 [minecraft] type = tcp local_ip = 127.0.0.1 local_port = 25565 remote_port = 25565 到目前為止應該就可以用 Server 端的 ip 連接到 Client 端了，如果連不上，可能要檢查一下 Server 端防火牆的設定，這邊就不贅述。\nToken 認證 不知道大家有沒有發現，基本上只要知道你 Server ip 或 domain 的人都可以新增自己的 port，要避免這樣的狀況，我們可以使用 token。使用方法也很簡單，只要在 Server 和 Client 端的 [common] 都加上相同的 token 參數，就可以進行簡單的認證。\nServer 端範例：\n[common] bind_port = 7000 token = 7Jc2ZCvVzHu Client 端範例：\n[common] server_addr = example.com server_port = 7000 token = 7Jc2ZCvVzHu [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 Refrence GitHub\n中文文檔\n","tags":["frp","linux"],"section":"posts"},{"id":15,"date":"1623782156","url":"https://tonypepebear.github.io/HugoBlog/posts/kotlin/medium-api/","title":"發布 Markdown 至 Medium","summary":"我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。","content":"我認為用 Markdown 用來寫技術文章還是最順手的，但是 Medium 的編輯器卻不支援 Markdown。前幾天用 import 的方式也失敗，另尋他處後發現 Medium 支援用 API 發布文章，更還支援用 Markdown 和 Html 發布。雖然不懂官方為何不直接讓用戶用 Markdown 發布，而是要用 API，但是竟然找到了一絲希望，就來試試看用 API 的方式發布文章。\n本篇使用 Kotlin 和 OKHttp，來嘗試撰寫一個應用程式，來協助發布 Markdwon 至 Medium，專案原始碼在 Github 上。\n申請 token Medium API 的 官方文件 在這，可以用 HTTP POST 的方式來發布文章。要使用 API 第一件事就是要有 token，要申請 token 不用錢，官方目前好像也沒有使用限制，到 用戶設定 的頁面，找到 Integration tokens 的地方，申請一個 token，說明隨便輸入就好。\nUserID 根據官方文檔，想要發布文章，需要 UserID，我找了好久才發現 UserID 不是 Name 也不是 UserName，也是要先用 API 的方式取得。\n用 Http GET 的方式可以取得 token 主人資料，使用方式如下：\nGET https://api.medium.com/v1/me GET /v1/me HTTP/1.1 Host: api.medium.com Authorization: Bearer 181d415f34379af07b2c11d144dfbe35d Content-Type: application/json Accept: application/json Accept-Charset: utf-8 token 是放在 Post 的 header，的 Authorization:Bearer 後方，下方是用 Kotlin 和 OKHttp 實作的方法：\nval request = Request.Builder() .url(\u0026#34;https://api.medium.com/v1/me\u0026#34;) .get() .addHeader(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer $token\u0026#34;) .build() val response = client.newCall(request).execute() 範例的 Response 如下，可以拿到用 UserID、UserName 等資料：\n{ \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;5303d74c64f66366f00cb9b2a94f3251bf5\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;majelbstoat\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Jamie Talbot\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://medium.com/@majelbstoat\u0026#34;, \u0026#34;imageUrl\u0026#34;: \u0026#34;https://images.medium.com/0*fkfQiTzT7TlUGGyI.png\u0026#34; } } 根據上方的 Json，可以產生 Kotlin Data Class 來放取回的資料：\ndata class MediumApiMe( val `data`: MediumMeData ) data class MediumMeData( val id: String, val imageUrl: String, val name: String, val url: String, val username: String ) 取回的 Response 用 gson 轉換 json 到 Data Class，最後寫成一個完整的方法如下：\nfun getUserData(token: String): MediumApiMe { val request = Request.Builder() .url(\u0026#34;https://api.medium.com/v1/me\u0026#34;) .get() .addHeader(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer $token\u0026#34;) .build() val response = client.newCall(request).execute() if (response.code != 200 || response.body == null) throw RuntimeException( \u0026#34;Can not get User info. Maybe token is wrong.\u0026#34; + {response.body?.byteStream()?.reader()?.readLines()} ) val text = response.body!!.byteStream() .reader() .readText() return gson.fromJson(text, MediumApiMe::class.java) } 上方的程式碼有判斷 Response Code 是否為 200，若不是 200 代表取得資料沒有成功，就拋出 Exception。\nPost 文章 取得 UserID 後就可以用 Http Post 的方式向 Medium 發布文章。下方的 authorId 就是剛剛用 Http Get 的方式取得的 UserID。\nPOST https://api.medium.com/v1/users/{{authorId}}/posts 下面是 Post 的範例，token 一樣是放在 header 裡。官方的範例是用 html 來發布文章，我們只要將 contentFormat 改成 markdown 就可以達成目的。\nPOST /v1/users/5303d74c64f66366f00cb9b2a94f3251bf5/posts HTTP/1.1 Host: api.medium.com Authorization: Bearer 181d415f34379af07b2c11d144dfbe35d Content-Type: application/json Accept: application/json Accept-Charset: utf-8 { \u0026#34;title\u0026#34;: \u0026#34;Liverpool FC\u0026#34;, \u0026#34;contentFormat\u0026#34;: \u0026#34;html\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;\u0026lt;h1\u0026gt;Liverpool FC\u0026lt;/h1\u0026gt;\u0026lt;p\u0026gt;You’ll never walk alone.\u0026lt;/p\u0026gt;\u0026#34;, \u0026#34;canonicalUrl\u0026#34;: \u0026#34;http://jamietalbot.com/posts/liverpool-fc\u0026#34;, \u0026#34;tags\u0026#34;: [\u0026#34;football\u0026#34;, \u0026#34;sport\u0026#34;, \u0026#34;Liverpool\u0026#34;], \u0026#34;publishStatus\u0026#34;: \u0026#34;public\u0026#34; } 根據上面 Post 的 Json 範例，我們可以產生出如下的 Kotlin Data Class，我順便寫了一個快速轉成 Json 的方法：\ndata class MediumApiPost( val title: String, val content: String, val contentFormat: String, val tags: List\u0026lt;String\u0026gt; = listOf(), val publishStatus: String = \u0026#34;draft\u0026#34;, //預設是草稿  val canonicalUrl: String = \u0026#34;\u0026#34;, ) { fun toJson(): String { return gson.toJson(this) } } 產生出 Data Class 就可以嘗試 Post 看看，是否會發布文章，直接利用剛剛寫好的 getUserData 拿到 UserID，之後在 Post：\nval userID = getUserData(token).data.id val medimuApiPost = MdieumApiPost(\u0026#34;Title\u0026#34;, \u0026#34;# Title\\nHi\u0026#34;, \u0026#34;markdown\u0026#34;) val request = Request.Builder() .url(\u0026#34;https://api.medium.com/v1/users/$userID/posts\u0026#34;) .post(mediumApiPost.toJson().toRequestBody(contentType = \u0026#34;application/json\u0026#34;.toMediaType())) .addHeader(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer $token\u0026#34;) .build() val response = client.newCall(request).execute() 如果發布成功，可以拿到 Response Code 201，其他的都代表發布失敗。\n寫成完整的發布方法如下：\nfun newPost(token: String, mediumApiPost: MediumApiPost): String { val userID = getUserData(token).data.id val request = Request.Builder() .url(\u0026#34;https://api.medium.com/v1/users/$userID/posts\u0026#34;) .post(mediumApiPost.toJson().toRequestBody(contentType = \u0026#34;application/json\u0026#34;.toMediaType())) .addHeader(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer $token\u0026#34;) .build() val response = client.newCall(request).execute() if (response.code != 201 || response.body == null) throw RuntimeException(\u0026#34;Something Wrong. ${response.body?.byteStream()?.reader()?.readText()}\u0026#34;) val text = response.body!!.byteStream().reader().readText() println(text) var json = gson.fromJson(text, MediumNewPostResponse::class.java) return json.data.url } 上面的方法會直接回傳發布成功的 URL，失敗則會直接拋出 Exception。\nGUI 寫好方法後，最後再用 TornadoFX 寫 GUI，這邊就不講述 GUI 的部分，有興趣可以自己到 GitHub 上看專案的原始碼。\n程式碼區塊 因為 Medium 目前並不支援程式碼高亮，傳上去的程式碼區塊都會變成黑底的，目前我有想到的解法是在 Post 上去之前，就先將程式碼區塊都換成 GitHub Gist，但這就需要更複雜的方式解決問題了，有興趣的人可以自己試試看。\nReference Medium’s API Documentation\n","tags":["medium","markdown","kotlin","tornadofx"],"section":"posts"},{"id":16,"date":"1623084919","url":"https://tonypepebear.github.io/HugoBlog/posts/vscode/vscode-clang/","title":"用 VSCode 寫 C/C++","summary":"其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩。","content":"其實在 VSCode 寫 C 根本不是一件難事，VSCode 本來就是一個優秀的文字編輯器，所以要要寫 C 完全不是問題，但問題是出在執行或 Debug 寫好的 Code 實在是很麻煩，要先經過不少設定。而且在官方的文件中，其實是教你怎麼建置專案，執行 Debug，如果只是寫一點簡單的小程式根本用不到那麼複雜的設定，所以本文是我目前發現比較容易在 VSCode 中執行 C 和 C++ 的方法。\ngcc g++ 在了解如何設定 vscode 前，我們先來了解一下基本的 gcc、g++ 指令，這是一個用來編譯 C 程式碼最快的方法，gcc 就是 C 的編譯器，g++ 則是 C++ 的。這裡不會解說如何安裝，在 Windows 下可以使用 MinGW，macOS 則是只要在 Terminal 下 gcc 指令，就會自動問你要不要安裝。\n下面的範例會編譯 main.cpp 的 C++ 檔案：\ng++ main.cpp 執行上面的指令後，會產生名為 a.out 的檔案，因為我們沒有指定輸出檔名，所以預設就是 a.out，在 Windows 上則為 a.exe 的執行檔。如果要執行產生的執行檔案：\n./a.out ./a.exe # On Windows 要指定輸出檔名也很簡單，加個 -o：\ng++ -o main.out main.cpp 這樣就可以將 main.cpp 編譯成 main.out 的執行檔。\n上面這些不會也沒關係，但我還是建議了解一下，因為等一下要安裝的模組，只是幫你完成這些步驟，如果完全不了解指令的功能，發生問題可能自己會沒辦法解決。\n設定 VSCode 第一步就是先在 VSCode 中安裝 C/C++，和 Code Runner，兩個延伸模組。\n安裝完成後，應該就會看到右上角出現了一個執行的按鈕，可以按按看程式會不會執行。\n如果找不到按鈕，或是想要停下程式，也可以用按下 f1 的方式叫出 VSCode 的指令輸入窗，輸入 Run Code 或是 Stop Code Run。\nRun In Terminal 現在可能會發先一個問題，這種執行模式是沒有辦法接收鍵盤輸入的，如果想要接收鍵盤輸入，我們要把執行模式改成在 Terminal 中。所以我們要開啟 VSCode 的 settings.json 設定檔，來更改設定，一樣是用 f1 叫出命令輸入區，並尋找 open settings json：\n打開後在裡面新增一行：\n\u0026#34;code-runner.runInTerminal\u0026#34;: true 如果前方有其他設定值，記得在前面的設定值的最後面加個逗號 ,：\n現在就可以方便的在 VSCode 中寫 C，和方便的執行他們。\n","tags":["vscode","code","c","c++"],"section":"posts"},{"id":17,"date":"1623074453","url":"https://tonypepebear.github.io/HugoBlog/posts/hugo/hugo-github-actions/","title":"用 Github Actions 來發布 Hugo 靜態網頁","summary":"Github Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到 gh-pages 的 git 分支。","content":"Github Actions 是 Github 官方提供的 CI/CD 服務，編寫簡單的腳本，就可以在每次 Push、 PR 時，自動的檢查程式碼可不可以通過 Test，或是直接產生 Release 來交付專案成品。另外一個重點是，這個服務完全免費，而在私有 Repo，則是有限制容器的執行時間。本文使用 Github Actions 來自動將 Hugo 專案自動產生靜態網頁，並且將網頁發布到 gh-pages 的 git 分支。\nGithub Actions 也是容器化技術的一環，也是類似 Docker 容器的一種，如果對 Docker 還不熟悉，應該會對本文有點吃力，但也可以對完全不了解 Docker 的人，多一點對容器化技術的認識。\n編寫 Workflows 檔案 Workflows 工作流檔案，就是在 CI/CD 中最重要的檔案，這個檔案寫下這個專案的工作流程，像是如何 Test、交付成品，都是寫在這的檔案裡，Github 會自動讀取所有工作留檔案和自動執行，所以只要寫好一次，基本上就一勞永逸，每次只需要 Push，Gihtub 就會按照腳本完成指定的工作。\nGithub Actions 的 Worksflows 檔案都是放在專案跟目錄的 /.github/workflows 這個資料夾中，Github 會讀取這個資料夾中的 *.yml 檔案，並且自動執行他們。我們現在在這個目錄下新增一個叫做 hugo-public.yml 的檔案，檔名可以自訂沒關係，Github 不會關心檔名長怎樣，如果有多個檔案也每個都會分別執行。\n我們在現在 /.github/workflows/hugo-public.yml 的檔案中新增如下的腳本：\nname: github pages on: push: branches: - master  # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/master\u0026#39; with: github_token: ${{ secrets.ACCESS_TOKEN }} publish_dir: ./public 下面我們分段來解釋上面腳本每行的意思。\nName 基本上就是這個腳本的名稱，可以隨意自訂不會影響結果。\nOn on: push: branches: - master  # Set a branch to deploy pull_request: on 區段定義了這個腳本什麼時候會被執行，我們現在這個範例中，定義了這個腳本會在 master 這個分支被 push 的時候自動執行。Github 現在預設的分支名稱是 main，如果是 main 的人千萬要記得改，以免這個腳本永遠不會執行。\nJobs jobs: deploy: # 以下省略 jobs 是整個檔案中最核心的部分，可以分成許多不同的 Job，目前我們只有一個叫做 deploy 的 Job，這個名稱也是可以自訂的，這裡只是取叫 deploy 看不順眼可以自己換。如果還需要有其他工作，可以自己視情況增加。\nJob 終於來到最核心的部分，deploy 任務中的第一行，就定義了這個任務要 Run 在哪個容器內，或是稱作哪個系統內。這邊是用 ubuntu 的 20.04，建議不要亂改，因為其他的 Linux 不一定可以完任務。\ndeploy: runs-on: ubuntu-20.04 ## 以下省略 Steps 接下來就是分步驟執行命令，uses 是利用 Github 上別人已經寫好的 Actions 腳本來執行命令，像是第一個 uses: actions/checkout@v2 就是李用 Github 上別人已經寫好的 git checkout 命令來把專案 checkout 到容器中。\n第二個部分也是使用別人已經寫好的腳本，快速的安裝 Hugo 到容器內，用別人寫好的東西來完成工作，避免不必要的重複造輪子。\nsteps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/master\u0026#39; with: github_token: ${{ secrets.ACCESS_TOKEN }} publish_dir: ./public 看到這裡也可以發現任務也是分很多步驟，第三部分的 Build 就是像是我們在本機目錄的產生方法一樣，直接輸入 hugo 命令產生靜態網頁。\n第四部分的 Deploy 就會比較複雜，這邊也是利用別人寫好用來發布 Github Pages 的任務，他會需要一個 Github Token，這個 Token 是要用來對 Repository 有 Push 的權限，雖然可以直接寫在腳本裡，但是就所有人都看得到你的 Token，那就會產生資安問題。所以 Github 提供 Secrets 的模式，可以把不方便直接寫在專案裡的機敏資料，放在 Github 上。\n所以我們現在會有兩件事要做：\n 產生 Token 把 Token 放到專案的 Secrets 中  我們先來產生 Token，先到個人的設定頁面找到 Developer settings：\n再到 Token 的頁面產生新的 Token：\n名稱可以自己隨意訂，Repo 的權限就全部打開，除了 Repo 以外的權限則都不需要。都確定後直接拉到最下面產生 Token：\n會得到一組新的 Token，請注意不要像我一樣 Show 出來給別人看，請妥善保存，而且 Github 也只會顯示這一次，以後想要看都看不到，只能產生新的 Token。\n複製下 Token 後，我們到專案層級的設定，注意是專案的設定，不是個人設定：\n找到 Secrets 並新增 Secrets：\n名字取好後，填入剛剛拿到的 Token，注意名稱要和剛剛在腳本中寫的一樣：\n都填完後就大功告成，基本上只要 Push 到 Github 上，應該就會自動觸發上面寫的工作，以後只要文章有新的變動，Push 上來就會自動更新網頁網頁到專案的 gh-pages 分之上。想要進一步看到 Pages 的設定，可以到專案下的 Pages 的設定下看看，也可以在這裡自訂 Domian。\n","tags":["hugo","github","github-actions","web"],"section":"posts"},{"id":18,"date":"1623003046","url":"https://tonypepebear.github.io/HugoBlog/posts/hugo/hugo/","title":"用 Hugo 來寫文章吧","summary":"Hugo 是靜態網頁的產生器，類似 Hexo 和 Jekyll，Hugo 由 go 語言編寫，效率極高。","content":"Hugo 是靜態網頁的產生器，類似 Hexo 和 Jekyll，Hugo 由 go 語言編寫，效率極高，我原本是用 Hexo 在產生文章，後來發現 Hugo 這個好東西，也觀望了一陣子其實是懶，就決定換過來了，目前也用得非常順手。\n安裝 Hugo 這是 Hugo 的官網，進去後可以看到一些簡單的介紹和安裝方法。\n我蠻推薦在 vscode 的 code in container 的方式用 Hugo，因為我自己也是這樣用，這樣就不用擔心會弄髒環境，但就讓有興趣的人自己研究吧，這裡我介紹一般電腦的安裝方式。\nWindows Windows 我建議是用 Chocolatey 來安裝是最方便的：\nchoco install hugo 但是如果不想要用 Chocolatey 安裝，可以去官方的 Github Release 下載最新的 Windows 版本，下載完後記得加入 PATH。\nMac macOS 安裝最簡單，用 Homebrew 就可以快速的安裝。\nbrew install hugo Linux Linux 我一律建議從官方的 Github Release 下載最新的版本，並自己加到 PATH。\n雖然 apt 等版本管理器好像有提供，但官方的文件上都說版本幾乎都不是最新版，所以也不建議。用下載的方式還是最方便的，或是用 Docker 也是好辦法。\n開始使用 Hugo 先創建一個新的 Hugo 專案，下面的 MyBlog 可以換成自己想要的專案名稱：\nhugo new site MyBlog 新增主題 創建好專案後，就可以來新增主題，目前在 Hugo 上提供非常多的主題，我們可以到官方的這個網站找找看，但目前些不要增加難度，用最官房提供的簡單的 ananke 主題就好，反正主題是隨時都可以換的。\ncd MyBlog git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo theme = \\\u0026#34;ananke\\\u0026#34; \u0026gt;\u0026gt; config.toml 可以看到，官方是建議使用 git submodule 的方式新增主題，這樣之後在更新主題的時候也比較方便。\n最後一行的 echo 指令會在專案底下產生一個 config.toml 的檔案，基本上之後所有有關 Hugo 網站的設定，都可以在這裡變更。這一行指令應該會幫你在檔案中產生如下的內容：\ntheme = \u0026#34;ananke\u0026#34; 新增文章 在 Hugo 中新增文章的指令就是如下，可以自己修改檔名。\nhugo new posts/my-first-post.md 產生完成後可以看到 Hugo 幫你產生了一些 Front Matter。\n--- title: \u0026#34;My First Post\u0026#34; date: 2019-03-26T08:47:11+01:00 draft: true --- 上面的 draft 的指令是草稿的意思，如果沒有在上線前改成 false，是不會在正式網站中渲染的。\n現在可以自己產生的 Markdown 檔案中加一些內容，等等就可以看看效果怎麼樣。\n執行 Hugo Server 要啟動 Hugo Server 也非常簡單：\nhugo server -D 上面的 -D 參數的意思是把 draft 的草稿文件也渲染，如果想要看看上線的網頁會長怎樣，可以不要加上這個參數。\n產生靜態網頁 這個最簡單了，連猴子都會，-D 的參數一樣是渲染草稿文件，可視需求加上。\nhugo 到這裡就介紹完成所有 Hugo 基本的使用方法了，之後我會介紹如何使用 Github Actio\u0008n，讓我們每次只需要 Push 專案，Github 就會幫我們重新建置並部署網站。\nReference  Hugo Quick Start ","tags":["hugo","blog","mac","linux","windows"],"section":"posts"},{"id":19,"date":"1622913437","url":"https://tonypepebear.github.io/HugoBlog/posts/linux/ubuntu-black-screen/","title":"Ubuntu 開機黑屏","summary":"聽說 Ubuntu 開機沒有畫面或是只有 Logo，十次有九次都是顯卡驅動的問題。","content":"我目前的工作環境都是用 Ubuntu (被 Windows 氣到)，前幾天我重新安裝 Ubuntu 的時候，一直安裝失敗，重新安裝四、五次後都沒有畫面，最後才發現是顯卡驅動問題。\n 聽說 Ubuntu 開機沒有畫面或是只有 Logo，十次有九次都是顯卡驅動的問題\n 解決問題 在開機引導時會看到這個畫面，立馬按下鍵盤上的 c 鍵。\n按下 c 後，會以下畫面，找到 quite splash。\n把 quite splash 改成 nomodeset，不要懷疑，把兩個字刪掉，改成一個字，改錯也沒關係，下次重開就會復原。\n改完後，按下 f10 應該就可以順利進入系統，只是是在沒有顯卡驅動的狀態，畫面可能非常不流暢，所以我們現在來安裝顯卡驅動。\n顯卡驅動 開啟 Terminal，輸入下面的指令，可以自動檢查顯卡的驅動\nsudo ubuntu-drivers devices 應該可以看到其中一項後面有 recommended，基本上安裝那個版本就沒有問題。下面我們直接用自動安裝的方式安裝推薦的驅動。\nsudo ubuntu-drivers autoinstall 如果你懶的關心 autoinstall 會幫你安裝哪個版本，基本上直接執行上面的指令就可以解決問題了。\n安裝完成後重開機，如果沒有遇到其他問題，這樣應該就可以順利進入系統了。\nReference  My computer boots to a black screen, what options do I have to fix it? ","tags":["ubuntu"],"section":"posts"},{"id":20,"date":"1622909309","url":"https://tonypepebear.github.io/HugoBlog/posts/docker/pwd-hosting/","title":"自架 Play With Docker","summary":"學過 Docker 的人都應該有用過 Docker Playground 來學習或是測試過軟體，不想在本機跑 Docker 可以先用 Docker Playground 試試看軟體可不可以跑。","content":"學過 Docker 的人都應該有用過 Docker Playground 來學習或是測試過軟體，不想在本機跑 Docker 可以先用 Docker Playground 試試看軟體可不可以跑。\n官方已經有架設 Docker Playground，可以讓大家方便使用，但我使用的時後常發現他會 Lag，也不知道是 Docker Server 的問題，還是臺灣網路的問題。剛好最近想要教社團 Docker，這樣我架好一個，大家就不需要準備環境，直接就可以開始學了。\n本專案的 GitHub\n準備環境   Docker 18.06.0+\n  Go 最新版\n  以上的安裝兩個在這邊都不贅述，請自行參閱官方文檔。\n開始部署 第一步：下載專案 git clone https://github.com/play-with-docker/play-with-docker cd play-with-docker 第二步：確認驅動 其實我不是很確定這一步驟是要幹嘛，但是官方文檔有寫到，但是我在 Mac 上無法執行此命令，也可以順利部署。\nsudo modprobe xt_ipvs 第三步：Docker swarm docker swarm init 第四步：下載 image 這個 Image 是之後在 PWD 中創建容器時要用到的 Image。\ndocker pull franela/dind 第五步：go mod 這步也是非必要的，我也不懂 Golang 所以也不確定是要幹嘛。\ngo mod vendor 最後：啟動 docker-compose up 若沒有其他問題，理論上現在連接到 http://localhost:80 就可以看到 PWD 正在執行，也可以開始創建容器使用。\nlocalhost or 404 上一段的最後寫到可以連接到 localhost，但如果你試著用 localhost 以外的方式連接，就會出現問題，不管是 127.0.0.1 或是用網址 pwd.example.com 之類的都沒有辦法連接到 PWD，會不斷地出現 404，就是只有 localhost 可以。官方的文件就寫到這裡，也沒寫解法，以下是我自己發現的解決方法。\n基本上這個問題是 DNS 解析發生的問題，PWD 一次只能解析一種網址，預設是 localhost，我們可以去他的設定檔中變更他。\n設定檔案在 play-with-docker/config/config.go 之中，其中會有一行長下面的樣子：\nflag.StringVar(\u0026amp;PlaygroundDomain, \u0026#34;playground-domain\u0026#34;, \u0026#34;localhost\u0026#34;, \u0026#34;Domain to use for the playground\u0026#34;) 可以看到 PWD 這裡可以設定要解析的網址就是 localhost，所以只要將此變更為 pwd.example.com，就可以用這個網址連上 PWD。\n連上容器內的 Port 就算做完上面的設定，也順利了啟動 Docker 容器，但最後才發現想要連上特定的 Port 還是會失敗，因為他是用子網域的方式去連線 http://ip\u0026lt;hyphen-ip\u0026gt;-\u0026lt;session_jd\u0026gt;-\u0026lt;port\u0026gt;.direct.pwd.example.com，所以又會遇到無法解析 DNS 的情況，我的解法是在 DNS 的設定中把 pwd.example.com 和 *.pwd.example.com 都加入 A Record，才順利連上。\nNginx Proxy Pass 這部分我研究了蠻久，如果要把 Server 隱藏在 Nginx 後面，要設定的東西比較複雜，因為 PWD 有使用到 WebSocket，但是這部分我沒有過多的心得，所以直接把我的 conf 放在下面，容我不做解釋了：\nmap $http_upgrade $connection_upgrade { default upgrade; \u0026#39;\u0026#39; close; } server { listen 80; server_name pwd.example.com *.pwd.example.com; location / { proxy_pass http://192.168.1.1:80; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } 上面是假設 PWD Server 跑在 192.168.1.1:80 上。\nReference  Play With Docker ","tags":["docker","play-with-docker","nginx"],"section":"posts"},{"id":21,"date":"1622891718","url":"https://tonypepebear.github.io/HugoBlog/posts/others/hello-world/","title":"Hello World","summary":"Hello World. This is a test post.","content":"This is my first post in hugo.\ngoogle\nKotlin fun String.hi() = \u0026#34;$thisHI\u0026#34; class Test(var i: Int) { var p = \u0026#34;13 13\u0026#34; var p = \u0026#34;--------------------------------------------------------------------------------------------------\u0026#34; } meilisearch\n引用  引引用引用引用引用引用引用引用引用引用引用引用引用引用引用引用用引用引用\n Test list ol\n one two three google  ul\n one two three  preview\npublic\n","tags":[],"section":"posts"}]