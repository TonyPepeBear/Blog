{"componentChunkName":"component---src-templates-article-list-page-template-tsx","path":"/pages/3","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"5a287e0a-4039-585c-b56d-03d41cb6b549","html":"<p>上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。</p>\n<!--more-->\n<blockquote>\n<p>No one likes to wait. Internet impatience is something we all suffer from.</p>\n</blockquote>\n<p>文章一開頭就用一句點出大家在上網時會遇到的狀況，沒有人喜歡等待，可是所有人都在上網時身受其害，相信大家都遇過下面的情況：</p>\n<ol>\n<li>等待 App 完成內容更新</li>\n<li>等待網頁出現</li>\n<li>等待電影開始播放</li>\n</ol>\n<p>但有寫過程式或服務的都知道，人一多，就一定慢，非常的難避免，<del>所以這時候就要用 Cloudflare</del>，這時又宣傳了一下 Cloudflare。</p>\n<p>許多使用者家裡都會覺得網路很慢，然後買了很快很快的網速，像是 100Mbpa, 1Gbps 甚至 2Gbps，但其實就算家裡的網路再怎麼快，你連線的 Server 就是很慢，你的上網體驗還是大打折扣。</p>\n<p>如果要讓自己的服務不卡，只需要完成下面三樣要求：</p>\n<ol>\n<li>Server 有充足的帶寬</li>\n<li>讓 Server 盡量接近 User</li>\n<li>讓你的 Web 或 App 盡量得快</li>\n</ol>\n<p>看起來很簡單，但如果要完成這三個要求，都會耗費極大的成本。</p>\n<h2>DNS</h2>\n<p>現今的網路世界主要是由 ipv4 組成，也就是說，如果沒有 ipv4 地址，所有的網路連線都不會發生，如果我只知道 <a href=\"www.fcu.edu.tw\">www.fcu.edu.tw</a>，是完全沒有辦法上網的，因為我並不知道這個網址對應的 ip 是多少 (像是 140.134.xxx.xxx)，就完全沒有辦法和伺服器產生連線。DNS 出現前，大家都是直接用 ip 溝通，快速方便，最大的缺點就是非常難記。所以 DNS 就出現了，DNS 就像你打電話會需要電話簿一樣，我只我需要一個簡單好記的名字，再去電話簿搜尋真正的電話號碼就好。</p>\n<p>在知道電話號碼前，所有網路連線都不會發生，所以用最快速的方式查找電話簿絕對是上網速度最重要的一環，如果光是要知道 ip 位置就花掉 50ms(甚至更多)，上網效率就會大大降低。如今網路上有許多的 DNS 提供商，為大家記下這龐大的 DNS 電話簿，最著名的就是 Google 的 <a href=\"8.8.8.8\">8.8.8.8</a>，和 Cloudflare 的 <a href=\"1.1.1.1\">1.1.1.1</a>，Cloudflare 宣稱他是全世界最快的 DNS 提供商，(雖然在台灣好像未必)，但 Cloudflare 承諾他不會<strong>紀錄</strong>使用者查過的 DNS 紀錄，或上過什麼網頁 (好像是在暗示競爭對手會這麼做)。</p>\n<p>另外，就算 DNS 伺服器完全不假思索 (沒有反應時間) 就回傳 DNS 的查詢結果，這也付出了至少一個<a href=\"#%E5%85%89%E9%80%9F%E6%90%8D%E8%80%97\"><strong>光速的代價</strong></a>，聽起來好像沒什麼影響，但可以看看下面簡單的計算。</p>\n<h3>光速損耗</h3>\n<p>假設我家和 DNS 伺服器之間的直線距離是 100 公里，而且中華電信筆直的連接了一條筆直光纖到 DNS 伺服器，而光在光纖中的速度是 200,000,000 公尺/秒，往返需要 200,000 公尺。經過這樣簡單的計算，光是光速就已經耗費整整 1 毫秒(ms)，可以試著想想看更糟的情況，光速已經開始在嚴重拖累網速。</p>\n<h2>Hello Hello OK</h2>\n<p>知道了 ip 後，瀏覽器終於可以連上目標伺服器取得網頁，不久後就可以看到網頁出現在眼前。</p>\n<p>上面的步驟，幾乎都是由 TCP 協定完成，協定的第一步就是你的電腦和伺服器互相同意連線，這個過程稱作三向交握 (Three-Way Handshake)，步驟如下：</p>\n<ol>\n<li>Client 對 Server 說：Hello</li>\n<li>Server 對 Client 說：我聽到你說 Hello</li>\n<li>Client 對 Server 說：我聽到 -- 你說你聽到我說 Hello，我們現在可以溝通了。</li>\n</ol>\n<p>從上面的步驟就可以發現，已經至少耗費了<a href=\"#%E5%85%89%E9%80%9F%E6%90%8D%E8%80%97\">一個光速的時間</a>，所以也是一樣，伺服器愈靠近用戶，網速就愈快。這也是為什麼 Cloudflare 在世界各地廣設伺服器。</p>\n<h3>TLS/SSL</h3>\n<p>有了 TCP 我們就可以安全的連線了嗎？當然不是，TCP 一點也不安全，現在的網路連線幾乎都是透過 TLS (或稱作 SSL) 加密連線，所以 TCP 連線後，下一步是建立安全的加密連線。</p>\n<p>TLS 是一個非常複雜的加密協定，會牽涉到下面的設備：網路瀏覽器、建立鑰匙的伺服器，而且還要有一個可以證明他的身分的伺服器，因為不會想要和銀行建立安全連線，但你根本不確定他是不是你的銀行。</p>\n<p>上面的步驟也會需要好幾次<a href=\"#%E5%85%89%E9%80%9F%E6%90%8D%E8%80%97\">光速損耗</a>，所以讓伺服器愈靠近用戶端愈好。另外，也要盡量使用最新的 TLS 標準 (現在是 TLS 1.3)。</p>\n<h2>後記</h2>\n<p>我覺得這篇文章最有趣的的部分就是一直在討論光速對網路連線的影響，以往我都覺得光速很快，但光就算很快，光也是要跑很長一段距離，這樣耗損來回個幾次就已經對網路連線產生極大的影響了，而且更何況一個連線就一定會需要來回溝通好幾次。這篇文章後面還有蠻多內容，但我覺得沒有那麼重要就懶得寫了，有興趣的話可以自己繼續往下看。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://blog.cloudflare.com/fastest-internet/\">Welcome to Speed Week and a Waitless Internet</a></li>\n</ul>","rawMarkdownBody":"\n上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。\n\n<!--more-->\n\n> No one likes to wait. Internet impatience is something we all suffer from.\n\n文章一開頭就用一句點出大家在上網時會遇到的狀況，沒有人喜歡等待，可是所有人都在上網時身受其害，相信大家都遇過下面的情況：\n\n1. 等待 App 完成內容更新\n2. 等待網頁出現\n3. 等待電影開始播放\n\n但有寫過程式或服務的都知道，人一多，就一定慢，非常的難避免，~~所以這時候就要用 Cloudflare~~，這時又宣傳了一下 Cloudflare。\n\n許多使用者家裡都會覺得網路很慢，然後買了很快很快的網速，像是 100Mbpa, 1Gbps 甚至 2Gbps，但其實就算家裡的網路再怎麼快，你連線的 Server 就是很慢，你的上網體驗還是大打折扣。\n\n如果要讓自己的服務不卡，只需要完成下面三樣要求：\n\n1. Server 有充足的帶寬\n2. 讓 Server 盡量接近 User\n3. 讓你的 Web 或 App 盡量得快\n\n看起來很簡單，但如果要完成這三個要求，都會耗費極大的成本。\n\n## DNS\n\n現今的網路世界主要是由 ipv4 組成，也就是說，如果沒有 ipv4 地址，所有的網路連線都不會發生，如果我只知道 [www.fcu.edu.tw](www.fcu.edu.tw)，是完全沒有辦法上網的，因為我並不知道這個網址對應的 ip 是多少 (像是 140.134.xxx.xxx)，就完全沒有辦法和伺服器產生連線。DNS 出現前，大家都是直接用 ip 溝通，快速方便，最大的缺點就是非常難記。所以 DNS 就出現了，DNS 就像你打電話會需要電話簿一樣，我只我需要一個簡單好記的名字，再去電話簿搜尋真正的電話號碼就好。\n\n在知道電話號碼前，所有網路連線都不會發生，所以用最快速的方式查找電話簿絕對是上網速度最重要的一環，如果光是要知道 ip 位置就花掉 50ms(甚至更多)，上網效率就會大大降低。如今網路上有許多的 DNS 提供商，為大家記下這龐大的 DNS 電話簿，最著名的就是 Google 的 [8.8.8.8](8.8.8.8)，和 Cloudflare 的 [1.1.1.1](1.1.1.1)，Cloudflare 宣稱他是全世界最快的 DNS 提供商，(雖然在台灣好像未必)，但 Cloudflare 承諾他不會**紀錄**使用者查過的 DNS 紀錄，或上過什麼網頁 (好像是在暗示競爭對手會這麼做)。\n\n另外，就算 DNS 伺服器完全不假思索 (沒有反應時間) 就回傳 DNS 的查詢結果，這也付出了至少一個[**光速的代價**](#光速損耗)，聽起來好像沒什麼影響，但可以看看下面簡單的計算。\n\n### 光速損耗\n\n假設我家和 DNS 伺服器之間的直線距離是 100 公里，而且中華電信筆直的連接了一條筆直光纖到 DNS 伺服器，而光在光纖中的速度是 200,000,000 公尺/秒，往返需要 200,000 公尺。經過這樣簡單的計算，光是光速就已經耗費整整 1 毫秒(ms)，可以試著想想看更糟的情況，光速已經開始在嚴重拖累網速。\n\n## Hello Hello OK\n\n知道了 ip 後，瀏覽器終於可以連上目標伺服器取得網頁，不久後就可以看到網頁出現在眼前。\n\n上面的步驟，幾乎都是由 TCP 協定完成，協定的第一步就是你的電腦和伺服器互相同意連線，這個過程稱作三向交握 (Three-Way Handshake)，步驟如下：\n\n1. Client 對 Server 說：Hello\n2. Server 對 Client 說：我聽到你說 Hello\n3. Client 對 Server 說：我聽到 -- 你說你聽到我說 Hello，我們現在可以溝通了。\n\n從上面的步驟就可以發現，已經至少耗費了[一個光速的時間](#光速損耗)，所以也是一樣，伺服器愈靠近用戶，網速就愈快。這也是為什麼 Cloudflare 在世界各地廣設伺服器。\n\n### TLS/SSL\n\n有了 TCP 我們就可以安全的連線了嗎？當然不是，TCP 一點也不安全，現在的網路連線幾乎都是透過 TLS (或稱作 SSL) 加密連線，所以 TCP 連線後，下一步是建立安全的加密連線。\n\nTLS 是一個非常複雜的加密協定，會牽涉到下面的設備：網路瀏覽器、建立鑰匙的伺服器，而且還要有一個可以證明他的身分的伺服器，因為不會想要和銀行建立安全連線，但你根本不確定他是不是你的銀行。\n\n上面的步驟也會需要好幾次[光速損耗](#光速損耗)，所以讓伺服器愈靠近用戶端愈好。另外，也要盡量使用最新的 TLS 標準 (現在是 TLS 1.3)。\n\n## 後記\n\n我覺得這篇文章最有趣的的部分就是一直在討論光速對網路連線的影響，以往我都覺得光速很快，但光就算很快，光也是要跑很長一段距離，這樣耗損來回個幾次就已經對網路連線產生極大的影響了，而且更何況一個連線就一定會需要來回溝通好幾次。這篇文章後面還有蠻多內容，但我覺得沒有那麼重要就懶得寫了，有興趣的話可以自己繼續往下看。\n\n## Reference\n\n- [Welcome to Speed Week and a Waitless Internet](https://blog.cloudflare.com/fastest-internet/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/Cloudflare Speed Week.md","excerpt":"上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。 No one likes to wait. Internet impatienc…","frontmatter":{"title":"Cloudflare Speed Week","date":"2021-10-05T16:10:58.000Z","draft":false,"tags":["cloudflare","web","internet","tcp"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/be2106f3-0557-4e94-803a-9dda63550300/public","description":"上個月看到 Cloudflare 發布了一關於速度週的文章，雖然看起來像是 Cloudflare 廣告自己的產品用的，我細讀後才發現，他詳細了說明了現在在上網時為何會有的網頁可以很快，有的網頁卻慢的跟烏龜一樣，詳細說明網路會遇到的一些困境和原理 (單然解法就是用他們家的產品)，在技術方面值得一讀，我就稍微統整一下。"}}},{"node":{"id":"829e849f-13bc-5b82-8699-88b701b8f0e3","html":"<p>Kotlin 在非同步處理上有新的方法，協程 <code class=\"language-text\">Coroutine</code>。<code class=\"language-text\">Coroutine</code> 不會像 <code class=\"language-text\">Thread</code> 會耗費大量的資源，能在原本的<code class=\"language-text\">線程</code>上創建極為輕量的<code class=\"language-text\">協程</code>，且較不會發生記憶體洩漏的情況。</p>\n<!--more-->\n<h2>導入 Coroutine</h2>\n<p>在 <code class=\"language-text\">build.gradle</code> 中添加依賴項</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">dependencies <span class=\"token punctuation\">{</span>\n    implementation <span class=\"token string\">'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2'</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>若要在 <code class=\"language-text\">Android</code> 中使用需要再添加 <code class=\"language-text\">Android</code> 依賴</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">implementation <span class=\"token string\">'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2'</span></code></pre></div>\n<h2>第一個 Coroutine</h2>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">//在後台啟動一個新的縣協程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//非阻塞式的等待 1 秒鐘</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 阻塞主線程兩秒確保主線程存活</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的程式碼輸出結果：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">Hellow<span class=\"token punctuation\">,</span>\nWorld</code></pre></div>\n<p>基本上 <code class=\"language-text\">Coroutine</code> 就是輕量的協程</p>\n<p>也可以分別將 <code class=\"language-text\">GlobalScope.launch{...}</code> 和 <code class=\"language-text\">delay(...)</code> 替換成<code class=\"language-text\">thread { ... }</code> 和 <code class=\"language-text\">Thread.Sleap(...)</code>，也可以得到相同的結果，可以嘗試一下。</p>\n<p>如果只將 <code class=\"language-text\">GlobalScope.launch{...}</code> 替換成 <code class=\"language-text\">thread{...}</code> 你會得到以下錯誤：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">Error: Kotlin: Suspend functions are only allowed to be called from a coroutine or another <span class=\"token function\">suspend</span> <span class=\"token keyword\">function</span></code></pre></div>\n<p>因為 <code class=\"language-text\">delay()</code> 是一個特殊的 <code class=\"language-text\">suspend function</code> (有人譯作 <code class=\"language-text\">掛起函數</code>)，他不會阻塞線程，但是會 <code class=\"language-text\">suspend</code> 協程，而且只能在協程中使用。</p>\n<h2>橋接阻塞和非阻塞的世界</h2>\n<p>上面的範例中同時使用了非阻塞式的 <code class=\"language-text\">delay()</code> 和阻塞式的 <code class=\"language-text\">Thread.sleap()</code>，這樣很容易讓我們混淆哪個會阻塞線程。下面我們使用 <code class=\"language-text\">runblocking{...}</code> 來阻塞線程</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 在後台啟動一個新的協程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    runBlocking <span class=\"token punctuation\">{</span>     <span class=\"token comment\">// 這個表達式會阻塞主線程</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 延遲兩秒來確保主線程存活</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>結果基本上是相似的，只是都是使用了非組塞式的 <code class=\"language-text\">delay()</code>。調用了 <code class=\"language-text\">runblocking{...}</code> 的主線程會被阻塞直到 <code class=\"language-text\">runblocking{...}</code> 內的協程執行完畢。</p>\n<p>下面用一個更合乎慣用法的方法在寫一次，用 <code class=\"language-text\">runblocking{...}</code> 來包裝 <code class=\"language-text\">main</code> 方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">import</span> kotlinx<span class=\"token punctuation\">.</span>coroutines<span class=\"token punctuation\">.</span><span class=\"token operator\">*</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> runBlocking<span class=\"token operator\">&lt;</span>Unit<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 開始執行主協程</span>\n    GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 在後台啓動一個協程並繼續執行</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000L</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 延遲 2 秒來確保主線程存活</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>這裡的 <code class=\"language-text\">runBlocking {...}</code> 用來啟動主線程。我們顯式指定了其返回類型 <code class=\"language-text\">Unit</code>，因為在 Kotlin 中 <code class=\"language-text\">main</code> 方法必須回傳 <code class=\"language-text\">Unit</code>。</p>\n<h2>等待一個作業完成</h2>\n<p>延遲一段時間來確保協程的運行並不是一個好辦法利用 <code class=\"language-text\">job.join()</code> 來確保工作執行結束。</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job<span class=\"token operator\">:</span> Job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">launch</code> 會回傳一個 <code class=\"language-text\">Job</code> 物件，而 <code class=\"language-text\">job.join()</code> 其實就是會等待 <code class=\"language-text\">job</code> 的工作完成再繼續持行。</p>\n<p>我們也可以利用 <code class=\"language-text\">job.cancel()</code> 取消協程：</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> job<span class=\"token operator\">:</span> Job <span class=\"token operator\">=</span> GlobalScope<span class=\"token punctuation\">.</span><span class=\"token function\">launch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000L</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"World!\"</span></span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Hello,\"</span></span><span class=\"token punctuation\">)</span>\njob<span class=\"token punctuation\">.</span><span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>但是如果 <code class=\"language-text\">job</code> 已經完成工作，<code class=\"language-text\">cancel</code> 是不會發生任何事。</p>\n<h2>參考資料</h2>\n<ul>\n<li><a href=\"https://kotlinlang.org/docs/reference/coroutines/basics.html\">Coroutine Basics</a></li>\n</ul>","rawMarkdownBody":"\nKotlin 在非同步處理上有新的方法，協程 `Coroutine`。`Coroutine` 不會像 `Thread` 會耗費大量的資源，能在原本的`線程`上創建極為輕量的`協程`，且較不會發生記憶體洩漏的情況。\n\n<!--more-->\n\n## 導入 Coroutine\n\n在 `build.gradle` 中添加依賴項\n\n```groovy\ndependencies {\n    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2'\n}\n```\n\n若要在 `Android` 中使用需要再添加 `Android` 依賴\n\n```groovy\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2'\n```\n\n## 第一個 Coroutine\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { //在後台啟動一個新的縣協程\n        delay(1000L) //非阻塞式的等待 1 秒鐘\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    Thread.sleep(2000L) // 阻塞主線程兩秒確保主線程存活\n}\n```\n\n上面的程式碼輸出結果：\n\n```kotlin\nHellow,\nWorld\n```\n\n基本上 `Coroutine` 就是輕量的協程\n\n也可以分別將 `GlobalScope.launch{...}` 和 `delay(...)` 替換成`thread { ... }` 和 `Thread.Sleap(...)`，也可以得到相同的結果，可以嘗試一下。\n\n如果只將 `GlobalScope.launch{...}` 替換成 `thread{...}` 你會得到以下錯誤：\n\n```shell\nError: Kotlin: Suspend functions are only allowed to be called from a coroutine or another suspend function\n```\n\n因為 `delay()` 是一個特殊的 `suspend function` (有人譯作 `掛起函數`)，他不會阻塞線程，但是會 `suspend` 協程，而且只能在協程中使用。\n\n## 橋接阻塞和非阻塞的世界\n\n上面的範例中同時使用了非阻塞式的 `delay()` 和阻塞式的 `Thread.sleap()`，這樣很容易讓我們混淆哪個會阻塞線程。下面我們使用 `runblocking{...}` 來阻塞線程\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() {\n    GlobalScope.launch { // 在後台啟動一個新的協程\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    runBlocking {     // 這個表達式會阻塞主線程\n        delay(2000L)  // 延遲兩秒來確保主線程存活\n    }\n}\n```\n\n結果基本上是相似的，只是都是使用了非組塞式的 `delay()`。調用了 `runblocking{...}` 的主線程會被阻塞直到 `runblocking{...}` 內的協程執行完畢。\n\n下面用一個更合乎慣用法的方法在寫一次，用 `runblocking{...}` 來包裝 `main` 方法：\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> { // 開始執行主協程\n    GlobalScope.launch { // 在後台啓動一個協程並繼續執行\n        delay(1000L)\n        println(\"World!\")\n    }\n    println(\"Hello,\")\n    delay(2000L)  // 延遲 2 秒來確保主線程存活\n}\n```\n\n這裡的 `runBlocking {...}` 用來啟動主線程。我們顯式指定了其返回類型 `Unit`，因為在 Kotlin 中 `main` 方法必須回傳 `Unit`。\n\n## 等待一個作業完成\n\n延遲一段時間來確保協程的運行並不是一個好辦法利用 `job.join()` 來確保工作執行結束。\n\n```kotlin\nval job: Job = GlobalScope.launch {\n    delay(1000L)\n    println(\"World!\")\n}\nprintln(\"Hello,\")\njob.join()\n```\n\n`launch` 會回傳一個 `Job` 物件，而 `job.join()` 其實就是會等待 `job` 的工作完成再繼續持行。\n\n我們也可以利用 `job.cancel()` 取消協程：\n\n```kotlin\nval job: Job = GlobalScope.launch {\n    delay(1000L)\n    println(\"World!\")\n}\nprintln(\"Hello,\")\njob.cancel()\n```\n\n但是如果 `job` 已經完成工作，`cancel` 是不會發生任何事。\n\n## 參考資料\n\n- [Coroutine Basics](https://kotlinlang.org/docs/reference/coroutines/basics.html)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Kotlin/kotlin coroutine.md","excerpt":"Kotlin 在非同步處理上有新的方法，協程 。 不會像  會耗費大量的資源，能在原本的上創建極為輕量的，且較不會發生記憶體洩漏的情況。 導入 Coroutine 在  中添加依賴項 若要在  中使用需要再添加  依賴 第一個 Coroutine 上面的程式碼輸出結果： 基本上  就是輕量的協程 也可以分別將  和  替換成 和 ，也可以得到相同的結果，可以嘗試一下。 如果只將  替換成  你會…","frontmatter":{"title":"Kotlin Coroutine","date":"2021-09-19T07:26:56.000Z","draft":false,"tags":["kotlin","coroutine"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6f11a63e-3923-4ce5-3b6e-d06243815300/public","description":"Kotlin 在非同步處理上有新的方法，協程 Coroutine，Coroutine 不會像 Thread 會耗費大量的資源，能在原本的線程上創建極為輕量的協程，且較不會發生記憶體洩漏的情況。"}}},{"node":{"id":"c18c63aa-34a1-5207-8f88-2ab72f9491df","html":"<p>要在一個 Git 專案中有子專案 (我都叫他 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄 submodule 的路徑和 commit 版本。</p>\n<!--more-->\n<h2>Add Submodule</h2>\n<p>要將專案新增到現有的目錄中，可以使用 <code class=\"language-text\">git submodule add</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> submodule <span class=\"token function\">add</span> <span class=\"token operator\">&lt;</span>repo_url<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>folder<span class=\"token operator\">></span></code></pre></div>\n<p>執行後，可以看到 git 會自動幫你把 submodule clone 到指定的目錄中，並多了一個檔案 <code class=\"language-text\">.gitmodules</code>，這個檔案就是上面說到的 Submodule 只紀錄 commit 版本，和 Submodule URL 的檔案。</p>\n<p>add submodule 後，還是要 commit，因為 Submodule 也就只是紀錄要用子專案的哪一個 commit 版本，所以也可以確保大家都是使用到同一個 Submodule 的版本。可以試著將專案 commit and push 到 GitHub 上，應該可以看到 Submodule 就是連結到另外一個專案的某一個 commit，下面是本站的 Hugo 主題的 submodule：</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c4ba8819-787e-4726-fb58-db317f9ed400/public\" alt=\"image\"></p>\n<h2>Clone Submodule</h2>\n<p>在 Clone 含有 Submodule 的專案時，Git 預設是不會自動 clone 子專案的，需要加上 <code class=\"language-text\">--recursive</code> 這個參數，才會自動把 Submodule 也 Clone 下來。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> clone --recursive <span class=\"token operator\">&lt;</span>repo_url<span class=\"token operator\">></span></code></pre></div>\n<p>如果 Clone 下來後才發現有 Submodule，可以用下面的方式補救，把子專案都 Clone 下來：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> submodule init\n<span class=\"token function\">git</span> submodule update --recursive</code></pre></div>","rawMarkdownBody":"\n要在一個 Git 專案中有子專案 (我都叫他 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄 submodule 的路徑和 commit 版本。\n\n<!--more-->\n\n## Add Submodule\n\n要將專案新增到現有的目錄中，可以使用 `git submodule add`：\n\n```shell\ngit submodule add <repo_url> <folder>\n```\n\n執行後，可以看到 git 會自動幫你把 submodule clone 到指定的目錄中，並多了一個檔案 `.gitmodules`，這個檔案就是上面說到的 Submodule 只紀錄 commit 版本，和 Submodule URL 的檔案。\n\nadd submodule 後，還是要 commit，因為 Submodule 也就只是紀錄要用子專案的哪一個 commit 版本，所以也可以確保大家都是使用到同一個 Submodule 的版本。可以試著將專案 commit and push 到 GitHub 上，應該可以看到 Submodule 就是連結到另外一個專案的某一個 commit，下面是本站的 Hugo 主題的 submodule：\n\n![image](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/c4ba8819-787e-4726-fb58-db317f9ed400/public)\n\n## Clone Submodule\n\n在 Clone 含有 Submodule 的專案時，Git 預設是不會自動 clone 子專案的，需要加上 `--recursive` 這個參數，才會自動把 Submodule 也 Clone 下來。\n\n```shell\ngit clone --recursive <repo_url>\n```\n\n如果 Clone 下來後才發現有 Submodule，可以用下面的方式補救，把子專案都 Clone 下來：\n\n```shell\ngit submodule init\ngit submodule update --recursive\n```\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Git/git submodule.md","excerpt":"要在一個 Git 專案中有子專案 (我都叫他 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄 submodule 的路徑和 commit 版本。 Add Submodule 要將專案新增到現有的目錄中，可以使用 ： 執行後，可以看到 git 會自動幫你把 submodul…","frontmatter":{"title":"Git Submodule","date":"2021-09-14T05:11:27.000Z","draft":false,"tags":["git","submodule","linux"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/6c29c4ca-3fc9-49b2-3109-0876c7492400/public","description":"要在一個 Git 專案中有子專案 (我稱為 git in git)，有兩個辦法，一個是直接 clone 到目錄下，另一個就是使用 submodule。兩者的不同是前者的子專案會在母專案中佔掉所有的空間，而後者只會紀錄"}}},{"node":{"id":"a9e11a01-abab-5de8-b3ae-abccff685c14","html":"<p>在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。</p>\n<!--more-->\n<h2>ssh-keygen</h2>\n<p>要使用 ssh 非對稱加密，就會需要公鑰與私鑰，創建 ssh key 的方法就是 <code class=\"language-text\">ssh-keygen</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">user@66c0bf85e710:~$ ssh-keygen\nGenerating public/private rsa key pair.\nEnter <span class=\"token function\">file</span> <span class=\"token keyword\">in</span> <span class=\"token function\">which</span> to save the key <span class=\"token punctuation\">(</span>/home/user/.ssh/id_rsa<span class=\"token punctuation\">)</span>:\nCreated directory <span class=\"token string\">'/home/user/.ssh'</span><span class=\"token builtin class-name\">.</span>\nEnter passphrase <span class=\"token punctuation\">(</span>empty <span class=\"token keyword\">for</span> no passphrase<span class=\"token punctuation\">)</span>:\nEnter same passphrase again:\nYour identification has been saved <span class=\"token keyword\">in</span> /home/user/.ssh/id_rsa\nYour public key has been saved <span class=\"token keyword\">in</span> /home/user/.ssh/id_rsa.pub\nThe key fingerprint is:\nSHA256:+UUuTN0YLUi2eh7HJoJvuy0whUuLvXIQejjPPTZ9gw4 user@66c0bf85e710\nThe key's randomart image is:\n+---<span class=\"token punctuation\">[</span>RSA <span class=\"token number\">3072</span><span class=\"token punctuation\">]</span>----+\n<span class=\"token operator\">|</span>         .o<span class=\"token punctuation\">..</span>.   <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>         <span class=\"token punctuation\">..</span>o.+.  <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>       <span class=\"token builtin class-name\">.</span>  o +<span class=\"token punctuation\">..</span>  <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>    <span class=\"token builtin class-name\">.</span> o<span class=\"token punctuation\">..</span><span class=\"token operator\">=</span> +     <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>   o <span class=\"token operator\">=</span>.+S * *    <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>  + + *. <span class=\"token operator\">=</span> B     <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>   <span class=\"token operator\">=</span> <span class=\"token assign-left variable\">oE</span><span class=\"token operator\">=</span>o.o      <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>    + Bo+oo      <span class=\"token operator\">|</span>\n<span class=\"token operator\">|</span>     + +++<span class=\"token punctuation\">..</span>     <span class=\"token operator\">|</span>\n+----<span class=\"token punctuation\">[</span>SHA256<span class=\"token punctuation\">]</span>-----+</code></pre></div>\n<p><code class=\"language-text\">ssh-keygen</code> 會問一些問題，最快的方式就是直接留白(保持預設)，一直按 enter 就可以看到已經在 <code class=\"language-text\">~/.ssh</code> 產生了兩個檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">user@66c0bf85e710:~$ <span class=\"token function\">ls</span> -l ~/.ssh\ntotal <span class=\"token number\">8</span>\n-rw------- <span class=\"token number\">1</span> user user <span class=\"token number\">2602</span> Sep <span class=\"token number\">12</span> <span class=\"token number\">22</span>:42 id_rsa\n-rw-r--r-- <span class=\"token number\">1</span> user user  <span class=\"token number\">571</span> Sep <span class=\"token number\">12</span> <span class=\"token number\">22</span>:42 id_rsa.pub\nuser@66c0bf85e710:~$</code></pre></div>\n<p><code class=\"language-text\">id_rsa</code> 就是私鑰，而多個 pub 結尾的 <code class=\"language-text\">id_rsa.pub</code> 就是公鑰。私鑰請不要傳給任何人，公鑰則提供給 GitHub。可以用 cat 將公鑰顯示出來並複製他：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.714d829xbug0.png\" alt=\"image\"></p>\n<h2>把公鑰交給 GitHub</h2>\n<p>到 GitHub 的 Settings -> SSH and GPG keys -> New SSH key：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.5frveu05dt00.png\" alt=\"image\"></p>\n<p>把剛剛複製下來的公鑰貼上，Title 可以自己隨便輸入或打這台電腦的名字：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.56vkhmb55ps0.png\" alt=\"image\"></p>\n<h2>測試連線</h2>\n<p>輸入下面命令就可以知道有沒有連線成功，如果有看到自己的使用者名稱，就代表已經完成 ssh 的認證：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">ssh</span> -T git@github.com</code></pre></div>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.5f99gnzo3ps0.png\" alt=\"image\"></p>\n<p>第一次連線可能會問要不要信任，輸入 <code class=\"language-text\">yes</code> 即可。</p>\n<blockquote>\n<p>如果覺得上面的方法麻煩，也可以直接創建一個私有 repo，然後試著 clone 和 push，就知道有沒有認證成功了。</p>\n</blockquote>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/testing-your-ssh-connection\">Testing your SSH connection</a></li>\n</ul>","rawMarkdownBody":"\n在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。\n\n<!--more-->\n\n## ssh-keygen\n\n要使用 ssh 非對稱加密，就會需要公鑰與私鑰，創建 ssh key 的方法就是 `ssh-keygen`：\n\n```shell\nuser@66c0bf85e710:~$ ssh-keygen\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/user/.ssh/id_rsa):\nCreated directory '/home/user/.ssh'.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/user/.ssh/id_rsa\nYour public key has been saved in /home/user/.ssh/id_rsa.pub\nThe key fingerprint is:\nSHA256:+UUuTN0YLUi2eh7HJoJvuy0whUuLvXIQejjPPTZ9gw4 user@66c0bf85e710\nThe key's randomart image is:\n+---[RSA 3072]----+\n|         .o...   |\n|         ..o.+.  |\n|       .  o +..  |\n|    . o..= +     |\n|   o =.+S * *    |\n|  + + *. = B     |\n|   = oE=o.o      |\n|    + Bo+oo      |\n|     + +++..     |\n+----[SHA256]-----+\n```\n\n`ssh-keygen` 會問一些問題，最快的方式就是直接留白(保持預設)，一直按 enter 就可以看到已經在 `~/.ssh` 產生了兩個檔案：\n\n```shell\nuser@66c0bf85e710:~$ ls -l ~/.ssh\ntotal 8\n-rw------- 1 user user 2602 Sep 12 22:42 id_rsa\n-rw-r--r-- 1 user user  571 Sep 12 22:42 id_rsa.pub\nuser@66c0bf85e710:~$\n```\n\n`id_rsa` 就是私鑰，而多個 pub 結尾的 `id_rsa.pub` 就是公鑰。私鑰請不要傳給任何人，公鑰則提供給 GitHub。可以用 cat 將公鑰顯示出來並複製他：\n\n![image](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.714d829xbug0.png)\n\n## 把公鑰交給 GitHub\n\n到 GitHub 的 Settings -> SSH and GPG keys -> New SSH key：\n\n![image](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.5frveu05dt00.png)\n\n把剛剛複製下來的公鑰貼上，Title 可以自己隨便輸入或打這台電腦的名字：\n\n![image](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.56vkhmb55ps0.png)\n\n## 測試連線\n\n輸入下面命令就可以知道有沒有連線成功，如果有看到自己的使用者名稱，就代表已經完成 ssh 的認證：\n\n```shell\nssh -T git@github.com\n```\n\n![image](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210912/image.5f99gnzo3ps0.png)\n\n第一次連線可能會問要不要信任，輸入 `yes` 即可。\n\n> 如果覺得上面的方法麻煩，也可以直接創建一個私有 repo，然後試著 clone 和 push，就知道有沒有認證成功了。\n\n## Reference\n\n- [Testing your SSH connection](https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh/testing-your-ssh-connection)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Git/github ssh.md","excerpt":"在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。 ssh-keygen 要使用 ssh 非對稱加密，就會需要公鑰與私鑰，創建 ssh key 的方法就是 ：  會問一些問題，最快的方式就是直接留白(保持預設)，一直按 enter 就可以看到已經在  產生了兩個檔案：  就是私鑰，而多個 pub 結尾的…","frontmatter":{"title":"GitHub SSH","date":"2021-09-12T14:32:19.000Z","draft":false,"tags":["git","github","ssh"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/8fdd1b8a-21b2-4d15-9947-a6bdcc6f1000/public","description":"在本機與 GitHub 溝通最安全的方式就是透過 ssh，最大的好處就是不需要輸入帳號密碼來確認身分，也可以享受到 ssh 加密所提供的安全性。"}}},{"node":{"id":"6768d0b8-3c0c-5392-8320-9c2443f08519","html":"<p>紀錄一下我的 <a href=\"https://github.com/TonyPepeBear/cloud-ide-docker\">Cloud IDE Docker</a> 使用方法。</p>\n<!--more-->\n<h2>Pycharm Community</h2>\n<p><a href=\"https://hub.docker.com/r/tonypepe/pycharmc\">Docker Hub</a></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -dp <span class=\"token number\">8887</span>:8887 tonypepe/pycharmc</code></pre></div>","rawMarkdownBody":"\n紀錄一下我的 [Cloud IDE Docker](https://github.com/TonyPepeBear/cloud-ide-docker) 使用方法。\n\n<!--more-->\n\n## Pycharm Community\n\n[Docker Hub](https://hub.docker.com/r/tonypepe/pycharmc)\n\n```bash\ndocker run -dp 8887:8887 tonypepe/pycharmc\n```\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Dev/Cloud Ide Docker.md","excerpt":"紀錄一下我的 Cloud IDE Docker 使用方法。 Pycharm Community Docker Hub","frontmatter":{"title":"Cloud IDE Docker","date":"2021-08-30T08:13:47.000Z","draft":false,"tags":["ide","docker","jetbrains"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/87cfccae-9904-4391-0e52-2b001fffd500/public","description":null}}},{"node":{"id":"b04ee4c4-22aa-519f-a77a-6ab113d7d6a2","html":"<p>Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。</p>\n<!--more-->\n<h2>Docker v.s. VM</h2>\n<p>入門 Docker 最常見的問題就是，Docker 和 VM 差在哪裡？這個問題不難理解，VM 「虛擬機」，顧名思義是虛擬化「硬體」。而 Docker 則是只虛擬化作業系統，或是稱作「軟體」。</p>\n<p>大家都應該知道每創建一個虛擬機，都會耗費掉數分鐘的時間，若還要安裝環境，那耗費的時間則會相當可觀，也會耗費掉相當大的硬體資源。Docker 只虛擬化軟體的優勢，就是可以在幾秒內就啟動服務，耗費資源也相當少，還省去了建立環境的時間。</p>\n<h2>Docker Hub</h2>\n<blockquote>\n<p>Git 有 GitHub，Docker 有 Docker Hub</p>\n</blockquote>\n<p>Docker Hub 是 Docker 官方用來存放 Image 的倉庫 (Registry)，使用者也可以自架 Registry，但是如果未指定 Registry，Docker 預設會去找 Docker Hub 上的 Image。</p>\n<h2>Image</h2>\n<p>Image 通常可以是一個系統，也可以是一個已經安裝好特定執行環境 (像是 JAVA) 的系統。系統部分最常見的會是用 alpine linux，這是一個非常小的項目，只有一個系統，可以讓你在幾秒內就可以啟動服務，許多執行環境也會建構在這個系統上。現在可以先去 Docker Hub 上看看幾個前幾名的 Image，大概就會比較清楚 Image 的功用。</p>\n<p>Docker Image 可以由下列幾方式取得：</p>\n<ul>\n<li>從 Docker Hub 上下載</li>\n<li>由 Dockerfile 構建</li>\n<li>從其他電腦 import</li>\n</ul>\n<h2>Container</h2>\n<p>Docker 用 Image 創建 Container，也就是說，Container 是 Image 的實例，Container 基本上就是一個完整的作業系統，可以執行任何的程式。</p>\n<h2>Docker Run</h2>\n<p>我們簡單創建一個 Ubuntu 的 Container，並且啟動它：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run ubuntu</code></pre></div>\n<p>執行後可以看到 Docker 自動從 Docker Hub 上下載 Ubuntu 的 Image，但是開始執行後卻甚麼都沒發生就結束了。這是因為 Ubuntu 的 Image 預設是啟動一個 Shell，如果沒有 Attach 到 Sheel 上，Container 馬上就結束了。</p>\n<p>所以如果我們要 Attach 到 Ubuntu 的 Shell 上，可以這樣執行：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -it ubuntu</code></pre></div>\n<p>執行應該就會看到我們到 ubuntu 的 Shell 裡。</p>\n<h2>啟動一個網頁服務</h2>\n<p>Nginx 有官方的 Hello Image，可以更清楚的看到 Container 有在執行 Nginx 服務。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -p <span class=\"token number\">8080</span>:80 -d nginxdemos/hello</code></pre></div>\n<p>上面多了一個 <code class=\"language-text\">-p</code> 的參數，後面跟上 <code class=\"language-text\">8080:80</code>，意思是本機的 8080 Port 對到容器的 80 Port，這樣就可以讓我們在本機的 8080 Port 上看到 Nginx 的網頁了。</p>\n<h2>列出、刪除容器</h2>\n<p>列出正在執行的容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">ps</span></code></pre></div>\n<p>列出所有容器，包含已經停止的容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> -a</code></pre></div>\n<p>刪除容器，若是尚未停止的容器則無法刪除：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token operator\">&lt;</span>container_id<span class=\"token operator\">></span></code></pre></div>\n<p>加上 <code class=\"language-text\">-f</code> 參數，可強制刪除執行中的容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> -f <span class=\"token operator\">&lt;</span>container_id<span class=\"token operator\">></span></code></pre></div>\n<p>強制刪除所有容器：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> <span class=\"token function\">rm</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">docker</span> <span class=\"token function\">ps</span> -aq<span class=\"token variable\">)</span></span></code></pre></div>\n<h2>創建自己的 Image</h2>\n<p>要教 Docker 怎麼創建 Image，需要先建立一個 <code class=\"language-text\">Dockerfile</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> ubuntu:latest</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> apt update <span class=\"token operator\">\\</span>\n    &amp;&amp; apt install vim git -y <span class=\"token operator\">\\</span>\n    &amp;&amp; rm -rf /var/lib/apt/lists/*</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"/bin/bash\"</span>]</span></code></pre></div>\n<p>Build Image:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> build -t my-ubuntu <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>注意上面的指令的最後面有一個 <code class=\"language-text\">.</code>，代表 Build 這個目錄。<code class=\"language-text\">-t</code> 的參數則是 Image 的名稱，或是稱作 Tag。</p>","rawMarkdownBody":"\nDocker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。\n\n<!--more-->\n\n## Docker v.s. VM\n\n入門 Docker 最常見的問題就是，Docker 和 VM 差在哪裡？這個問題不難理解，VM 「虛擬機」，顧名思義是虛擬化「硬體」。而 Docker 則是只虛擬化作業系統，或是稱作「軟體」。\n\n大家都應該知道每創建一個虛擬機，都會耗費掉數分鐘的時間，若還要安裝環境，那耗費的時間則會相當可觀，也會耗費掉相當大的硬體資源。Docker 只虛擬化軟體的優勢，就是可以在幾秒內就啟動服務，耗費資源也相當少，還省去了建立環境的時間。\n\n## Docker Hub\n\n> Git 有 GitHub，Docker 有 Docker Hub\n\nDocker Hub 是 Docker 官方用來存放 Image 的倉庫 (Registry)，使用者也可以自架 Registry，但是如果未指定 Registry，Docker 預設會去找 Docker Hub 上的 Image。\n\n## Image\n\nImage 通常可以是一個系統，也可以是一個已經安裝好特定執行環境 (像是 JAVA) 的系統。系統部分最常見的會是用 alpine linux，這是一個非常小的項目，只有一個系統，可以讓你在幾秒內就可以啟動服務，許多執行環境也會建構在這個系統上。現在可以先去 Docker Hub 上看看幾個前幾名的 Image，大概就會比較清楚 Image 的功用。\n\nDocker Image 可以由下列幾方式取得：\n\n- 從 Docker Hub 上下載\n- 由 Dockerfile 構建\n- 從其他電腦 import\n\n## Container\n\nDocker 用 Image 創建 Container，也就是說，Container 是 Image 的實例，Container 基本上就是一個完整的作業系統，可以執行任何的程式。\n\n## Docker Run\n\n我們簡單創建一個 Ubuntu 的 Container，並且啟動它：\n\n```bash\ndocker run ubuntu\n```\n\n執行後可以看到 Docker 自動從 Docker Hub 上下載 Ubuntu 的 Image，但是開始執行後卻甚麼都沒發生就結束了。這是因為 Ubuntu 的 Image 預設是啟動一個 Shell，如果沒有 Attach 到 Sheel 上，Container 馬上就結束了。\n\n所以如果我們要 Attach 到 Ubuntu 的 Shell 上，可以這樣執行：\n\n```bash\ndocker run -it ubuntu\n```\n\n執行應該就會看到我們到 ubuntu 的 Shell 裡。\n\n## 啟動一個網頁服務\n\nNginx 有官方的 Hello Image，可以更清楚的看到 Container 有在執行 Nginx 服務。\n\n```bash\ndocker run -p 8080:80 -d nginxdemos/hello\n```\n\n上面多了一個 `-p` 的參數，後面跟上 `8080:80`，意思是本機的 8080 Port 對到容器的 80 Port，這樣就可以讓我們在本機的 8080 Port 上看到 Nginx 的網頁了。\n\n## 列出、刪除容器\n\n列出正在執行的容器：\n\n```bash\ndocker ps\n```\n\n列出所有容器，包含已經停止的容器：\n\n```bash\ndocker ps -a\n```\n\n刪除容器，若是尚未停止的容器則無法刪除：\n\n```bash\ndocker rm <container_id>\n```\n\n加上 `-f` 參數，可強制刪除執行中的容器：\n\n```bash\ndocker rm -f <container_id>\n```\n\n強制刪除所有容器：\n\n```bash\ndocker rm $(docker ps -aq)\n```\n\n## 創建自己的 Image\n\n要教 Docker 怎麼創建 Image，需要先建立一個 `Dockerfile`：\n\n```dockerfile\nFROM ubuntu:latest\n\nRUN apt update \\\n    && apt install vim git -y \\\n    && rm -rf /var/lib/apt/lists/*\n\nCMD [\"/bin/bash\"]\n```\n\nBuild Image:\n\n```bash\ndocker build -t my-ubuntu .\n```\n\n注意上面的指令的最後面有一個 `.`，代表 Build 這個目錄。`-t` 的參數則是 Image 的名稱，或是稱作 Tag。\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Docker/docker.md","excerpt":"Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。 Docker v.s. VM 入門 Docker 最常見的問題就是，Docker 和 VM 差在哪裡？這個問題不難理解，VM 「虛擬機」，顧名思義是虛擬化「硬體」。而 Docker 則是只虛擬…","frontmatter":{"title":"Docker","date":"2021-08-25T18:31:57.000Z","draft":false,"tags":["docker"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/a45b7e65-d6dd-4ef5-23b4-44e2090c5b00/public","description":"Docker 是一個虛擬化技術，可以將我們編寫好的程式包裹成一個小的「容器」，再發佈到伺服器上。Docker 解決了困擾程式界多年來的環境問題，只要伺服器安裝了 Docker 就可以確保一定可以執行服務。"}}},{"node":{"id":"0328ae6c-1fa1-50d8-aec1-a55575fe59b5","html":"<p>Cloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。</p>\n<p>我覺得目前的缺點就是網路上相關的資料比較少，遇到問題很難找到資料參考，因為他其實主要是 Cloudflare 的一項零信任服務，目標客群都是一些厲害的網管，所以官方寫的文件也都很深奧，如果是新手可能會頭昏眼花。</p>\n<!--more-->\n<p>這一項服務可以先不用帳號就能試用，不過就不能自訂 Domain，我會先介紹免登入的，再介紹要登入的。第一步還是要在本地先安裝環境。</p>\n<h2>安裝 cloudflared</h2>\n<h3>全系統適用</h3>\n<p>注意 Cloudflare 後面多了一個 <code class=\"language-text\">d</code>，這是他連上 Tunnel 的必要程式，是用 Go 編寫，安裝方式就是到<a href=\"https://github.com/cloudflare/cloudflared/releases\">官方 Github</a>下載符合自己環境的執行檔。</p>\n<h3>macOS</h3>\n<p>mac 可以用 Homebrew 安裝：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">brew install cloudflare/cloudflare/cloudflared</code></pre></div>\n<h3>Windows</h3>\n<p>Windows 永遠是最麻煩的，下載完執行檔後，隨便丟到一個資料夾，然後加到 PATH 裡。</p>\n<h3>Update</h3>\n<p>要更新這個執行檔，只要 Run 下面的指令，另外，Windows 不支援自動更新，要更新就只能手動下載覆蓋：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared update</code></pre></div>\n<h2>免登入測試 Tunnel</h2>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel --url http://localhost:8080</code></pre></div>\n<p>執行上面的指令，就可以將本地電腦的 8080 port 用 http 公開到網路上，應該會看到輸出中會給一串個 <code class=\"language-text\">*-*-*.trycloudflare.com</code> 的網址，現在只要訪問那個網址，就可以發現本地的網頁已經可以從全網連到，不需註冊，也不用設定複雜的 Domain，還不限流量。</p>\n<h2>登入 Cloudflare</h2>\n<p>第一步就是先登入 Cloudflare 的帳號，也要有一個已經託管給 Cloudflare 的 Domain：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel login</code></pre></div>\n<p>執行這個命令後，應該會跳出瀏覽器授權，如果沒有跳出，就手動複製提供的授權網址登入 Cloudflare 帳號。</p>\n<h2>創建並使用 Tunnel</h2>\n<p>登入完成後就可以開始創建通道，創建只會在本地產生一些文件，並不會有任何連線的動作，可以放心執行：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel create &lt;Name&gt;</code></pre></div>\n<p>創建完成後，Cloudflare 會給一組 UUID，可以看一下有沒有創建成功：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel list</code></pre></div>\n<p>如果要刪除就是 Delete：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel delete &lt;Name or UUID&gt;</code></pre></div>\n<h2>DNS 設定</h2>\n<p>在創建 Tunnel 後，Cloudflare 會將剛剛創建隧道時產生的 UUID 綁定到 <code class=\"language-text\">&lt;UUID>.cfargotunnel.com</code> 這個 Domain，不過 Cloudflare 會擋掉用這個 Domain 直接連線的流量，所以我們要把我們的 Domain 新增一個 CNAME 紀錄，把流量往這邊導。</p>\n<p>有兩個方法可以設定 CNAME，一個是自己去 Cloudflare 的官網設定：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210813165733.png\" alt=\"img\"></p>\n<p>另一個是直接用指令設定，快又方便，把後面的 domain 改成自己想要綁定的：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel route dns &lt;Name or UUID&gt; test.example.com</code></pre></div>\n<p>打完後如果不放心，還是可以自己到 Cloudflare 的 Dns 設定看一下有沒有設定完成，應該會看到跟上圖一樣產生一個 CNAME Record。</p>\n<h2>Tunnel Config</h2>\n<p>下面是最簡單的 Config 範例，這是一個 <code class=\"language-text\">yml</code> 檔案：</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">tunnel</span><span class=\"token punctuation\">:</span> &lt;Name<span class=\"token punctuation\">></span>\n\n<span class=\"token key atrule\">ingress</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">hostname</span><span class=\"token punctuation\">:</span> test.example.com\n    <span class=\"token key atrule\">service</span><span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">:</span>//localhost<span class=\"token punctuation\">:</span><span class=\"token number\">8080</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">service</span><span class=\"token punctuation\">:</span> http_status<span class=\"token punctuation\">:</span><span class=\"token number\">404</span></code></pre></div>\n<p>上面會把 8080 的 HTTP 流量導到 <code class=\"language-text\">domain.example.com</code>，使用剛剛創建的 Tunnel。</p>\n<p>最後一行一定要有一個可以接受所有流量的 Service，不然服務會不能啟動，這裡全部往 404 導。</p>\n<h2>Run Tunnel</h2>\n<p>最後一步，加上 config 的參數，把剛剛的 yml 檔喂給 Cloudflare，就可以啟動通道了：</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">cloudflared tunnel --config test.yml run</code></pre></div>\n<h2>後記</h2>\n<p>這篇只介紹了如何創建一個 Http 的 Tunnel，如果要開其他的 TCP Port，還需要其他的設定，而且在 Client 端也會需要安裝 Cloudflared，所以我留到下一篇在介紹。</p>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://developers.cloudflare.com/cloudflare-one/\">Cloudflare for Teams documentation</a></li>\n</ul>","rawMarkdownBody":"\nCloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。\n\n我覺得目前的缺點就是網路上相關的資料比較少，遇到問題很難找到資料參考，因為他其實主要是 Cloudflare 的一項零信任服務，目標客群都是一些厲害的網管，所以官方寫的文件也都很深奧，如果是新手可能會頭昏眼花。\n\n<!--more-->\n\n這一項服務可以先不用帳號就能試用，不過就不能自訂 Domain，我會先介紹免登入的，再介紹要登入的。第一步還是要在本地先安裝環境。\n\n## 安裝 cloudflared\n\n### 全系統適用\n\n注意 Cloudflare 後面多了一個 `d`，這是他連上 Tunnel 的必要程式，是用 Go 編寫，安裝方式就是到[官方 Github](https://github.com/cloudflare/cloudflared/releases)下載符合自己環境的執行檔。\n\n### macOS\n\nmac 可以用 Homebrew 安裝：\n\n```sh\nbrew install cloudflare/cloudflare/cloudflared\n```\n\n### Windows\n\nWindows 永遠是最麻煩的，下載完執行檔後，隨便丟到一個資料夾，然後加到 PATH 裡。\n\n### Update\n\n要更新這個執行檔，只要 Run 下面的指令，另外，Windows 不支援自動更新，要更新就只能手動下載覆蓋：\n\n```sh\ncloudflared update\n```\n\n## 免登入測試 Tunnel\n\n```sh\ncloudflared tunnel --url http://localhost:8080\n```\n\n執行上面的指令，就可以將本地電腦的 8080 port 用 http 公開到網路上，應該會看到輸出中會給一串個 `*-*-*.trycloudflare.com` 的網址，現在只要訪問那個網址，就可以發現本地的網頁已經可以從全網連到，不需註冊，也不用設定複雜的 Domain，還不限流量。\n\n## 登入 Cloudflare\n\n第一步就是先登入 Cloudflare 的帳號，也要有一個已經託管給 Cloudflare 的 Domain：\n\n```sh\ncloudflared tunnel login\n```\n\n執行這個命令後，應該會跳出瀏覽器授權，如果沒有跳出，就手動複製提供的授權網址登入 Cloudflare 帳號。\n\n## 創建並使用 Tunnel\n\n登入完成後就可以開始創建通道，創建只會在本地產生一些文件，並不會有任何連線的動作，可以放心執行：\n\n```sh\ncloudflared tunnel create <Name>\n```\n\n創建完成後，Cloudflare 會給一組 UUID，可以看一下有沒有創建成功：\n\n```sh\ncloudflared tunnel list\n```\n\n如果要刪除就是 Delete：\n\n```sh\ncloudflared tunnel delete <Name or UUID>\n```\n\n## DNS 設定\n\n在創建 Tunnel 後，Cloudflare 會將剛剛創建隧道時產生的 UUID 綁定到 `<UUID>.cfargotunnel.com` 這個 Domain，不過 Cloudflare 會擋掉用這個 Domain 直接連線的流量，所以我們要把我們的 Domain 新增一個 CNAME 紀錄，把流量往這邊導。\n\n有兩個方法可以設定 CNAME，一個是自己去 Cloudflare 的官網設定：\n\n![img](https://cdn.jsdelivr.net/gh/TonyPepeBear/ImageBed@main/20210813165733.png)\n\n另一個是直接用指令設定，快又方便，把後面的 domain 改成自己想要綁定的：\n\n```sh\ncloudflared tunnel route dns <Name or UUID> test.example.com\n```\n\n打完後如果不放心，還是可以自己到 Cloudflare 的 Dns 設定看一下有沒有設定完成，應該會看到跟上圖一樣產生一個 CNAME Record。\n\n## Tunnel Config\n\n下面是最簡單的 Config 範例，這是一個 `yml` 檔案：\n\n```yml\ntunnel: <Name>\n\ningress:\n  - hostname: test.example.com\n    service: http://localhost:8080\n  - service: http_status:404\n```\n\n上面會把 8080 的 HTTP 流量導到 `domain.example.com`，使用剛剛創建的 Tunnel。\n\n最後一行一定要有一個可以接受所有流量的 Service，不然服務會不能啟動，這裡全部往 404 導。\n\n## Run Tunnel\n\n最後一步，加上 config 的參數，把剛剛的 yml 檔喂給 Cloudflare，就可以啟動通道了：\n\n```sh\ncloudflared tunnel --config test.yml run\n```\n\n## 後記\n\n這篇只介紹了如何創建一個 Http 的 Tunnel，如果要開其他的 TCP Port，還需要其他的設定，而且在 Client 端也會需要安裝 Cloudflared，所以我留到下一篇在介紹。\n\n## Reference\n\n- [Cloudflare for Teams documentation](https://developers.cloudflare.com/cloudflare-one/)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Web/Cloudflare Tunnel.md","excerpt":"Cloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。 我覺得目前的缺點就是網路上相關的資料比較少，遇到問題很難找到資料參考，因為他其實主要是 Cloudflare 的一項零信任服務，目標…","frontmatter":{"title":"Cloudflare Tunnel","date":"2021-08-13T07:17:39.000Z","draft":false,"tags":["cloudflare","tunnel","teams","cloudflare-tunnel"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/00e85cf1-4c03-45ea-004c-f61e6216d400/public","description":"Cloudflare 真的是佛心公司，提供免費的 DNS、DDoS 防護，還可以拿來託管靜態網頁，而今天是介紹他們公司的 Tunnel，這個服務可以將本地電腦的特定 port 開放到網路上，而且完全免費，在台灣的速度也不慢，真的很佛，幾乎等於拿到免費的 IPv4。"}}},{"node":{"id":"acc7e2df-e6e5-5c7a-aa49-4f23527be703","html":"<p>簡單記錄我所認知的 A320 的一些程序。</p>\n<!--more-->\n<blockquote>\n<p>注意這些都不是標準程序，只是我自己亂理解的，也省去蠻多步驟，基本上就是能起讓飛機動起來，標準程序肯定是更複雜的。</p>\n</blockquote>\n<h2>啟動飛機前檢查</h2>\n<p><del>模擬器中跳過還是可以飛</del></p>\n<ol>\n<li>Engine Master 1 and 2 Switch -> OFF\n<ul>\n<li>主引擎 1, 2 都關閉</li>\n</ul>\n</li>\n<li>Engine Mode Selector -> NORM\n<ul>\n<li>引擎模式在 Normal 位置</li>\n</ul>\n</li>\n<li>Weather Radar -> OFF\n<ul>\n<li>關閉氣象雷達</li>\n</ul>\n</li>\n<li>Landing Gear -> Down\n<ul>\n<li>機輪放下</li>\n</ul>\n</li>\n<li>Wipers -> Both OFF\n<ul>\n<li>兩個雨刷都關閉</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/7e29f7e1-bf0b-44d4-7589-29286ed81b00/large\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/ca5109ba-4baf-40e3-850e-ee4002882c00/large\" alt=\"img\"></p>\n<h2>啟動飛機</h2>\n<ol>\n<li>Batt 1 and 2 -> ON</li>\n<li>EXT Power -> ON\n<ul>\n<li>啟動外部電源</li>\n<li>這時應該可以看到所有儀表亮起</li>\n</ul>\n</li>\n<li>APU Fire Test\n<ul>\n<li>APU 滅火測試</li>\n</ul>\n</li>\n<li>APU Master and wait 3 sec -> ON\n<ul>\n<li>打開 APU 主開關，並等待 3 秒</li>\n</ul>\n</li>\n<li>APU START -> ON\n<ul>\n<li>發動 APU</li>\n</ul>\n</li>\n<li>Wait for APU START -> Green \"AVAIL\"\n<ul>\n<li>等 APU 發動完成</li>\n</ul>\n</li>\n<li>APU BLEED -> ON\n<ul>\n<li>開啟 APU 供給氣壓</li>\n</ul>\n</li>\n<li>EXT Power -> OFF\n<ul>\n<li>移除外部電源</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/bcc428a6-c065-4bc3-0d19-ad204b860700/large\" alt=\"img\"></p>\n<h2>Overhead Panel 上方儀表</h2>\n<p>基本上，由左至右，由下而上的檢查</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4aa17d2f-419c-40e6-09f8-e31ca2833a00/large\" alt=\"img\"></p>\n<h3>左邊那排</h3>\n<ol>\n<li>CREW SUPPLY -> ON\n<ul>\n<li>打開組員氧氣供給</li>\n</ul>\n</li>\n<li>ADIRS 1, 2, 3 -> NAV\n<ul>\n<li>開啟三個慣性導航，需等待 6-7 分鐘校準</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b25f2e34-5ff9-4534-4fc2-927961a5ce00/large\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/16fb299e-1847-4767-8093-aa0d058cd400/large\" alt=\"img\"></p>\n<h3>中間那排</h3>\n<ol>\n<li>NAV &#x26; LOGO Light -> ON</li>\n<li>OVHD INTEG LT -> AS REQ.</li>\n<li>DOME LT -> AS REQ.</li>\n<li>ANN LT TEST</li>\n<li>EMER EXIT LT -> ARM</li>\n<li>SEAT BELTS -> ON</li>\n<li>NO SMOKING -> ON</li>\n<li>ALL PUMP -> ON</li>\n<li>ENG 1 FIRE TEST</li>\n<li>ENG 2 FIRE TEST</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/e5f05a70-bc36-4bc3-fff2-61f413e6b900/large\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/613ca5d3-3519-4c5d-cb82-4f9371e1d500/large\" alt=\"img\"></p>\n<h3>右邊那排</h3>\n<p>基本上不用動</p>\n<h2>MCDU 飛行電腦</h2>\n<p>在等待導航校準時，來設定飛行電腦。設定飛行電腦有一個口訣：</p>\n<blockquote>\n<p>D > I > F > S > R > I > P > P</p>\n</blockquote>\n<ul>\n<li>DATA</li>\n<li>INIT A</li>\n<li>F-PLN</li>\n<li>SEC PLAN</li>\n<li>RAD NAV</li>\n<li>INIT B</li>\n<li>PREF</li>\n<li>PROG</li>\n</ul>\n<blockquote>\n<p>飛行電腦設定蠻複雜的，本文就先跳過詳細步驟，專注在冷操到起飛。</p>\n</blockquote>\n<h2>後推 and 啟動引擎前檢查</h2>\n<p>記得等 IRS 校準完後再後推。</p>\n<ol>\n<li>申請後推</li>\n<li>BECON Light -> ON\n<ul>\n<li>啟動 BECAON 燈</li>\n</ul>\n</li>\n<li>Trust Levers -> IDLE\n<ul>\n<li>確定推力桿在 IDLE</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f3d16c92-7e28-4b76-c106-458211015c00/public\" alt=\"img\"></p>\n<p>在 MSFS 的 FlyByWire 中可以用旁邊的 FlyPad 申請後推。</p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/71f815a8-11e0-4d0b-38a5-2de486a4e000/public\" alt=\"img\"></p>\n<h2>啟動引擎</h2>\n<ol>\n<li>ENG MODE selector -> IGN/START\n<ul>\n<li>把 ENG MODE selector 轉到右邊的啟動引擎模式</li>\n</ul>\n</li>\n<li>ENGINE 2 START -> ON\n<ul>\n<li>啟動右邊的 2 號引擎</li>\n<li>我也不知道為甚麼都是先啟動 2 號引擎</li>\n<li>等待發動完成後再發動 1 號引擎</li>\n<li>發動時應監控引擎數據，19% N1, 68% N2, 520°C EGT, 290 kg/h FF，等待 2 號引擎 AVAIL 字樣出現</li>\n</ul>\n</li>\n<li>ENGINE 1 START -> ON\n<ul>\n<li>啟動左邊的 1 號引擎，重複第 2 步直到 1 號引擎 AVAIL 字樣出現</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/1e82de0e-18d0-402e-b279-780fe5f6b800/public\" alt=\"img\"></p>\n<p><img src=\"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d164d67d-9afb-4bd6-2eb9-835d7fe24300/public\" alt=\"img\"></p>\n<h2>啟動引擎後</h2>\n<ol>\n<li>ENG MODE selectgor -> NORM\n<ul>\n<li>引擎模式轉回中間 NORM</li>\n</ul>\n</li>\n<li>APU Bleed -> OFF\n<ul>\n<li>關閉 APU 供氣</li>\n</ul>\n</li>\n<li>APU MASTER -> OFF\n<ul>\n<li>關閉 APU</li>\n</ul>\n</li>\n<li>FLAPS lever -> SET TAKEOFF POSITION\n<ul>\n<li>放出襟翼到起飛需要的位置</li>\n</ul>\n</li>\n</ol>\n<h2>滑行 Taxi</h2>\n<ol>\n<li>NOSE Light -> Taxi\n<ul>\n<li>開啟滑行燈</li>\n</ul>\n</li>\n<li>RWY TURN OFF -> ON\n<ul>\n<li>開啟脫離跑道燈 (轉彎燈)</li>\n</ul>\n</li>\n<li>PARK BRK -> OFF\n<ul>\n<li>關閉手煞車</li>\n</ul>\n</li>\n<li>AUTO BRK MAX -> ON\n<ul>\n<li>開啟最大自動煞車</li>\n</ul>\n</li>\n</ol>\n<h2>起飛</h2>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"https://www.youtube.com/channel/UCDKKDx4mNVI7vONL1vqTx7g\">教官我想飛</a></li>\n<li><a href=\"https://www.youtube.com/channel/UCOHc8xzWD25Nn-snDBJUMGQ\">機師阿楷</a></li>\n<li><a href=\"https://github.com/flybywiresim/manuals/blob/master/pdf/A32NX%20Documentation/FBW%20A32NX%20Checklist.pdf\">FBW A32NX Checklist.pdf</a></li>\n<li><a href=\"https://github.com/flybywiresim/manuals/blob/master/pdf/A32NX%20Documentation/FBW%20A32NX%20SOP.pdf\">FBW A32NX SOP.pdf</a></li>\n</ul>","rawMarkdownBody":"\n簡單記錄我所認知的 A320 的一些程序。\n\n<!--more-->\n\n> 注意這些都不是標準程序，只是我自己亂理解的，也省去蠻多步驟，基本上就是能起讓飛機動起來，標準程序肯定是更複雜的。\n\n## 啟動飛機前檢查\n\n~~模擬器中跳過還是可以飛~~\n\n1. Engine Master 1 and 2 Switch -> OFF\n   - 主引擎 1, 2 都關閉\n2. Engine Mode Selector -> NORM\n   - 引擎模式在 Normal 位置\n3. Weather Radar -> OFF\n   - 關閉氣象雷達\n4. Landing Gear -> Down\n   - 機輪放下\n5. Wipers -> Both OFF\n   - 兩個雨刷都關閉\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/7e29f7e1-bf0b-44d4-7589-29286ed81b00/large)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/ca5109ba-4baf-40e3-850e-ee4002882c00/large)\n\n## 啟動飛機\n\n1. Batt 1 and 2 -> ON\n2. EXT Power -> ON\n   - 啟動外部電源\n   - 這時應該可以看到所有儀表亮起\n3. APU Fire Test\n   - APU 滅火測試\n4. APU Master and wait 3 sec -> ON\n   - 打開 APU 主開關，並等待 3 秒\n5. APU START -> ON\n   - 發動 APU\n6. Wait for APU START -> Green \"AVAIL\"\n   - 等 APU 發動完成\n7. APU BLEED -> ON\n   - 開啟 APU 供給氣壓\n8. EXT Power -> OFF\n   - 移除外部電源\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/bcc428a6-c065-4bc3-0d19-ad204b860700/large)\n\n## Overhead Panel 上方儀表\n\n基本上，由左至右，由下而上的檢查\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/4aa17d2f-419c-40e6-09f8-e31ca2833a00/large)\n\n### 左邊那排\n\n1. CREW SUPPLY -> ON\n   - 打開組員氧氣供給\n2. ADIRS 1, 2, 3 -> NAV\n   - 開啟三個慣性導航，需等待 6-7 分鐘校準\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/b25f2e34-5ff9-4534-4fc2-927961a5ce00/large)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/16fb299e-1847-4767-8093-aa0d058cd400/large)\n\n### 中間那排\n\n1. NAV & LOGO Light -> ON\n2. OVHD INTEG LT -> AS REQ.\n3. DOME LT -> AS REQ.\n4. ANN LT TEST\n5. EMER EXIT LT -> ARM\n6. SEAT BELTS -> ON\n7. NO SMOKING -> ON\n8. ALL PUMP -> ON\n9. ENG 1 FIRE TEST\n10. ENG 2 FIRE TEST\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/e5f05a70-bc36-4bc3-fff2-61f413e6b900/large)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/613ca5d3-3519-4c5d-cb82-4f9371e1d500/large)\n\n### 右邊那排\n\n基本上不用動\n\n## MCDU 飛行電腦\n\n在等待導航校準時，來設定飛行電腦。設定飛行電腦有一個口訣：\n\n> D > I > F > S > R > I > P > P\n\n- DATA\n- INIT A\n- F-PLN\n- SEC PLAN\n- RAD NAV\n- INIT B\n- PREF\n- PROG\n\n> 飛行電腦設定蠻複雜的，本文就先跳過詳細步驟，專注在冷操到起飛。\n\n## 後推 and 啟動引擎前檢查\n\n記得等 IRS 校準完後再後推。\n\n1. 申請後推\n2. BECON Light -> ON\n   - 啟動 BECAON 燈\n3. Trust Levers -> IDLE\n   - 確定推力桿在 IDLE\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/f3d16c92-7e28-4b76-c106-458211015c00/public)\n\n在 MSFS 的 FlyByWire 中可以用旁邊的 FlyPad 申請後推。\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/71f815a8-11e0-4d0b-38a5-2de486a4e000/public)\n\n## 啟動引擎\n\n1. ENG MODE selector -> IGN/START\n   - 把 ENG MODE selector 轉到右邊的啟動引擎模式\n2. ENGINE 2 START -> ON\n   - 啟動右邊的 2 號引擎\n   - 我也不知道為甚麼都是先啟動 2 號引擎\n   - 等待發動完成後再發動 1 號引擎\n   - 發動時應監控引擎數據，19% N1, 68% N2, 520°C EGT, 290 kg/h FF，等待 2 號引擎 AVAIL 字樣出現\n3. ENGINE 1 START -> ON\n   - 啟動左邊的 1 號引擎，重複第 2 步直到 1 號引擎 AVAIL 字樣出現\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/1e82de0e-18d0-402e-b279-780fe5f6b800/public)\n\n![img](https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/d164d67d-9afb-4bd6-2eb9-835d7fe24300/public)\n\n## 啟動引擎後\n\n1. ENG MODE selectgor -> NORM\n   - 引擎模式轉回中間 NORM\n2. APU Bleed -> OFF\n   - 關閉 APU 供氣\n3. APU MASTER -> OFF\n   - 關閉 APU\n4. FLAPS lever -> SET TAKEOFF POSITION\n   - 放出襟翼到起飛需要的位置\n\n## 滑行 Taxi\n\n1. NOSE Light -> Taxi\n   - 開啟滑行燈\n2. RWY TURN OFF -> ON\n   - 開啟脫離跑道燈 (轉彎燈)\n3. PARK BRK -> OFF\n   - 關閉手煞車\n4. AUTO BRK MAX -> ON\n   - 開啟最大自動煞車\n\n## 起飛\n\n## Reference\n\n- [教官我想飛](https://www.youtube.com/channel/UCDKKDx4mNVI7vONL1vqTx7g)\n- [機師阿楷](https://www.youtube.com/channel/UCOHc8xzWD25Nn-snDBJUMGQ)\n- [FBW A32NX Checklist.pdf](https://github.com/flybywiresim/manuals/blob/master/pdf/A32NX%20Documentation/FBW%20A32NX%20Checklist.pdf)\n- [FBW A32NX SOP.pdf](https://github.com/flybywiresim/manuals/blob/master/pdf/A32NX%20Documentation/FBW%20A32NX%20SOP.pdf)\n","fileAbsolutePath":"/home/runner/work/Blog/Blog/src/posts/Flight/A320 Note.md","excerpt":"簡單記錄我所認知的 A320 的一些程序。 注意這些都不是標準程序，只是我自己亂理解的，也省去蠻多步驟，基本上就是能起讓飛機動起來，標準程序肯定是更複雜的。 啟動飛機前檢查 模擬器中跳過還是可以飛 Engine Master 1 and 2 Switch -> OFF 主引擎 1, 2 都關閉 Engine Mode Selector -> NORM 引擎模式在 Normal 位置 Weathe…","frontmatter":{"title":"A320neo 冷艙到飛行","date":"2021-07-21T14:08:20.000Z","draft":false,"tags":["a320neo","airbus","msfs"],"image":"https://imagedelivery.net/cdkaXPuFls5qlrh3GM4hfA/06a43a08-dc77-48eb-9f4a-f47a29566900/public","description":"簡單記錄我所認知的 A320 的一些程序。"}}}]}},"pageContext":{"limit":8,"skip":16,"numPages":5,"currentPage":3}},"staticQueryHashes":[]}